<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Scikit-Learn与TensorFlow机器学习实用指南-1</title>
      <link href="/posts/Scikit-Learn%E4%B8%8ETensorFlow%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97-1/"/>
      <url>/posts/Scikit-Learn%E4%B8%8ETensorFlow%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>一、简介</p><p>很多机器学习的问题都会涉及到有着几千甚至数百万维的特征的训练实例。这不仅让训练过程变得非常缓慢，同时还很难找到一个很好的解，我们接下来就会遇到这种情况。这种问题通常被称为维数灾难（curse of dimentionality）。</p><p>幸运的是，在现实生活中我们经常可以极大的降低特征维度，将一个十分棘手的问题转变成一个可以较为容易解决的问题。例如，对于 MNIST 图片集（第 3 章中提到）：图片四周边缘部分的像素几乎总是白的，因此你完全可以将这些像素从你的训练集中扔掉而不会丢失太多信息。图 7-6 向我们证实了这些像素的确对我们的分类任务是完全不重要的。同时，两个相邻的像素往往是高度相关的：如果你想要将他们合并成一个像素（比如取这两个像素点的平均值）你并不会丢失很多信息。</p><p>警告：降维肯定会丢失一些信息（这就好比将一个图片压缩成 JPEG 的格式会降低图像的质量），因此即使这种方法可以加快训练的速度，同时也会让你的系统表现的稍微差一点。降维会让你的工作流水线更复杂因而更难维护。所有你应该先尝试使用原始的数据来训练，如果训练速度太慢的话再考虑使用降维。在某些情况下，降低训练集数据的维度可能会筛选掉一些噪音和不必要的细节，这可能会让你的结果比降维之前更好（这种情况通常不会发生；它只会加快你训练的速度）。</p><p>降维除了可以加快训练速度外，在数据可视化方面（或者 DataViz）也十分有用。降低特征维度到 2（或者 3）维从而可以在图中画出一个高维度的训练集，让我们可以通过视觉直观的发现一些非常重要的信息，比如聚类。</p><p>在这一章里，我们将会讨论维数灾难问题并且了解在高维空间的数据。然后，我们将会展示两种主要的降维方法：投影（projection）和流形学习（Manifold Learning），同时我们还会介绍三种流行的降维技术：主成分分析（PCA），核主成分分析（Kernel PCA）和局部线性嵌入（LLE）。</p><p>二、维数灾难<br>我们已经习惯生活在一个三维的世界里，以至于当我们尝试想象更高维的空间时，我们的直觉不管用了。即使是一个基本的 4D 超正方体也很难在我们的脑中想象出来（见图 8-1），更不用说一个 200 维的椭球弯曲在一个 1000 维的空间里了。</p><p>图 8-1 点，线，方形，立方体和超正方体（0D 到 4D 超正方体）<br>这表明很多物体在高维空间表现的十分不同。比如，如果你在一个正方形单元中随机取一个点（一个1×1的正方形），那么随机选的点离所有边界大于 0.001（靠近中间位置）的概率为 0.4%（1 - 0.998^2）（换句话说，一个随机产生的点不大可能严格落在某一个维度上。但是在一个 1,0000 维的单位超正方体（一个1×1×…×1的立方体，有 10,000 个 1），这种可能性超过了 99.999999%。在高维超正方体中，大多数点都分布在边界处。</p><p>还有一个更麻烦的区别：如果你在一个平方单位中随机选取两个点，那么这两个点之间的距离平均约为 0.52。如果您在单位 3D 立方体中选取两个随机点，平均距离将大致为 0.66。但是，在一个 1,000,000 维超立方体中随机抽取两点呢？那么，平均距离，信不信由你，大概为 408.25！这非常违反直觉：当它们都位于同一单元超立方体内时，两点是怎么距离这么远的？这一事实意味着高维数据集有很大风险分布的非常稀疏：大多数训练实例可能彼此远离。当然，这也意味着一个新实例可能远离任何训练实例，这使得预测的可靠性远低于我们处理较低维度数据的预测，因为它们将基于更大的推测（extrapolations）。简而言之，训练集的维度越高，过拟合的风险就越大。</p><p>理论上来说，维数爆炸的一个解决方案是增加训练集的大小从而达到拥有足够密度的训练集。不幸的是，在实践中，达到给定密度所需的训练实例的数量随着维度的数量呈指数增长。如果只有 100 个特征（比 MNIST 问题要少得多）并且假设它们均匀分布在所有维度上，那么如果想要各个临近的训练实例之间的距离在 0.1 以内，您需要比宇宙中的原子还要多的训练实例。</p><p>三、降维的主要方法<br>在我们深入研究具体的降维算法之前，我们来看看降低维度的两种主要方法：投影和流形学习。</p><p>3.1 投影（Projection）<br>在大多数现实生活的问题中，训练实例并不是在所有维度上均匀分布的。许多特征几乎是常数，而其他特征则高度相关（如前面讨论的 MNIST）。结果，所有训练实例实际上位于（或接近）高维空间的低维子空间内。这听起来有些抽象，所以我们不妨来看一个例子。在图 8-2 中，您可以看到由圆圈表示的 3D 数据集。</p><p>图 8-2 一个分布接近于2D子空间的3D数据集<br>注意到所有训练实例的分布都贴近一个平面：这是高维（3D）空间的较低维（2D）子空间。现在，如果我们将每个训练实例垂直投影到这个子空间上（就像将短线连接到平面的点所表示的那样），我们就可以得到如图8-3所示的新2D数据集。铛铛铛！我们刚刚将数据集的维度从 3D 降低到了 2D。请注意，坐标轴对应于新的特征z1和z2（平面上投影的坐标）。</p><p>图 8-3 一个经过投影后的新的 2D 数据集<br>但是，投影并不总是降维的最佳方法。在很多情况下，子空间可能会扭曲和转动，比如图 8-4 所示的着名瑞士滚动玩具数据集。</p><p>图 8-4 瑞士滚动数玩具数据集<br>简单地将数据集投射到一个平面上（例如，直接丢弃x3）会将瑞士卷的不同层叠在一起，如图 8-5 左侧所示。但是，你真正想要的是展开瑞士卷所获取到的类似图 8-5 右侧的 2D 数据集。</p><p>图 8-5 投射到平面的压缩（左）vs 展开瑞士卷（右）<br>3.2 流形学习</p><p>瑞士卷一个是二维流形的例子。简而言之，二维流形是一种二维形状，它可以在更高维空间中弯曲或扭曲。更一般地，一个d维流形是类似于d维超平面的n维空间（其中d &lt; n）的一部分。在我们瑞士卷这个例子中，d = 2，n = 3：它有些像 2D 平面，但是它实际上是在第三维中卷曲。</p><p>许多降维算法通过对训练实例所在的流形进行建模从而达到降维目的；这叫做流形学习。它依赖于流形猜想（manifold assumption），也被称为流形假设（manifold hypothesis），它认为大多数现实世界的高维数据集大都靠近一个更低维的流形。这种假设经常在实践中被证实。</p><p>让我们再回到 MNIST 数据集：所有手写数字图像都有一些相似之处。它们由连线组成，边界是白色的，大多是在图片中中间的，等等。如果你随机生成图像，只有一小部分看起来像手写数字。换句话说，如果您尝试创建数字图像，那么您的自由度远低于您生成任何随便一个图像时的自由度。这些约束往往会将数据集压缩到较低维流形中。</p><p>流形假设通常包含着另一个隐含的假设：你现在的手上的工作（例如分类或回归）如果在流形的较低维空间中表示，那么它们会变得更简单。例如，在图 8-6 的第一行中，瑞士卷被分为两类：在三维空间中（图左上），分类边界会相当复杂，但在二维展开的流形空间中（图右上），分类边界是一条简单的直线。</p><p>但是，这个假设并不总是成立。例如，在图 8-6 的最下面一行，决策边界位于x1 = 5（图左下）。这个决策边界在原始三维空间（一个垂直平面）看起来非常简单，但在展开的流形中却变得更复杂了（四个独立线段的集合）（图右下）。</p><p>简而言之，如果在训练模型之前降低训练集的维数，那训练速度肯定会加快，但并不总是会得出更好的训练效果；这一切都取决于数据集。</p><p>希望你现在对于维数爆炸以及降维算法如何解决这个问题有了一定的理解，特别是对流形假设提出的内容。本章的其余部分将介绍一些最流行的降维算法。</p><p>图 8-6 决策边界并不总是会在低维空间中变的简单</p><p><a href="https://zhuanlan.zhihu.com/p/83284762">参考</a><br><a href="https://www.zhihu.com/topic/20134952/hot">参考二</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用python进行数据分析-高级pandas</title>
      <link href="/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E9%AB%98%E7%BA%A7pandas/"/>
      <url>/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E9%AB%98%E7%BA%A7pandas/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用python进行数据分析-时间序列</title>
      <link href="/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
      <url>/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>一、第14章 数据分析案例<br>本书正文的最后一章，我们来看一些真实世界的数据集。对于每个数据集，我们会用之前介绍的方法，从原始数据中提取有意义的内容。展示的方法适用于其它数据集，也包括你的。本章包含了一些各种各样的案例数据集，可以用来练习。</p><p>下载本书代码：<a href="https://github.com/wesm/pydata-book%EF%BC%88%E5%BB%BA%E8%AE%AE%E6%8A%8A%E4%BB%A3%E7%A0%81%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%AE%89%E8%A3%85%E5%A5%BDAnaconda">https://github.com/wesm/pydata-book（建议把代码下载下来之后，安装好Anaconda</a> 3.6，在目录文件夹中用Jupyter notebook打开）</p><p>二、实例<br>2.6 1880-2010年间全美婴儿姓名<br>美国社会保障总署提供了一份从1880年到现在的婴儿名字频率数据。Hadley Wickham（许多流行R包的作者）经常用这份数据来演示R的数据处理功能。</p><p>你可以用这个数据集做很多事，例如：</p><p>· 计算指定名字（可以是你自己的，也可以是别人的）的年度比例。</p><p>· 计算某个名字的相对排名。</p><p>· 计算各年度最流行的名字，以及增长或减少最快的名字。</p><p>· 分析名字趋势：元音、辅音、长度、总体多样性、拼写变化、首尾字母等。</p><p>· 分析外源性趋势：圣经中的名字、名人、人口结构变化等。</p><p>利用前面介绍过的那些工具，这些分析工作都能很轻松地完成，我会讲解其中的一些。</p><p>到编写本书时为止，美国社会保障总署将该数据库按年度制成了多个数据文件，其中给出了每个性别/名字组合的出生总数。</p><p>下载”National data”文件names.zip，解压后的目录中含有一组文件（如yob1880.txt）。其中一个文件的前10行：</p><p>Mary,F,7065</p><p>Anna,F,2604</p><p>Emma,F,2003</p><p>Elizabeth,F,1939</p><p>Minnie,F,1746</p><p>Margaret,F,1578</p><p>Ida,F,1472</p><p>Alice,F,1414</p><p>Bertha,F,1320</p><p>Sarah,F,1288</p><p>由于这是一个非常标准的以逗号隔开的格式，所以可以用pandas.read_csv将其加载到DataFrame中：</p><p>In [95]: import pandas as pd</p><p>In [96]: names1880 =pd.read_csv(‘datasets/babynames/yob1880.txt’,names=[‘name’, ‘sex’, ‘births’])</p><p>In [97]: names1880</p><p>Out[97]:</p><p>name sex births</p><p>0 Mary F 7065</p><p>1 Anna F 2604</p><p>2 Emma F 2003</p><p>… … .. …</p><p>1997 Wright M 5</p><p>1998 York M 5</p><p>1999 Zachariah M 5</p><p>[2000 rows x 3 columns]</p><p>这些文件中仅含有当年出现超过5次的名字。为了简单起见，我们可以用births列的sex分组小计表示该年度的births总计：</p><p>In [98]: names1880.groupby(‘sex’).births.sum()</p><p>Out[98]:</p><p>sex</p><p>F 90993</p><p>M 110493</p><p>Name: births, dtype: int64</p><p>由于该数据集按年度被分隔成了多个文件，所以第一件事情就是要将所有数据都组装到一个DataFrame里面，并加上一个year字段。使用pandas.concat即可达到这个目的：</p><p>years = range(1880, 2011)</p><p>pieces = []</p><p>columns = [‘name’, ‘sex’, ‘births’]</p><p>for year in years:</p><p>path = ‘datasets/babynames/yob%d.txt’ % year</p><p>frame = pd.read_csv(path, names=columns)</p><p>frame[‘year’] = year</p><p>pieces.append(frame)</p><p>names = pd.concat(pieces, ignore_index=True)#合并表格</p><p>这里需要注意几件事情。第一，concat默认是按行将多个DataFrame组合到一起的；第二，必须指定ignore_index=True，因为我们不希望保留read_csv所返回的原始行号。现在我们得到了一个非常大的DataFrame，它含有全部的名字数据：</p><p>In [100]: names</p><p>Out[100]:</p><p>name sex births year</p><p>0 Mary F 7065 1880</p><p>1 Anna F 2604 1880</p><p>2 Emma F 2003 1880</p><p>3 Elizabeth F 1939 1880</p><p>… … .. … …</p><p>1690781 Zyquarius M 5 2010</p><p>1690782 Zyran M 5 2010</p><p>1690783 Zzyzx M 5 2010</p><p>[1690784 rows x 4 columns]</p><p>有了这些数据之后，我们就可以利用groupby或pivot_table在year和sex级别上对其进行聚合了，如图14-4所示：</p><p>In [101]: total_births = names.pivot_table(‘births’, index=’year’,</p><p>…..: columns=’sex’, aggfunc=sum)</p><p>In [102]: total_births.tail()</p><p>Out[102]:</p><p>sex F M</p><p>year</p><p>2006 1896468 2050234</p><p>2007 1916888 2069242</p><p>2008 1883645 2032310</p><p>2009 1827643 1973359</p><p>2010 1759010 1898382</p><p>In [103]: %matplotlib</p><p>total_births.plot(title=’Total births by sex and year’)</p><p>图14-4 按性别和年度统计的总出生数<br>下面我们来插入一个prop列，用于存放指定名字的婴儿数相对于总出生数的比例。prop值为0.02表示每100名婴儿中有2名取了当前这个名字。因此，我们先按year和sex分组，然后再将新列加到各个分组上：</p><p>def add_prop(group):</p><p>group[‘prop’] = group.births / group.births.sum()</p><p>return group</p><p>names = names.groupby([‘year’, ‘sex’]).apply(add_prop)</p><p>现在，完整的数据集就有了下面这些列：</p><p>In [105]: names</p><p>Out[105]:</p><p>name sex births year prop</p><p>0 Mary F 7065 1880 0.077643</p><p>1 Anna F 2604 1880 0.028618</p><p>2 Emma F 2003 1880 0.022013</p><p>… … .. … … …</p><p>1690781 Zyquarius M 5 2010 0.000003</p><p>1690782 Zyran M 5 2010 0.000003</p><p>1690783 Zzyzx M 5 2010 0.000003</p><p>[1690784 rows x 5 columns]</p><p>在执行这样的分组处理时，一般都应该做一些有效性检查，比如验证所有分组的prop的总和是否为1：</p><p>In [106]: names.groupby([‘year’, ‘sex’]).prop.sum()</p><p>Out[106]:</p><p>year sex</p><p>1880 F 1.0</p><p>M 1.0</p><p>1881 F 1.0</p><p>M 1.0</p><p>1882 F 1.0</p><p>M 1.0</p><p>…</p><p>2008 F 1.0</p><p>M 1.0</p><p>2009 F 1.0</p><p>M 1.0</p><p>2010 F 1.0</p><p>M 1.0</p><p>Name: prop, Length: 262, dtype: float64</p><p>工作完成。为了便于实现更进一步的分析，我需要取出该数据的一个子集：每对sex/year组合的前1000个名字。这又是一个分组操作：</p><p>def get_top1000(group):</p><p>return group.sort_values(by=’births’, ascending=False)[:1000]</p><p>grouped = names.groupby([‘year’, ‘sex’])</p><p>top1000 = grouped.apply(get_top1000)</p><p>top1000.reset_index(inplace=True, drop=True)</p><p>如果你喜欢DIY的话，也可以这样：</p><p>pieces = []</p><p>for year, group in names.groupby([‘year’, ‘sex’]):</p><p>pieces.append(group.sort_values(by=’births’, ascending=False)[:1000])</p><p>top1000 = pd.concat(pieces, ignore_index=True)</p><p>现在的结果数据集就小多了：</p><p>In [108]: top1000</p><p>Out[108]:</p><p>name sex births year prop</p><p>0 Mary F 7065 1880 0.077643</p><p>1 Anna F 2604 1880 0.028618</p><p>2 Emma F 2003 1880 0.022013</p><p>3 Elizabeth F 1939 1880 0.021309</p><p>… … .. … … …</p><p>261874 Jaquan M 194 2010 0.000102</p><p>261875 Jaydan M 194 2010 0.000102</p><p>261876 Maxton M 193 2010 0.000102</p><p>[261877 rows x 5 columns]</p><p>接下来的数据分析工作就针对这个top1000数据集了。</p><p>2.7分析命名趋势<br>有了完整的数据集和刚才生成的top1000数据集，我们就可以开始分析各种命名趋势了。首先将前1000个名字分为男女两个部分：</p><p>In [109]: boys = top1000[top1000.sex == ‘M’]</p><p>In [110]: girls = top1000[top1000.sex == ‘F’]</p><p>这是两个简单的时间序列，只需稍作整理即可绘制出相应的图表（比如每年叫做John和Mary的婴儿数）。我们先生成一张按year和name统计的总出生数透视表：</p><p>In [111]: total_births = top1000.pivot_table(‘births’, index=’year’,</p><p>…..: columns=’name’,aggfunc=sum)</p><p>现在，我们用DataFrame的plot方法绘制几个名字的曲线图（见图14-5）：</p><p>In [112]: <a href="http://total_births.info()/">http://total_births.info()</a></p><p>&lt;class ‘pandas.core.frame.DataFrame’&gt;</p><p>Int64Index: 131 entries, 1880 to 2010</p><p>Columns: 6868 entries, Aaden to Zuri</p><p>dtypes: float64(6868)</p><p>memory usage: 6.9 MB</p><p>In [113]: subset = total_births[[‘John’, ‘Harry’, ‘Mary’, ‘Marilyn’]]</p><p>In [114]: subset.plot(subplots=True, figsize=(12, 10), grid=False,</p><p>…..: title=”Number of births per year”)</p><p>图14-5 几个男孩和女孩名字随时间变化的使用数量<br>从图中可以看出，这几个名字在美国人民的心目中已经风光不再了。但事实并非如此简单，我们在下一节中就能知道是怎么一回事了。</p><p>2.8评估命名多样性的增长<br>一种解释是父母愿意给小孩起常见的名字越来越少。这个假设可以从数据中得到验证。一个办法是计算最流行的1000个名字所占的比例，我按year和sex进行聚合并绘图（见图14-6）：</p><p>In [116]: table = top1000.pivot_table(‘prop’, index=’year’,</p><p>…..: columns=’sex’, aggfunc=sum)</p><p>In [117]: table.plot(title=’Sum of table1000.prop by year and sex’,</p><p>…..: yticks=np.linspace(0, 1.2, 13), xticks=range(1880, 2020, 10))</p><p>图14-6 分性别统计的前1000个名字在总出生人数中的比例<br>从图中可以看出，名字的多样性确实出现了增长（前1000项的比例降低）。另一个办法是计算占总出生人数前50%的不同名字的数量，这个数字不太好计算。我们只考虑2010年男孩的名字：</p><p>In [118]: df = boys[boys.year == 2010]</p><p>In [119]: df</p><p>Out[119]:</p><p>name sex births year prop</p><p>260877 Jacob M 21875 2010 0.011523</p><p>260878 Ethan M 17866 2010 0.009411</p><p>260879 Michael M 17133 2010 0.009025</p><p>… … .. … … …</p><p>261874 Jaquan M 194 2010 0.000102</p><p>261875 Jaydan M 194 2010 0.000102</p><p>261876 Maxton M 193 2010 0.000102</p><p>[1000 rows x 5 columns]</p><p>在对prop降序排列之后，我们想知道前面多少个名字的人数加起来才够50%。虽然编写一个for循环确实也能达到目的，但NumPy有一种更聪明的矢量方式。先计算prop的累计和cumsum，然后再通过searchsorted方法找出0.5应该被插入在哪个位置才能保证不破坏顺序：</p><p>In [120]: prop_cumsum = df.sort_values(by=’prop’, ascending=False).prop.cumsum()</p><p>In [121]: prop_cumsum[:10]</p><p>Out[121]:<br>260877 0.011523</p><p>260878 0.020934</p><p>260879 0.029959</p><p>260880 0.038930</p><p>260881 0.047817</p><p>260882 0.056579</p><p>260883 0.065155</p><p>260884 0.073414</p><p>260885 0.081528</p><p>260886 0.089621</p><p>Name: prop, dtype: float64</p><p>In [122]: prop_cumsum.values.searchsorted(0.5)</p><p>Out[122]: 116</p><p>由于数组索引是从0开始的，因此我们要给这个结果加1，即最终结果为117。拿1900年的数据来做个比较，这个数字要小得多：</p><p>In [123]: df = boys[boys.year == 1900]</p><p>In [124]: in1900 = df.sort_values(by=’prop’, ascending=False).prop.cumsum()</p><p>In [125]: in1900.values.searchsorted(0.5) + 1</p><p>Out[125]: 25</p><p>现在就可以对所有year/sex组合执行这个计算了。按这两个字段进行groupby处理，然后用一个函数计算各分组的这个值：</p><p>def get_quantile_count(group, q=0.5):</p><p>group = group.sort_values(by=’prop’, ascending=False)</p><p>return group.prop.cumsum().values.searchsorted(q) + 1</p><p>diversity = top1000.groupby([‘year’, ‘sex’]).apply(get_quantile_count)</p><p>diversity = diversity.unstack(‘sex’)</p><p>现在，diversity这个DataFrame拥有两个时间序列（每个性别各一个，按年度索引）。通过IPython，你可以查看其内容，还可以像之前那样绘制图表（如图14-7所示）：</p><p>In [128]: diversity.head()</p><p>Out[128]:</p><p>sex F M</p><p>year</p><p>1880 38 14</p><p>1881 38 14</p><p>1882 38 15</p><p>1883 39 15</p><p>1884 39 16</p><p>In [129]: diversity.plot(title=”Number of popular names in top 50%”)</p><p>图14-7 按年度统计的密度表<br>从图中可以看出，女孩名字的多样性总是比男孩的高，而且还在变得越来越高。</p><p>2.9 “最后一个字母”的变革<br>2007年，一名婴儿姓名研究人员Laura Wattenberg在她自己的网站上指出（<a href="http://www.babynamewizard.com）：近百年来，男孩名字在最后一个字母上的分布发生了显著的变化。为了了解具体的情况，我首先将全部出生数据在年度、性别以及末字母上进行了聚合：">http://www.babynamewizard.com）：近百年来，男孩名字在最后一个字母上的分布发生了显著的变化。为了了解具体的情况，我首先将全部出生数据在年度、性别以及末字母上进行了聚合：</a></p><p>get_last_letter = lambda x: x[-1]# 提取尾字符</p><p>last_letters = names.name.map(get_last_letter)</p><p>last_letters.name = ‘last_letter’</p><p>table = names.pivot_table(‘births’, index=last_letters,</p><p>columns=[‘sex’, ‘year’], aggfunc=sum)</p><p>然后选出具有一定代表性的三年，并输出前面几行：</p><p>In [131]: subtable = table.reindex(columns=[1910, 1960, 2010], level=’year’)</p><p>In [132]: subtable.head()</p><p>Out[132]:</p><p>sex F M</p><p>year 1910 1960 2010 1910 1960 2010</p><p>last_letter</p><p>a 108376.0 691247.0 670605.0 977.0 5204.0 28438.0</p><p>b NaN 694.0 450.0 411.0 3912.0 38859.0</p><p>c 5.0 49.0 946.0 482.0 15476.0 23125.0</p><p>d 6750.0 3729.0 2607.0 22111.0 262112.0 44398.0</p><p>e 133569.0 435013.0 313833.0 28655.0 178823.0 129012.0</p><p>接下来我们需要按总出生数对该表进行规范化处理，以便计算出各性别各末字母占总出生人数的比例：</p><p>In [133]: subtable.sum()</p><p>Out[133]:</p><p>sex year</p><p>F 1910 396416.0</p><p>1960 2022062.0</p><p>2010 1759010.0</p><p>M 1910 194198.0</p><p>1960 2132588.0</p><p>2010 1898382.0</p><p>dtype: float64</p><p>In [134]: letter_prop = subtable / subtable.sum()</p><p>In [135]: letter_prop</p><p>Out[135]:</p><p>sex F M</p><p>year 1910 1960 2010 1910 1960 2010</p><p>last_letter</p><p>a 0.273390 0.341853 0.381240 0.005031 0.002440 0.014980</p><p>b NaN 0.000343 0.000256 0.002116 0.001834 0.020470</p><p>c 0.000013 0.000024 0.000538 0.002482 0.007257 0.012181</p><p>d 0.017028 0.001844 0.001482 0.113858 0.122908 0.023387</p><p>e 0.336941 0.215133 0.178415 0.147556 0.083853 0.067959</p><p>f NaN 0.000010 0.000055 0.000783 0.004325 0.001188</p><p>g 0.000144 0.000157 0.000374 0.002250 0.009488 0.001404</p><p>h 0.051529 0.036224 0.075852 0.045562 0.037907 0.051670</p><p>i 0.001526 0.039965 0.031734 0.000844 0.000603 0.022628</p><p>j NaN NaN 0.000090 NaN NaN 0.000769</p><p>k 0.000121 0.000156 0.000356 0.036581 0.049384 0.018541</p><p>l 0.043189 0.033867 0.026356 0.065016 0.104904 0.070367</p><p>m 0.001201 0.008613 0.002588 0.058044 0.033827 0.024657</p><p>n 0.079240 0.130687 0.140210 0.143415 0.152522 0.362771</p><p>o 0.001660 0.002439 0.001243 0.017065 0.012829 0.042681</p><p>p 0.000018 0.000023 0.000020 0.003172 0.005675 0.001269</p><p>q NaN NaN 0.000030 NaN NaN 0.000180</p><p>r 0.013390 0.006764 0.018025 0.064481 0.031034 0.087477</p><p>s 0.039042 0.012764 0.013332 0.130815 0.102730 0.065145</p><p>t 0.027438 0.015201 0.007830 0.072879 0.065655 0.022861</p><p>u 0.000684 0.000574 0.000417 0.000124 0.000057 0.001221</p><p>v NaN 0.000060 0.000117 0.000113 0.000037 0.001434</p><p>w 0.000020 0.000031 0.001182 0.006329 0.007711 0.016148</p><p>x 0.000015 0.000037 0.000727 0.003965 0.001851 0.008614</p><p>y 0.110972 0.152569 0.116828 0.077349 0.160987 0.058168</p><p>z 0.002439 0.000659 0.000704 0.000170 0.000184 0.001831</p><p>有了这个字母比例数据之后，就可以生成一张各年度各性别的条形图了，如图14-8所示：</p><p>import matplotlib.pyplot as plt</p><p>fig, axes = plt.subplots(2, 1, figsize=(10, 8))</p><p>letter_prop[‘M’].plot(kind=’bar’, rot=0, ax=axes[0], title=’Male’)</p><p>letter_prop[‘F’].plot(kind=’bar’, rot=0, ax=axes[1], title=’Female’,</p><p>legend=False)</p><p>图14-8 男孩女孩名字中各个末字母的比例<br>可以看出，从20世纪60年代开始，以字母”n”结尾的男孩名字出现了显著的增长。回到之前创建的那个完整表，按年度和性别对其进行规范化处理，并在男孩名字中选取几个字母，最后进行转置以便将各个列做成一个时间序列：</p><p>In [138]: letter_prop = table / table.sum()</p><p>In [139]: dny_ts = letter_prop.loc[[‘d’, ‘n’, ‘y’], ‘M’].T</p><p>In [140]: dny_ts.head()</p><p>Out[140]:</p><p>last_letter d n y</p><p>year</p><p>1880 0.083055 0.153213 0.075760</p><p>1881 0.083247 0.153214 0.077451</p><p>1882 0.085340 0.149560 0.077537</p><p>1883 0.084066 0.151646 0.079144</p><p>1884 0.086120 0.149915 0.080405</p><p>有了这个时间序列的DataFrame之后，就可以通过其plot方法绘制出一张趋势图了（如图14-9所示）：</p><p>In [143]: dny_ts.plot()</p><p>2.10变成女孩名字的男孩名字（以及相反的情况）<br>另一个有趣的趋势是，早年流行于男孩的名字近年来“变性了”，例如Lesley或Leslie。回到top1000数据集，找出其中以”lesl”开头的一组名字：</p><p>In [144]: all_names = pd.Series(top1000.name.unique())</p><p>In [145]: lesley_like = all_names[all_names.str.lower().str.contains(‘lesl’)]</p><p>In [146]: lesley_like</p><p>Out[146]:</p><p>632 Leslie</p><p>2294 Lesley</p><p>4262 Leslee</p><p>4728 Lesli</p><p>6103 Lesly</p><p>dtype: object</p><p>然后利用这个结果过滤其他的名字，并按名字分组计算出生数以查看相对频率：</p><p>In [147]: filtered = top1000[top1000.name.isin(lesley_like)]</p><p>In [148]: filtered.groupby(‘name’).births.sum()</p><p>Out[148]:</p><p>name</p><p>Leslee 1082</p><p>Lesley 35022</p><p>Lesli 929</p><p>Leslie 370429</p><p>Lesly 10067</p><p>Name: births, dtype: int64</p><p>接下来，我们按性别和年度进行聚合，并按年度进行规范化处理：</p><p>In [149]: table = filtered.pivot_table(‘births’, index=’year’,</p><p>…..: columns=’sex’, aggfunc=’sum’)</p><p>In [150]: table = table.div(table.sum(1), axis=0)</p><p>In [151]: table.tail()</p><p>Out[151]:</p><p>sex F M</p><p>year</p><p>2006 1.0 NaN</p><p>2007 1.0 NaN</p><p>2008 1.0 NaN</p><p>2009 1.0 NaN</p><p>2010 1.0 NaN</p><p>最后，就可以轻松绘制一张分性别的年度曲线图了（如图2-10所示）：</p><p>In [153]: table.plot(style={‘M’: ‘k-‘, ‘F’: ‘k–’})</p><p>图14-10 各年度使用“Lesley型”名字的男女比例<br>三、小结</p><p>names1880 =pd.read_csv(‘datasets/babynames/yob1880.txt’,names=[‘name’, ‘sex’, ‘births’])</p><p>names1880.groupby(‘sex’).births.sum()</p><p>for year in years:</p><p>path = ‘datasets/babynames/yob%d.txt’ % year</p><p>frame = pd.read_csv(path, names=columns)</p><p>frame[‘year’] = year</p><p>pieces.append(frame)</p><p>names = pd.concat(pieces, ignore_index=True)#合并表格</p><p>total_births = names.pivot_table(‘births’, index=’year’,</p><p>…..: columns=’sex’, aggfunc=sum)</p><p>def add_prop(group):</p><p>group[‘prop’] = group.births / group.births.sum()</p><p>return group</p><p>names = names.groupby([‘year’, ‘sex’]).apply(add_prop)</p><p>names.groupby([‘year’, ‘sex’]).prop.sum()</p><p>def get_top1000(group):</p><p>return group.sort_values(by=’births’, ascending=False)[:1000]</p><p>grouped = names.groupby([‘year’, ‘sex’])</p><p>top1000 = grouped.apply(get_top1000)</p><p>top1000.reset_index(inplace=True, drop=True)</p><p>for year, group in names.groupby([‘year’, ‘sex’]):</p><p>pieces.append(group.sort_values(by=’births’, ascending=False)[:1000])</p><p>top1000 = pd.concat(pieces, ignore_index=True)</p><p>total_births = top1000.pivot_table(‘births’, index=’year’,</p><p>…..: columns=’name’,aggfunc=sum)</p><p>subset.plot(subplots=True, figsize=(12, 10), grid=False,</p><p>…..: title=”Number of births per year”)</p><p>table = top1000.pivot_table(‘prop’, index=’year’,</p><p>…..: columns=’sex’, aggfunc=sum)</p><p>table.plot(title=’Sum of table1000.prop by year and sex’,</p><p>…..: yticks=np.linspace(0, 1.2, 13), xticks=range(1880, 2020, 10))</p><p>prop_cumsum = df.sort_values(by=’prop’, ascending=False).prop.cumsum()</p><p>prop_cumsum.values.searchsorted(0.5)</p><p>in1900 = df.sort_values(by=’prop’, ascending=False).prop.cumsum()</p><p>in1900.values.searchsorted(0.5) + 1</p><p>def get_quantile_count(group, q=0.5):</p><p>group = group.sort_values(by=’prop’, ascending=False)</p><p>return group.prop.cumsum().values.searchsorted(q) + 1</p><p>diversity = top1000.groupby([‘year’, ‘sex’]).apply(get_quantile_count)</p><p>diversity = diversity.unstack(‘sex’)</p><p>table = names.pivot_table(‘births’, index=last_letters,</p><p>columns=[‘sex’, ‘year’], aggfunc=sum)</p><p>subtable = table.reindex(columns=[1910, 1960, 2010], level=’year’)</p><p>letter_prop = subtable / subtable.sum()</p><p>fig, axes = plt.subplots(2, 1, figsize=(10, 8))</p><p>letter_prop[‘M’].plot(kind=’bar’, rot=0, ax=axes[0], title=’Male’)</p><p>dny_ts = letter_prop.loc[[‘d’, ‘n’, ‘y’], ‘M’].T</p><p>all_names = pd.Series(top1000.name.unique())</p><p>lesley_like = all_names[all_names.str.lower().str.contains(‘lesl’)]</p><p>filtered = top1000[top1000.name.isin(lesley_like)]</p><p>filtered.groupby(‘name’).births.sum()</p><p>table = filtered.pivot_table(‘births’, index=’year’,</p><p>…..: columns=’sex’, aggfunc=’sum’)</p><p>table = table.div(table.sum(1), axis=0)</p><p>table.plot(style={‘M’: ‘k-‘, ‘F’: ‘k–’})</p><p>·后记<br>这一节涉及的统计学知识还是比较多的，对大数量的数据找特定维度展开分析给出了很多有用的实际案例。(下班撸一遍代码累成小番薯)</p><p><a href="https://zhuanlan.zhihu.com/p/68766758">参考</a><br><a href="https://zhuanlan.zhihu.com/p/38093168">参考二</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用python进行数据分析-数据清洗</title>
      <link href="/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"/>
      <url>/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用python进行数据分析-pandas</title>
      <link href="/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-pandas/"/>
      <url>/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-pandas/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>一、第14章 数据分析案例<br>本书正文的最后一章，我们来看一些真实世界的数据集。对于每个数据集，我们会用之前介绍的方法，从原始数据中提取有意义的内容。展示的方法适用于其它数据集，也包括你的。本章包含了一些各种各样的案例数据集，可以用来练习。</p><p>下载本书代码：<a href="https://github.com/wesm/pydata-book%EF%BC%88%E5%BB%BA%E8%AE%AE%E6%8A%8A%E4%BB%A3%E7%A0%81%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%AE%89%E8%A3%85%E5%A5%BDAnaconda">https://github.com/wesm/pydata-book（建议把代码下载下来之后，安装好Anaconda</a> 3.6，在目录文件夹中用Jupyter notebook打开）</p><p>二、实例<br>2.4 MovieLens 1M数据集<br>GroupLens Research（<a href="http://www.grouplens.org/node/73%EF%BC%89%E9%87%87%E9%9B%86%E4%BA%86%E4%B8%80%E7%BB%84%E4%BB%8E20%E4%B8%96%E7%BA%AA90%E5%B9%B4%E6%9C%AB%E5%88%B021%E4%B8%96%E7%BA%AA%E5%88%9D%E7%94%B1MovieLens%E7%94%A8%E6%88%B7%E6%8F%90%E4%BE%9B%E7%9A%84%E7%94%B5%E5%BD%B1%E8%AF%84%E5%88%86%E6%95%B0%E6%8D%AE%E3%80%82%E8%BF%99%E4%BA%9B%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8C%85%E6%8B%AC%E7%94%B5%E5%BD%B1%E8%AF%84%E5%88%86%E3%80%81%E7%94%B5%E5%BD%B1%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%88%E9%A3%8E%E6%A0%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B9%B4%E4%BB%A3%EF%BC%89%E4%BB%A5%E5%8F%8A%E5%85%B3%E4%BA%8E%E7%94%A8%E6%88%B7%E7%9A%84%E4%BA%BA%E5%8F%A3%E7%BB%9F%E8%AE%A1%E5%AD%A6%E6%95%B0%E6%8D%AE%EF%BC%88%E5%B9%B4%E9%BE%84%E3%80%81%E9%82%AE%E7%BC%96%E3%80%81%E6%80%A7%E5%88%AB%E5%92%8C%E8%81%8C%E4%B8%9A%E7%AD%89%EF%BC%89%E3%80%82%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B8%80%E8%88%AC%E9%83%BD%E4%BC%9A%E5%AF%B9%E6%AD%A4%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%84%9F%E5%85%B4%E8%B6%A3%E3%80%82%E8%99%BD%E7%84%B6%E6%88%91%E4%B8%8D%E4%BC%9A%E5%9C%A8%E6%9C%AC%E4%B9%A6%E4%B8%AD%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%BD%86%E6%88%91%E4%BC%9A%E5%91%8A%E8%AF%89%E4%BD%A0%E5%A6%82%E4%BD%95%E5%AF%B9%E8%BF%99%E7%A7%8D%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%88%87%E7%89%87%E5%88%87%E5%9D%97%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%AE%9E%E9%99%85%E9%9C%80%E6%B1%82%E3%80%82">http://www.grouplens.org/node/73）采集了一组从20世纪90年末到21世纪初由MovieLens用户提供的电影评分数据。这些数据中包括电影评分、电影元数据（风格类型和年代）以及关于用户的人口统计学数据（年龄、邮编、性别和职业等）。基于机器学习算法的推荐系统一般都会对此类数据感兴趣。虽然我不会在本书中详细介绍机器学习技术，但我会告诉你如何对这种数据进行切片切块以满足实际需求。</a></p><p>MovieLens 1M数据集含有来自6000名用户对4000部电影的100万条评分数据。它分为三个表：评分、用户信息和电影信息。将该数据从zip文件中解压出来之后，可以通过pandas.read_table将各个表分别读到一个pandas DataFrame对象中：</p><p>import pandas as pd</p><p>pd.options.display.max_rows = 10 #限制显示数量</p><p>unames = [‘user_id’, ‘gender’, ‘age’, ‘occupation’, ‘zip’]</p><p>users = pd.read_table(‘datasets/movielens/users.dat’, sep=’::’,</p><p>header=None, names=unames)</p><p>rnames = [‘user_id’, ‘movie_id’, ‘rating’, ‘timestamp’]</p><p>ratings = pd.read_table(‘datasets/movielens/ratings.dat’, sep=’::’,</p><p>header=None, names=rnames)</p><p>mnames = [‘movie_id’, ‘title’, ‘genres’]</p><p>movies = pd.read_table(‘datasets/movielens/movies.dat’, sep=’::’,</p><p>header=None, names=mnames)</p><p>利用Python的切片语法，通过查看每个DataFrame的前几行即可验证数据加载工作是否一切顺利：</p><p>In [69]: users[:5]</p><p>Out[69]:</p><p>user_id gender age occupation zip</p><p>0 1 F 1 10 48067</p><p>1 2 M 56 16 70072</p><p>2 3 M 25 15 55117</p><p>3 4 M 45 7 02460</p><p>4 5 M 25 20 55455</p><p>In [70]: ratings[:5]</p><p>Out[70]:</p><p>user_id movie_id rating timestamp</p><p>0 1 1193 5 978300760</p><p>1 1 661 3 978302109</p><p>2 1 914 3 978301968</p><p>3 1 3408 4 978300275</p><p>4 1 2355 5 978824291</p><p>In [71]: movies[:5]</p><p>Out[71]:</p><p>movie_id title genres</p><p>0 1 Toy Story (1995) Animation|Children’s|Comedy</p><p>1 2 Jumanji (1995) Adventure|Children’s|Fantasy</p><p>2 3 Grumpier Old Men (1995) Comedy|Romance</p><p>3 4 Waiting to Exhale (1995) Comedy|Drama</p><p>4 5 Father of the Bride Part II (1995) Comedy</p><p>In [72]: ratings</p><p>Out[72]:</p><p>user_id movie_id rating timestamp</p><p>0 1 1193 5 978300760</p><p>1 1 661 3 978302109</p><p>2 1 914 3 978301968</p><p>3 1 3408 4 978300275</p><p>4 1 2355 5 978824291</p><p>… … … … …</p><p>1000204 6040 1091 1 956716541</p><p>1000205 6040 1094 5 956704887</p><p>1000206 6040 562 5 956704746</p><p>1000207 6040 1096 4 956715648</p><p>1000208 6040 1097 4 956715569</p><p>注意，其中的年龄和职业是以编码形式给出的，它们的具体含义请参考该数据集的README文件。分析散布在三个表中的数据可不是一件轻松的事情。假设我们想要根据性别和年龄计算某部电影的平均得分，如果将所有数据都合并到一个表中的话问题就简单多了。我们先用pandas的merge函数将ratings跟users合并到一起，然后再将movies也合并进去。pandas会根据列名的重叠情况推断出哪些列是合并（或连接）键：</p><p>In [73]: data = pd.merge(pd.merge(ratings, users), movies)</p><p>In [74]: data</p><p>Out[74]:</p><p>user_id … genres</p><p>0 1 … Drama</p><p>1 2 … Drama</p><p>2 12 … Drama</p><p>3 15 … Drama</p><p>4 17 … Drama</p><p>… … … …</p><p>1000204 5949 … Documentary</p><p>1000205 5675 … Drama</p><p>1000206 5780 … Drama</p><p>1000207 5851 … Comedy|Drama|Western</p><p>1000208 5938 … Documentary</p><p>[1000209 rows x 10 columns]</p><p>In [75]: data.iloc[0]</p><p>Out[75]:</p><p>user_id 1</p><p>movie_id 1193</p><p>rating 5</p><p>timestamp 978300760</p><p>gender F</p><p>age 1</p><p>occupation 10</p><p>zip 48067</p><p>title One Flew Over the Cuckoo’s Nest (1975)</p><p>genres Drama</p><p>Name: 0, dtype: object</p><p>为了按性别计算每部电影的平均得分，我们可以使用pivot_table方法：</p><p>In [76]: mean_ratings = data.pivot_table(‘rating’, index=’title’,</p><p>….: columns=’gender’, aggfunc=’mean’)</p><p>In [77]: mean_ratings[:5]</p><p>Out[77]:</p><p>gender F M</p><p>title</p><p>$1,000,000 Duck (1971) 3.375000 2.761905</p><p>‘Night Mother (1986) 3.388889 3.352941</p><p>‘Til There Was You (1997) 2.675676 2.733333</p><p>‘burbs, The (1989) 2.793478 2.962085</p><p>…And Justice for All (1979) 3.828571 3.689024</p><p>该操作产生了另一个DataFrame，其内容为电影平均得分，行标为电影名称，列标为性别。现在，我打算过滤掉评分数据不够250条的电影。为了达到这个目的，我先对title进行分组，然后利用size()得到一个含有各电影分组大小的Series对象：</p><p>In [78]: ratings_by_title = data.groupby(‘title’).size()</p><p>In [79]: ratings_by_title[:10]</p><p>Out[79]:</p><p>title</p><p>$1,000,000 Duck (1971) 37</p><p>‘Night Mother (1986) 70</p><p>‘Til There Was You (1997) 52</p><p>‘burbs, The (1989) 303</p><p>…And Justice for All (1979) 199</p><p>1-900 (1994) 2</p><p>10 Things I Hate About You (1999) 700</p><p>101 Dalmatians (1961) 565</p><p>101 Dalmatians (1996) 364</p><p>12 Angry Men (1957) 616</p><p>dtype: int64</p><p>In [80]: active_titles = ratings_by_title.index[ratings_by_title &gt;= 250]</p><p>In [81]: active_titles</p><p>Out[81]:</p><p>Index([‘’burbs, The (1989)’, ‘10 Things I Hate About You (1999)’,</p><p>‘101 Dalmatians (1961)’, ‘101 Dalmatians (1996)’, ‘12 Angry Men (1957)’,</p><p>‘13th Warrior, The (1999)’, ‘2 Days in the Valley (1996)’,</p><p>‘20,000 Leagues Under the Sea (1954)’, ‘2001: A Space Odyssey (1968)’,</p><p>‘2010 (1984)’,</p><p>…</p><p>‘X-Men (2000)’, ‘Year of Living Dangerously (1982)’,</p><p>‘Yellow Submarine (1968)’, ‘You’ve Got Mail (1998)’,</p><p>‘Young Frankenstein (1974)’, ‘Young Guns (1988)’,</p><p>‘Young Guns II (1990)’, ‘Young Sherlock Holmes (1985)’,</p><p>‘Zero Effect (1998)’, ‘eXistenZ (1999)’],</p><p>dtype=’object’, name=’title’, length=1216)</p><p>标题索引中含有评分数据大于250条的电影名称，然后我们就可以据此从前面的mean_ratings中选取所需的行了：</p><p>In [82]: mean_ratings = mean_ratings.loc[active_titles]</p><p>In [83]: mean_ratings</p><p>Out[83]:</p><p>gender F M</p><p>title</p><p>‘burbs, The (1989) 2.793478 2.962085</p><p>10 Things I Hate About You (1999) 3.646552 3.311966</p><p>101 Dalmatians (1961) 3.791444 3.500000</p><p>101 Dalmatians (1996) 3.240000 2.911215</p><p>12 Angry Men (1957) 4.184397 4.328421</p><p>… … …</p><p>Young Guns (1988) 3.371795 3.425620</p><p>Young Guns II (1990) 2.934783 2.904025</p><p>Young Sherlock Holmes (1985) 3.514706 3.363344</p><p>Zero Effect (1998) 3.864407 3.723140</p><p>eXistenZ (1999) 3.098592 3.289086</p><p>[1216 rows x 2 columns]</p><p>为了了解女性观众最喜欢的电影，我们可以对F列降序排列：</p><p>In [85]: top_female_ratings = mean_ratings.sort_values(by=’F’, ascending=False)</p><p>In [86]: top_female_ratings[:10]</p><p>Out[86]:</p><p>gender F M<br>title<br>Close Shave, A (1995) 4.644444 4.473795<br>Wrong Trousers, The (1993) 4.588235 4.478261<br>Sunset Blvd. (a.k.a. Sunset Boulevard) (1950) 4.572650 4.464589<br>Wallace &amp; Gromit: The Best of Aardman Animation… 4.563107 4.385075<br>Schindler’s List (1993) 4.562602 4.491415<br>Shawshank Redemption, The (1994) 4.539075 4.560625<br>Grand Day Out, A (1992) 4.537879 4.293255<br>To Kill a Mockingbird (1962) 4.536667 4.372611<br>Creature Comforts (1990) 4.513889 4.272277<br>Usual Suspects, The (1995) 4.513317 4.518248<br>2.5计算评分分歧<br>假设我们想要找出男性和女性观众分歧最大的电影。一个办法是给mean_ratings加上一个用于存放平均得分之差的列，并对其进行排序：</p><p>In [87]: mean_ratings[‘diff’] = mean_ratings[‘M’] - mean_ratings[‘F’]</p><p>按”diff”排序即可得到分歧最大且女性观众更喜欢的电影：</p><p>In [88]: sorted_by_diff = mean_ratings.sort_values(by=’diff’)</p><p>In [89]: sorted_by_diff[:10]</p><p>Out[89]:</p><p>gender F M diff</p><p>title</p><p>Dirty Dancing (1987) 3.790378 2.959596 -0.830782</p><p>Jumpin’ Jack Flash (1986) 3.254717 2.578358 -0.676359</p><p>Grease (1978) 3.975265 3.367041 -0.608224</p><p>Little Women (1994) 3.870588 3.321739 -0.548849</p><p>Steel Magnolias (1989) 3.901734 3.365957 -0.535777</p><p>Anastasia (1997) 3.800000 3.281609 -0.518391</p><p>Rocky Horror Picture Show, The (1975) 3.673016 3.160131 -0.512885</p><p>Color Purple, The (1985) 4.158192 3.659341 -0.498851</p><p>Age of Innocence, The (1993) 3.827068 3.339506 -0.487561</p><p>Free Willy (1993) 2.921348 2.438776 -0.482573</p><p>对排序结果反序并取出前10行，得到的则是男性观众更喜欢的电影：</p><p>In [90]: sorted_by_diff[::-1][:10] #倒序</p><p>Out[90]:</p><p>gender F M diff</p><p>title</p><p>Good, The Bad and The Ugly, The (1966) 3.494949 4.221300 0.726351</p><p>Kentucky Fried Movie, The (1977) 2.878788 3.555147 0.676359</p><p>Dumb &amp; Dumber (1994) 2.697987 3.336595 0.638608</p><p>Longest Day, The (1962) 3.411765 4.031447 0.619682</p><p>Cable Guy, The (1996) 2.250000 2.863787 0.613787</p><p>Evil Dead II (Dead By Dawn) (1987) 3.297297 3.909283 0.611985</p><p>Hidden, The (1987) 3.137931 3.745098 0.607167</p><p>Rocky III (1982) 2.361702 2.943503 0.581801</p><p>Caddyshack (1980) 3.396135 3.969737 0.573602</p><p>For a Few Dollars More (1965) 3.409091 3.953795 0.544704</p><p>如果只是想要找出分歧最大的电影（不考虑性别因素），则可以计算得分数据的方差或标准差：</p><p>In [91]: rating_std_by_title = data.groupby(‘title’)[‘rating’].std()#标准差</p><p>In [92]: rating_std_by_title = rating_std_by_title.loc[active_titles]#选择列</p><p>In [93]: rating_std_by_title.sort_values(ascending=False)[:10]#排序</p><p>Out[93]:</p><p>title</p><p>Dumb &amp; Dumber (1994) 1.321333</p><p>Blair Witch Project, The (1999) 1.316368</p><p>Natural Born Killers (1994) 1.307198</p><p>Tank Girl (1995) 1.277695</p><p>Rocky Horror Picture Show, The (1975) 1.260177</p><p>Eyes Wide Shut (1999) 1.259624</p><p>Evita (1996) 1.253631</p><p>Billy Madison (1995) 1.249970</p><p>Fear and Loathing in Las Vegas (1998) 1.246408</p><p>Bicentennial Man (1999) 1.245533</p><p>Name: rating, dtype: float64</p><p>可能你已经注意到了，电影分类是以竖线（|）分隔的字符串形式给出的。如果想对电影分类进行分析的话，就需要先将其转换成更有用的形式才行。</p><p>三、小结<br>pd.options.display.max_rows = 10 #限制显示数量</p><p>data = pd.merge(pd.merge(ratings, users), movies)</p><p>data.iloc[0]</p><p>mean_ratings = data.pivot_table(‘rating’, index=’title’,</p><p>….: columns=’gender’, aggfunc=’mean’)</p><p>ratings_by_title = data.groupby(‘title’).size()</p><p>active_titles = ratings_by_title.index[ratings_by_title &gt;= 250]</p><p>mean_ratings = mean_ratings.loc[active_titles]</p><p>top_female_ratings = mean_ratings.sort_values(by=’F’, ascending=False)</p><p>mean_ratings[‘diff’] = mean_ratings[‘M’] - mean_ratings[‘F’]</p><p>sorted_by_diff = mean_ratings.sort_values(by=’diff’)</p><p>sorted_by_diff[::-1][:10] #倒序</p><p>rating_std_by_title = data.groupby(‘title’)[‘rating’].std()#标准差</p><p>rating_std_by_title = rating_std_by_title.loc[active_titles]#选择列</p><p>rating_std_by_title.sort_values(ascending=False)[:10]#排序</p><p>·后记<br>最后一章，查缺补漏。本节涉及了表的读取、合并、选择、透视、分组、排序、筛选、统计，功能相对齐全。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用python进行数据分析-numpy</title>
      <link href="/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-numpy/"/>
      <url>/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-numpy/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- toc --><ul><li><a href="#%E4%B8%80-numpy%E5%8C%85%E7%AE%80%E4%BB%8B">一、NumPy包简介</a><ul><li><a href="#11-%E7%AE%80%E4%BB%8B">1.1 简介</a></li></ul></li><li><a href="#%E4%BA%8C-%E5%AE%9E%E4%BE%8B">二、实例</a><ul><li><a href="#21-%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94">2.1 性能对比</a></li><li><a href="#22-%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0">2.2 产生随机数</a></li><li><a href="#23-%E6%89%B9%E9%87%8F%E8%BF%90%E7%AE%97">2.3 批量运算</a></li><li><a href="#24-%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84">2.4 创建数组</a></li><li><a href="#25-ndarray%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2.5 ndarray的数据类型</a></li></ul></li><li><a href="#%E4%B8%89-%E5%B0%8F%E7%BB%93">三、小结</a></li></ul><!-- tocstop --><p>书摘前言：</p><p>《利用Python进行数据分析·第2版》是量化分析前置中非常具有教科书意义的一本书，其中前三章为基础知识。第四章起是相对重要的内容，也是此文收录的内容和我的一些想法，依托每篇文章两千字左右的篇幅拆分成几篇。感谢作者McKinney和SeanCheney。</p><h1><span id="一-numpy包简介">一、NumPy包简介</span></h1><h2><span id="11-简介">1.1 简介</span></h2><p>该包是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。</p><p>NumPy最重要的一个特点就是其N维数组对象（即ndarray），该对象是一个快速而灵活的大数据集容器。后续所有提到的数组都是指ndarry。</p><h1><span id="二-实例">二、实例</span></h1><h2><span id="21-性能对比">2.1 性能对比</span></h2><p>要搞明白具体的性能差距，考察一个包含一百万整数的数组，和一个等价的Python列表：</p><p>In [7]: import numpy as np #np为通用简写,测试环境为ipython</p><p>In [8]: my_arr = np.arange(1000000) #所有涉及np的代码建议手打一遍</p><p>In [9]: my_list = list(range(1000000))</p><p>#各个序列分别乘以2：</p><p>In [10]: %time for _ in range(10): my_arr2 = my_arr * 2</p><p>CPU times: user 20 ms, sys: 50 ms, total: 70 ms</p><p>Wall time: 72.4 ms #我的是22ms</p><p>In [11]: %time for _ in range(10): my_list2 = [x * 2 for x in my_list]</p><p>CPU times: user 760 ms, sys: 290 ms, total: 1.05 s</p><p>Wall time: 1.05 s #我的是1.37s</p><p>基于NumPy的算法要比纯Python快10到100倍（甚至更快），并且使用的内存更少。#我的耗时为1370ms:22ms,折合62倍</p><h2><span id="22-产生随机数">2.2 产生随机数</span></h2><p>In [12]: import numpy as np</p><p>In [13]: data = np.random.randn(2, 3)#2,3为2行3列</p><p>In [14]: data</p><p>Out[14]:</p><p>array([[-0.2047, 0.4789, -0.5194],</p><p>[-0.5557, 1.9658, 1.3934]])</p><h2><span id="23-批量运算">2.3 批量运算</span></h2><p>In [15]: data * 10 #进行整体的数学运算,数值10倍</p><p>Out[15]:</p><p>array([[ -2.0471, 4.7894, -5.1944],</p><p>[ -5.5573, 19.6578, 13.9341]])</p><p>·原数组乘2,可以用*实现数组内全数平方</p><p>In [16]: data + data</p><p>Out[16]:</p><p>array([[-0.4094, 0.9579, -1.0389],</p><p>[-1.1115, 3.9316, 2.7868]])</p><p>·ndarray中的所有元素必须是相同类型的。每个数组都有一个shape（一个表示各维度大小的元组）和一个dtype（一个用于说明数组数据类型的对象）：</p><p>In [17]: data.shape #几行几列</p><p>Out[17]: (2, 3)</p><p>In [18]: data.dtype #数据类型dtype=datatype</p><p>Out[18]: dtype(‘float64’)</p><p>·数组大小的对比</p><p>In [51]: arr = np.array([[1., 2., 3.], [4., 5., 6.]])</p><p>In [57]: arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])</p><p>In [59]: arr2 &gt; arr</p><p>Out[59]:</p><p>array([[False, True, False],</p><p>[ True, False, True]])</p><h2><span id="24-创建数组">2.4 创建数组</span></h2><p>·创建数组最简单的办法就是使用array函数。</p><p>In [19]: data1 = [6, 7.5, 8, 0, 1]</p><p>In [20]: arr1 = np.array(data1) #转化为ndarry</p><p>In [21]: arr1</p><p>Out[21]: array([ 6. , 7.5, 8. , 0. , 1. ])</p><p>·嵌套序列将会被转换为一个多维数组：</p><p>In [22]: data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]</p><p>In [23]: arr2 = np.array(data2) #转化为2行两列的多维数组</p><p>In [24]: arr2</p><p>Out[24]:</p><p>array([[1, 2, 3, 4],</p><p>[5, 6, 7, 8]])</p><p>·数组的行列数统计</p><p>In [25]: arr2.ndim #行数函数,代表两行</p><p>Out[25]: 2</p><p>In [26]: arr2.shape#数组的行数和列数组成的元组</p><p>Out[26]: (2, 4)</p><p>·zeros和ones分别可以创建指定长度或形状的全0或全1数组。</p><p>empty可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元组即可：</p><p>In [30]: np.zeros((3, 6))</p><p>Out[30]:</p><p>array([[ 0., 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0., 0.],</p><p>[ 0., 0., 0., 0., 0., 0.]])</p><p>In [31]: np.empty((2, 3, 2)) #返回的不一定是0,可能是任何数</p><p>Out[31]:</p><p>array([[[ 0., 0.], [ 0., 0.], [ 0., 0.]], [[ 0., 0.],</p><p>[ 0., 0.], [ 0., 0.]]])</p><p>·由于NumPy关注的是数值计算，因此，如果没有特别指定，数据类型基本都是float64（浮点数）</p><h2><span id="25-ndarray的数据类型">2.5 ndarray的数据类型</span></h2><p>dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息：</p><p>In [33]: arr1 = np.array([1, 2, 3], dtype=np.float64)</p><p>In [35]: arr1.dtype</p><p>Out[35]: dtype(‘float64’)</p><p>·NumPy的数据类型（简单了解即可，后续实例中慢慢掌握）</p><p>int8、uint8（i1、 u1）：有符号和无符号的8位(1个字节)整型</p><p>int16、uint16（i2、u2）： 有符号和无符号的16位(2个字节)整型</p><p>int32、uint32（i4、u4）：有符号和无符号的32位(4个字节)整型</p><p>int64、uint64（i8、u8）：有符号和无符号的64位(8个字节)整型</p><p>float16 （f2）： 半精度浮点数</p><p>float32（f4或f）： 标准的单精度浮点数。与C的float兼 容</p><p>float64（f8或d）： 标准的双精度浮点数。</p><p>float128（f16或g） ：扩展精度浮点数</p><p>complex64、complex128、complex256（c8 c16 c32）分别用两个32位、64位或128位浮点数表示的复数</p><p>bool 存储True和False值的布尔类型</p><p>·你可以通过ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype：</p><p>In [37]: arr = np.array([1, 2, 3, 4, 5])</p><p>In [38]: arr.dtype</p><p>Out[38]: dtype(‘int64’)</p><p>In [39]: float_arr = arr.astype(np.float64)</p><p>In [40]: float_arr.dtype</p><p>Out[40]: dtype(‘float64’)</p><p>·如果转换反向把小数转整数,则会直接去掉小数部分。字符串如果全是数字，也可以转换为数值。</p><p>·数组的切片</p><p>In [60]: arr = np.arange(10)</p><p>In [61]: arr</p><p>Out[61]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</p><p>In [62]: arr[5]</p><p>Out[62]: 5</p><p>In [63]: arr[5:8]</p><p>Out[63]: array([5, 6, 7])</p><p>In [64]: arr[5:8] = 12</p><p>In [65]: arr</p><p>Out[65]: array([ 0, 1, 2, 3, 4, 12, 12, 12, 8, 9])</p><p>当你将一个标量值赋值给一个切片时（如arr[5:8]=12），该值会自动传播到整个选区。跟列表最重要的区别在于，数组切片是原始数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。</p><p>·注意：如果你想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作:arr[5:8].copy()。</p><p>·对于高维度数组，能做的事情更多。在一个二维数组中，各索引位置上的元素不再是标量而是一维数组：</p><p>In [72]: arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</p><p>In [73]: arr2d[2]</p><p>Out[73]: array([7, 8, 9])</p><p>·你可以传入一个以逗号隔开的索引列表来选取单个元素。也就是说，下面两种方式是等价的：</p><p>In [74]: arr2d[0][2]</p><p>Out[74]: 3</p><p>In [75]: arr2d[0, 2]</p><p>Out[75]: 3</p><p>·索引列表中相当于数组的一部分,操作部分同样会影响到整体</p><p>·多维数组切片，可以选取第二行的前两列,通过对切片的影响,可以变更数组的部分：</p><p>In [93]: arr2d[1, :2]</p><p>Out[93]: array([4, 5])</p><h1><span id="三-小结">三、小结</span></h1><p>import numpy as np #导入</p><p>np.arange(1000000) #生成一个0至999999的数组</p><p>np.random.randn(2, 3) #产生一个2行3列的随机数</p><p>arr1 = np.array(data1) #建立数组</p><p>data.shape #数组的行列数</p><p>data.dtype #数组的类型</p><p>arr2.ndim #数组的行数</p><p>np.zeros(10) #生成包含10个0的一维数组</p><p>np.empty((2, 3, 2)) #生成2个3行2列的数组</p><p>arr1 = np.array([1, 2, 3], dtype=np.float64) #建立指定类型的数组</p><p>float_arr = arr.astype(np.float64) #借鉴其他数组建立不同类型数组</p><p>arr[5:8].copy() #复制一个一样的数组</p><p>arr2d[0][2] #取数组的部分</p><p>arr2d[1, :2] #数组切片</p><p>此处其实原文还有些许其他内容，但是个人建议可以等到有需求要用的时候再搜来学。</p><p>个人觉得，所有知识系统的核心应该是应用场景。</p>]]></content>
      
      
      
        <tags>
            
            <tag> numpy </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习书单</title>
      <link href="/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%A6%E5%8D%95/"/>
      <url>/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="数据分析">数据分析</span></h1><ol><li>利用python进行数据分析</li></ol><h1><span id="机器学习">机器学习</span></h1><ol><li>python机器学习基础教程</li><li>机器学习实战：基于Scikit-Learn和TensorFlow</li><li>机器学习（周志华）</li><li>统计学习方法（李航）</li><li>优达学城-机器学习入门</li><li>Cousera-机器学习-吴恩达</li><li>Python机器学习实践指南</li><li>Python机器学习——预测分析核心算法</li><li>实用机器学习</li><li>深入理解XGBoost：高效机器学习算法与进阶</li><li>分布式机器学习：算法、理论与实践</li></ol><h1><span id="深度学习">深度学习</span></h1><ol><li>python神经网络编程</li><li>深度学习入门-基于python的理论与实现</li><li>python深度学习</li><li>深度学习</li><li>deeplearning.ai-深度学习吴恩达</li><li>TensorFlow技术解析与实战</li><li>精通Python自然语言处理</li><li>Hands-On Machine Learning with Scikit-Learn and TensorFlow</li></ol><h1><span id="强化学习">强化学习</span></h1><ol><li>Reinforcement learning</li></ol><h1><span id="数学">数学</span></h1><ol><li>可汗学院</li><li>线性代数及其应用</li><li>概率论基础教程</li><li>统计学</li></ol><h1><span id="实践">实践</span></h1><ol><li>智能风控：原理、算法与工程实践</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 书单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习路线</title>
      <link href="/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="机器学习路线图">机器学习路线图</span></h1><h2><span id="入门课程">入门课程</span></h2><ol><li><a href="https://www.coursera.org/learn/machine-learning">Machine Learning | Coursera</a><br>入门首选，推荐只认识“机器学习”四个字但还不知道它是什么的学习这些年机器学习的大多数年轻人靠这个入门。具体提纲我就不列了，免得增加篇幅。建议是直接按顺序一课课学，不要着急。在学完这个课程前，不要学后面的。<br>关于这门课的官方介绍是：本课程将广泛介绍机器学习、数据挖掘和统计模式识别。相关主题包括：(i) 监督式学习（参数和非参数算法、支持向量机、核函数和神经网络）。(ii) 无监督学习（集群、降维、推荐系统和深度学习）。(iii) 机器学习实例（偏见/方差理论；机器学习和AI领域的创新）。课程将引用很多案例和应用，您还需要学习如何在不同领域应用学习算法，例如智能机器人（感知和控制）、文本理解（网络搜索和垃圾邮件过滤）、计算机视觉、医学信息学、音频、数据库挖掘等领域。这门课基本涵盖了机器学习的主要知识点，例如：线性回归、逻辑回归、支持向量机、神经网络、K-Means、异常检测等等。而且课程中没有复杂的公式推导和理论分析。Ng 的目的是让机器学习初学者能够快速对整个机器学习知识点有比较整体的认识，便于快速入门。</li></ol><p><img src="https://pic1.zhimg.com/v2-2b979310ac6c053b9a96a1e594824934_b.jpg" alt="img"></p><ol start="2"><li><p><a href="http://cs231n.stanford.edu/">CS231n: Convolutional Neural Networks for Visual RecognitionStanford</a><br>最受欢迎的课之一.</p></li><li><p>机器学习体系图</p><p><img src="https://img-blog.csdnimg.cn/20190425205801254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2MDYzMDc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ol><h1><span id="引用链接">引用链接</span></h1><p><a href="https://www.nowcoder.com/tutorial/95/3cefbe4d0e914256b1271fe3417dded8">面试技巧</a><br><a href="https://www.nowcoder.com/discuss/experience?tagId=645">面经</a><br><a href="https://www.nowcoder.com/ta/review-ml">面试题</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己写一个数据库</title>
      <link href="/posts/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/posts/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="godb">godb</span></h1><blockquote><p>本项目中，数据库就是本地一个文件夹，表也是数据库下的目录，里面的数据就是表文件夹下的文件，<br>表目录下的scheme.json保存着表结构<br>表目录下data0.json data1.json分别存储着数据，每个文件里的数据不超过1000行。</p></blockquote><h2><span id="设计逻辑">设计逻辑</span></h2><ul><li>  代码分为client端和server端</li><li>  server端开启端口，接收指令，并执行指令</li><li>  client端连接端口，发送指令</li><li>server端分层执行<ul><li>  解析语句，判断类型，建库、建表、插入数据等等</li><li>  不同类型语句进入不同service执行，互不干扰</li><li>  验证语句，返回数据</li></ul></li></ul><h2><span id="建库">建库</span></h2><blockquote><p>暂时建表只支持这种格式，实际实现是在项目tmp目录下新建一个db1的文件夹</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database db1</span><br></pre></td></tr></table></figure><h2><span id="建表">建表</span></h2><blockquote><p>暂时只支持  ‘id’ 列名， varchar（255） 类型长度，以及默认值<br>以及主键<br>实际实现是在数据库目录下新建一个表名的文件夹，并有一个scheme.json文件记录各列属性</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>  table1 (`id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h2><span id="插入数据">插入数据</span></h2><blockquote><p>支持语句格式,value 只支持一个括号，values支持多个括号多行数据插入<br>实际实现是在表文件夹下，新建data(i).json文件，里面存储具体数据，i是预留数据量大的情况下的分文件存储，每个文件暂时最多支持存储1000行。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> feature_conf <span class="keyword">values</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>// TODO</p><ul><li>  [ ] 增加索引文件，指向data(i).json并指明多少列</li><li>  [ ] 索引文件分层，类似B+树存储</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>String.intern方法理解</title>
      <link href="/posts/String-intern%E6%96%B9%E6%B3%95%E7%90%86%E8%A7%A3/"/>
      <url>/posts/String-intern%E6%96%B9%E6%B3%95%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="intern作用">intern作用</span></h2><blockquote><p>如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回</p></blockquote><p>先明白含义是什么，再看一道题，copy美团的文章，详见参考一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    s.intern();</span><br><span class="line">    String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    s3.intern();</span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>jdk7,8下false true<br>jdk6以下false false</p></blockquote><p>接下来把intern下移一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    s.intern();</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    s3.intern();</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>jdk7,8下false false<br>jdk6以下false false</p></blockquote><p>看完答案后，我是很懵逼的，我有看了美团文章的解释，瞬间，更懵逼了。美团文章解释的其实挺好的，但是没有抓住重点。<br>详细论证两篇文章都有，基本都能看明白（看不明白可以找我交流），重点在两点：</p><ul><li>jdk7、8和6有什么不同： 7以上将常量池从perm区移到了heap中</li><li>jdk7、8第一个程序中为什么一个是false，一个是true，<strong>jdk7以后常量去不仅仅可以保存对象，也可以保存对象的引用</strong>，所以s3的引用被保存到常量区中，s4直接在常量区找到了对象的引用，所以为true。</li></ul><p>有兴趣研究的同学，可以联系我，微信 ryry89，邮箱<a href="mailto:&#x65;&#x61;&#x72;&#121;&#97;&#110;&#x74;&#76;&#x65;&#101;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">&#x65;&#x61;&#x72;&#121;&#97;&#110;&#x74;&#76;&#x65;&#101;&#x40;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a></p><p><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html">参考一</a><br><a href="https://www.cnblogs.com/Kidezyq/p/8040338.html">参考二</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>谷歌jib工具试用</title>
      <link href="/posts/%E8%B0%B7%E6%AD%8Cjib%E5%B7%A5%E5%85%B7%E8%AF%95%E7%94%A8/"/>
      <url>/posts/%E8%B0%B7%E6%AD%8Cjib%E5%B7%A5%E5%85%B7%E8%AF%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="jib">Jib</span></h1><p>好久没写blog了，最近看到google新开源的工具心痒痒，试着玩下~<br>首先什么是Jib，：</p><blockquote><p>Jib 是 Google 开发的可以直接构建 Java 应用的 Docker 和 OCI 镜像的类库，以 Maven 和 Gradle 插件形式提供。<br>通过 Jib，Java 开发者可以使用他们熟悉的 Java 工具来构建容器。Jib 是一个快速而简单的容器镜像构建工具，它负责处理将应用程序打包到容器镜像中所需的所有步骤。它不需要你编写 Dockerfile 或安装 Docker，而且可以直接集成到 Maven 和 Gradle中 —— 只需要将插件添加到构建中，就可以立即将 Java 应用程序容器化。</p></blockquote><h2><span id="构建流程">构建流程</span></h2><ul><li><p>Docker构建的复杂流程<br><img src="https://static.oschina.net/uploads/space/2018/0710/155927_vHQt_2720166.png"></p></li><li><p>Jib构建流程<br><img src="https://static.oschina.net/uploads/space/2018/0710/155918_xYRX_2720166.png"></p></li></ul><p>从此可以告别繁琐的Dockerfile啦~~</p><h2><span id="上手">上手</span></h2><ol><li><p>首先配置jib插件<br> maven:</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.cloud.tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jib-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">image</span>&gt;</span></span><br><span class="line">                        registry.hub.docker.com/adoptopenjdk/openjdk8</span><br><span class="line">          <span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">image</span>&gt;</span>registry.hub.docker.com/earyant/earyant<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p> gradle</p> <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  id <span class="string">&#x27;com.google.cloud.tools.jib&#x27;</span> version <span class="string">&#x27;0.9.6&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">jib.to.image = <span class="string">&#x27;registry.hub.docker.com/earyant/earyant&#x27;</span></span><br><span class="line">jib.<span class="keyword">from</span>.image = <span class="string">&#x27;registry.hub.docker.com/adoptopenjdk/openjdk8&#x27;</span></span><br></pre></td></tr></table></figure><hr><p>需要注意的是image不加域名的话，默认是gcr.io,google Cloud下的镜像，<strong>需要梯子</strong>，所以没有梯子的话，请使用 registry.hub.docker.com,阿里云加速同理</p></li></ol><p>如果不加from标签，也是默认访问grc.io去下载jdk镜像，emmmm，同样需要梯子，报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Build to Docker daemon failed: Connect to gcr.io/108.177.97.82:443 timed out</span><br></pre></td></tr></table></figure><p>所以记得加上from镜像标签哦~~</p><p>如果报错信息如下，请先登录docker login -name=earyant registry.hub.docker.com  ，如果没有注册过，请到docker官网注册~<br>Retrieving registry credentials for registry.hub.docker.com</p><ol start="2"><li>Build</li></ol><ul><li><p>build到远程仓库</p><ul><li>gradle jib</li><li>mvn compile jib:build</li></ul></li><li><p>本地运行（确保本地docker已运行 ）</p><ul><li>mvn compile jib:dockerBuild</li><li>gradle jibDockerBuild</li></ul></li></ul><ol start="3"><li>运行<br>本地镜像查看如下：<br>docker images<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">earyant/earyant       latest              e34b4cad637b        48 years ago        367MB</span><br></pre></td></tr></table></figure></li></ol><p>docker run -p 8880:8880  -it –rm –name earyant registry.hub.docker.com/earyant/earyant</p><p>访问 <a href="http://localhost:8880/">http://localhost:8880</a> 即可纵享丝滑，开心~~~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>持续实战</title>
      <link href="/posts/%E6%8C%81%E7%BB%AD%E5%AE%9E%E6%88%98/"/>
      <url>/posts/%E6%8C%81%E7%BB%AD%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li><input disabled type="checkbox"> mysql主从配置</li><li><input disabled type="checkbox"> mybatis自动生成代码</li><li><input disabled type="checkbox"> 读写分离，与主从配置相关联</li><li><input disabled type="checkbox"> 分布式redis缓存</li><li><input disabled type="checkbox"> tomcat session共享、session绑定</li><li><input disabled type="checkbox"> 分布式锁：redis、mysql</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 持续实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm系列</title>
      <link href="/posts/jvm%E7%B3%BB%E5%88%97/"/>
      <url>/posts/jvm%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="jvm系列一java类的加载机制"></span></h2><ul><li><p>什么是类的加载</p><blockquote><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p></blockquote></li><li><p>类的生命周期</p><ul><li>  加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</li><li>  连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用</li><li>  初始化，为类的静态变量赋予正确的初始值</li><li>  使用，new出对象程序中使用</li><li>  卸载，执行垃圾回收</li></ul></li><li><p>类加载器</p><ul><li><p>  启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库</p></li><li><p>  扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p></li><li><p>  应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器</p></li></ul></li><li><p>双亲委派模型</p><pre><code>  \-  全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入  - 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类  - 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</code></pre><h2><span id="jvm系列二jvm内存结构"></span></h2><p>  <img src="http://mmbiz.qpic.cn/mmbiz_png/PgqYrEEtEnprm5p8TE8Ogn2WfVM3YUA5R55vvKcRJC1UXBVrjuEJuLOxD6woyWpicufMicSZbZTpLrGrNrr0cmAQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1"></p></li></ul><blockquote><p>方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序计数器是运行是线程私有的内存区域。</p></blockquote><ul><li><p>  Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p></li><li><p>  方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></li><li><p>  程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>  JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p></li><li><p>  本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p></li></ul><h3><span id="对象分配规则">对象分配规则</span></h3><ul><li><p>  对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</p></li><li><p>  大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p></li><li><p>  长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</p></li><li><p>  动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p></li><li><p>  空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</p></li></ul><h2><span id="jvm系列三gc算法-垃圾收集器"></span></h2><h3><span id="对象存活判断">对象存活判断</span></h3><blockquote><p>判断对象是否存活一般有两种方式：</p></blockquote><ul><li><p>  引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p></li><li><p>  可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</p></li></ul><h3><span id="gc算法">GC算法</span></h3><ul><li><p>  GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。</p></li><li><p>  标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</p></li><li><p>  复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p></li><li><p>  标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p></li><li><p>  分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p></li></ul><h3><span id="垃圾回收器">垃圾回收器</span></h3><ul><li><p>  Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。</p></li><li><p>  ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。</p></li><li><p>  Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。</p></li><li><p>  Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法</p></li><li><p>  CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p></li><li><p>  G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征</p></li></ul><p>在Java语言中，GC Roots包括：</p><ul><li>  虚拟机栈中引用的对象。</li><li>  方法区中类静态属性实体引用的对象。</li><li>  方法区中常量引用的对象。</li><li>  本地方法栈中JNI引用的对象。</li></ul><h2><span id="jvm系列四jvm调优-命令篇"></span></h2><h3><span id="调优命令">调优命令</span></h3><blockquote><p>  Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</p></blockquote><ul><li>  jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li><li>  jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li><li>  jmap，JVM Memory Map命令用于生成heap dump文件</li><li>  jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li><li>  jstack，用于生成java虚拟机当前时刻的线程快照。</li><li>  jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</li></ul><h2><span id="jvm系列五java-gc-分析"></span></h2><h3><span id="主要关注点">主要关注点：</span></h3><ul><li><p>  GC日志分析</p></li><li><p>  调优命令</p></li><li><p>  调优工具</p></li></ul><p><a href="https://earyant.github.io/2018/05/04/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E8%84%9A%E6%9C%AC/">参考</a><br><a href="https://earyant.github.io/2018/05/04/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">参考</a></p><h2><span id="jvm系列六java服务gc参数调优案例"></span></h2><p>##<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247484023&idx=1&sn=39be119fdf3132240adc84a85bf8a054&chksm=ebf6da08dc81531e3719389555150f2d0237554b6b6c07a123efdea7c78c0ae2f064cc577bd4&scene=21#wechat_redirect">jvm系列(七):jvm调优-工具篇</a></p><blockquote><p>调优工具</p></blockquote><ul><li>  常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。</li><li>  jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li><li>  jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。</li><li>  MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li><li>  GChisto，一款专业分析gc日志的工具</li></ul><h2><span id="jvm系列八jvm知识点总览"></span></h2><h2><span id="jvm系列九如何优化java-gc译"></span></h2><h2><span id="jvm系列十教你如何成为java的oom-killer"></span></h2><p>##<a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247484074&idx=1&sn=826318867783afaf99f62b38b2f5c268&chksm=ebf6dad5dc8153c32a6ce0201afe310b47135b07c8bb028a8fd9df7ecaf6e60950a7847c7df5&scene=21#wechat_redirect">jvm系列(十一):Java 8-从持久代到metaspace</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日志分析脚本</title>
      <link href="/posts/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E8%84%9A%E6%9C%AC/"/>
      <url>/posts/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="sed编辑器">sed编辑器</span></h2><p>不修改原内容的行级别流编辑器</p><ul><li><p>sed ‘s/baidu /earyant/‘ access.log | head -10</p><blockquote><p>将日志文件中的baidu替换成earyant输出<br>s表示执行的事文本替换命令</p></blockquote></li><li><p>sed -n ‘2,6p’ access.log</p><blockquote><p>-n表示只输出指定的行，’2,6p’表示选择的事第二行到第六行</p></blockquote></li><li><p>sed ‘/earyant/d’ access.log</p><blockquote><p>d表示执行文本删除命令，将包含earyant的行删除</p></blockquote></li><li><p>sed ‘=’ access.log</p><blockquote><p>显示文本行号</p></blockquote></li><li><p>sed -e ‘i\head’ access.log | head -10</p><blockquote><p>在行首插入文本</p></blockquote></li><li><p>sed -e ‘a\end’ access.log | head -10</p><blockquote><p> 在文末追加文本</p></blockquote></li><li><p>sed -e ‘/baidu/c\hello’ access.log | head -10</p><blockquote><p>c命令对文本进行替换，查找/baidu/匹配的行，用hello对匹配的行进行替换，与s不同的是，这个替换行，s是替换单词</p></blockquote></li><li><p>sed -n ‘1,5p;1,5=’ access.log</p><blockquote><p>多条命令，分号隔开</p></blockquote></li></ul><h2><span id="awk">awk</span></h2><ul><li><p>awk ‘{print $1}’ access.log | head -10</p><blockquote><p>打印指定的列</p></blockquote></li><li><p>awk ‘/baidu/{print $5,%6}’ access.log | head -10</p><blockquote><p>筛选指定的行，并且打印出其中一部分列</p></blockquote></li><li><p>awk ‘length{$0} &gt; 40 {print $3}’ access.log | head  -10</p><blockquote><p>$0 表示当前的行，length($0)获取当前行的长度，print $3 打印出第三列</p></blockquote></li><li><p>awk ‘{line = sprintf (“method:%s,response:%s”,$3,$7); print line}’ access.log | head -10</p><blockquote><p>定义line接收sprintf输出，sprintf用户格式化输出第三行的请求式和第七行的响应时间</p></blockquote></li></ul><h2><span id="shell">shell</span></h2><ul><li>  系统load超过2或者磁盘利用率超过85%报警：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#earyantlee@gmail.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#top取系统load值， -n 1 表示只刷新一次</span></span><br><span class="line"><span class="comment"># sed 过滤第一行</span></span><br><span class="line"><span class="comment"># top命令会输出1分钟、5分钟、15分钟load的平均值，awk筛选出1分钟内的平均load，赋值给load</span></span><br><span class="line">load = `top -n 1| sed -n <span class="string">&#x27;1p&#x27;</span> | awk <span class="string">&#x27;&#123;print $11&#125;&#x27;</span>`</span><br><span class="line"><span class="comment"># 从右边开始，过滤掉不需要的逗号</span></span><br><span class="line">load = <span class="variable">$&#123;load%\,*&#125;</span></span><br><span class="line"><span class="comment"># df取得磁盘利用率信息，用sed筛选磁盘总利用率第二行</span></span><br><span class="line">disk_usage = `df -h | sed -n <span class="string">&#x27;2p&#x27;</span> |awk <span class="string">&#x27;&#123;print $(NF - 1)&#125;&#x27;</span> `</span><br><span class="line"><span class="comment"># 过滤掉百分号</span></span><br><span class="line">disk_usage = <span class="variable">$&#123;disk_usage%\%*&#125;</span></span><br><span class="line">overhead = `expr <span class="variable">$load</span> \&gt; 2.00`</span><br><span class="line"><span class="keyword">if</span> [<span class="variable">$overhead</span> -eq 1];<span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;System load is overhead&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [<span class="variable">$disk_usage</span> -gt 85 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;disk is nearly full ,need more disk space&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><ul><li>读取日志文件，对字段切割，插入到sql。<br>  db:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create table access_log(</span><br><span class="line">  ip varchar(20),# ip地址</span><br><span class="line">  rt bigint,# 响应时间</span><br><span class="line">  method varchar(10), #请求方式</span><br><span class="line">  url varchar (400), # 请求地址</span><br><span class="line">  refer varchar(400),# 请求来源</span><br><span class="line">  return_code int,# 返回码</span><br><span class="line">  response_size bigint # 响应大小</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>shell:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#earyantlee@gmail.com</span></span><br><span class="line"><span class="comment"># 日志路径</span></span><br><span class="line">ACCESS_FILE=<span class="string">&quot;D:\\0\\nginx-1.11.13\\logs\\access2.log&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> LINE</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 系统数组分隔符</span></span><br><span class="line">  OLD_IFS=<span class="string">&quot;<span class="variable">$IFS</span>&quot;</span></span><br><span class="line">  IFS=<span class="string">&quot; &quot;</span></span><br><span class="line">  <span class="comment"># 每行分割成数组</span></span><br><span class="line">  field_arr=(<span class="variable">$LINE</span>)</span><br><span class="line">  IFS=<span class="string">&quot;<span class="variable">$OLD_IFS</span>&quot;</span></span><br><span class="line">  <span class="comment"># 生成插入语句，各列的值对应什么，懒得改了。</span></span><br><span class="line">  STATEMENT=<span class="string">&quot;insert into access_log values(&#x27;<span class="variable">$&#123;field_arr[0]&#125;</span>&#x27; , &#x27;<span class="variable">$&#123;field_arr[1]&#125;</span>&#x27;, &#x27;<span class="variable">$&#123;field_arr[2]&#125;</span>&#x27;, &#x27;<span class="variable">$&#123;field_arr[3]&#125;</span>&#x27;, &#x27;<span class="variable">$&#123;field_arr[4]&#125;</span>&#x27;, &#x27;<span class="variable">$&#123;field_arr[5]&#125;</span>&#x27;, &#x27;<span class="variable">$&#123;field_arr[6]&#125;</span>&#x27;);&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$STATEMENT</span></span><br><span class="line">  mysql earyant -u root -p123456 -e <span class="string">&quot;<span class="variable">$&#123;STATEMENT&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &lt; <span class="variable">$ACCESS_FILE</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日志分析常用命令</title>
      <link href="/posts/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/posts/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="查看文件的内容">查看文件的内容</span></h2><ul><li><p>cat：正序查看</p><blockquote><p>cat access.log</p></blockquote></li><li><p>tac：倒序查看</p><blockquote><p>tac access.log</p></blockquote></li></ul><p>##分页显示文件</p><ul><li><p>more</p><blockquote><p>more access.log</p></blockquote><p>   Enter显示文件下一行<br>   空格显示下一页<br>   F显示下一屏内容<br>   B显示上一屏内容</p></li><li><p>less</p><blockquote><p>/GET 查找GET字符串</p></blockquote></li></ul><h2><span id="显示文件尾">显示文件尾</span></h2><ul><li><p>tail</p><blockquote><p>tail  -f -n 500 access.log</p></blockquote><p>   -f  持续查看<br>   -n 显示最后n行</p></li></ul><h2><span id="显示文件头">显示文件头</span></h2><ul><li>head<blockquote><p>head -n2 access.log</p></blockquote></li></ul><h2><span id="内容排序">内容排序</span></h2><ul><li><p>sort</p><blockquote><p>sort -n -r access.log</p></blockquote><p>   -n 按照数字排序<br>   -r 逆序排序</p><blockquote><p>sort -k 2 -t “ “ -n access.log</p></blockquote><p>   -k 指定排序的列<br>   -t 指定列分隔符<br>   -n 按照数字排序</p></li></ul><h2><span id="字符统计">字符统计</span></h2><ul><li><p>wc</p><blockquote><p>  wc -l access.log</p></blockquote><pre><code>-l 统计文件中的行数</code></pre><blockquote><p>  wc -c access.log</p></blockquote><pre><code>-c 显示文件的字节数</code></pre><blockquote><p>  wc -L access.log</p></blockquote><pre><code>-L得出最长的行长度</code></pre><blockquote><p>  wc -w access.log</p></blockquote><pre><code>-w 查看文件包含多少单词</code></pre></li></ul><h2><span id="重复行">重复行</span></h2><ul><li><p>uniq</p><blockquote><p> sort uniqfile| uniq -c</p></blockquote><pre><code>\-c 用来在每一行前面加上该行出现的次数</code></pre><blockquote><p>  sort uniqfile | uniq -c -u</p></blockquote><pre><code>\-u 只会显示出现一次的行</code></pre><blockquote><p>  sort uniqfile | uniq -c -d</p></blockquote><pre><code>\-d 只会显示重复出现的行</code></pre></li></ul><h2><span id="字符串查找">字符串查找</span></h2><ul><li><p>grep</p><pre><code>  &gt;   grep earyant access.log    earyant 为指定的查找串  &gt; grep -c earyant access.log    -c 可以显示查找到的行数  &gt;   grep &#39;G.\*T&#39; access.log    支持正则表达式</code></pre><h2><span id="文件查找">文件查找</span></h2></li><li><p>find</p><blockquote><p>find /home/earyant -name access.log</p></blockquote><pre><code> 在/home/earyant 目录下查找文件名为access.log的文件</code></pre><blockquote><p>find /home/earyant -name “*.txt”</p><p>find . -print</p></blockquote><pre><code> 打印当前目录所有文件</code></pre></li><li><p>whereis</p><blockquote><p>whereis java</p></blockquote></li><li><p>which</p><blockquote><p>which java</p></blockquote></li></ul><h2><span id="表达式求值">表达式求值</span></h2><ul><li>expr<blockquote><p>expr 10 * 3<br>expr 10 % 3<br>expr index “earyant.github.io” earyant</p></blockquote></li></ul><h2><span id="压缩">压缩</span></h2><ul><li><p>tar</p><blockquote><p>tar -cf aaa.tar tmp1 tmp2</p></blockquote><pre><code>  将当前目录下的tmp1和tmp2目录打包成aaa.tar  -c 表示生成新包  -f 指定包名称</code></pre><blockquote><p>tar -tf aaa.tar</p></blockquote><pre><code>  -t 能够列出包中文件的名称</code></pre><blockquote><p>tar -xf aaa.tar</p></blockquote><pre><code>  -x 将打包文件解压</code></pre></li></ul><h2><span id="url-访问工具">url 访问工具</span></h2><ul><li><p>curl</p><blockquote><p>curl <a href="http://www.baidu.com/">www.baidu.com</a></p><p>curl -i <a href="http://www.baidu.com/">www.baidu.com</a></p></blockquote><p>  -i 返回带header的文档</p><blockquote><p>curl -I <a href="http://www.baidu.com/">www.baidu.com</a></p></blockquote><p>  -I 只返回页面的header信息</p><h2><span id="查看请求访问量">查看请求访问量</span></h2></li></ul><blockquote><p>cat access.log | cut -f1 -d “ “ | sort | uniq -c | sort -k 1 -n -r | head -10</p></blockquote><p>访问量排名前10的ip地址</p><blockquote><p>cat  access.log | cut  -f4 -d “ “ | sort | uniq -c | sort -k 1 -n -r | head -10</p></blockquote><p>页面访问量排名前10的url</p><h2><span id="查看最耗时的页面">查看最耗时的页面</span></h2><blockquote><p>cat access.log | sort -k 2 -n -r |head -10</p></blockquote><h2><span id="统计404请求的占比">统计404请求的占比</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export total_line = `wc -l access.log | cut -f1 -d &quot; &quot;` &amp;&amp; export not_found_line = `awk &#x27;$6==&#x27;404&#x27;&#123;print $6&#125;&#x27; access.log | wc -l`  &amp;&amp; expr $ not_found_line \*100 / $total_line</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Guava 1.1基本工具</title>
      <link href="/posts/Guava-1-1%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/"/>
      <url>/posts/Guava-1-1%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="11-使用和避免null">1.1-使用和避免null</span></h1><p>map允许null作为键，但只能有一个。<br>concurrentHashMap不允许null作为键。</p><h2><span id="optional">Optional</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; possible = Optional.of(<span class="number">5</span>);</span><br><span class="line">possible.isPresent(); <span class="comment">// returns true</span></span><br><span class="line">possible.get(); <span class="comment">// returns 5</span></span><br></pre></td></tr></table></figure><h3><span id="静态创建方法">静态创建方法</span></h3><ul><li>  of</li><li>  ofNullable</li><li>empty<h3><span id="实例方法">实例方法</span></h3></li><li>  isPresent</li><li>  get</li><li>  or (jdk中是orElse)</li><li>  orNull</li><li>  asSet</li></ul><blockquote><p>意义：<br>    使用Optional除了赋予null语义，增加了可读性，最大的优点在于它是一种傻瓜式的防护。Optional迫使你积极思考引用缺失的情况，因为你必须显式地从Optional获取引用。直接使用null很容易让人忘掉某些情形，尽管FindBugs可以帮助查找null相关的问题，但是我们还是认为它并不能准确地定位问题根源。<br>    如同输入参数，方法的返回值也可能是null。和其他人一样，你绝对很可能会忘记别人写的方法method(a,b)会返回一个null，就好像当你实现method(a,b)时，也很可能忘记输入参数a可以为null。将方法的返回类型指定为Optional，也可以迫使调用者思考返回的引用缺失的情形。</p></blockquote><h3><span id="使用方式">使用方式：</span></h3><ul><li>错误的使用方式：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;User&gt; user = Optional.ofNullable(user);</span><br><span class="line"><span class="keyword">if</span> (user.isPresent()) &#123;</span><br><span class="line">  <span class="keyword">int</span> sex = user.getSex();</span><br><span class="line">  <span class="comment">// 链式调用，最容易出现空指针</span></span><br><span class="line">  <span class="keyword">int</span> age = user.getParent().getParent().getParent().getAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>正确的使用方式  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;User&gt; user = Optional.ofNullable(user);</span><br><span class="line"><span class="keyword">int</span> sex = user.map(User::getSex).orElse(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> age = user.map(User::getParent).map(User::getParent).map(User::getParent).map(User::getAge).orElse(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ul><h2><span id="其他处理null的便利方法">其他处理null的便利方法</span></h2><ul><li>  Objects.firstNonNull(T, T)</li><li>  Objects还有其它一些方法专门处理null或空字符串：emptyToNull(String)，nullToEmpty(String)，isNullOrEmpty(String)。</li></ul><h1><span id="12-前置条件-preconditions">1.2-前置条件 Preconditions</span></h1><table><thead><tr><th>–</th><th>–</th><th>–</th></tr></thead><tbody><tr><td>方法声明（不包括额外参数）</td><td>描述</td><td>检查失败时抛出的异常</td></tr><tr><td>checkArgument(boolean)</td><td>检查boolean是否为true，用来检查传递给方法的参数。</td><td>IllegalArgumentException</td></tr><tr><td>checkNotNull(T)</td><td>检查value是否为null，该方法直接返回value，因此可以内嵌使用checkNotNull。</td><td>NullPointerException</td></tr><tr><td>checkState(boolean)</td><td>用来检查对象的某些状态。</td><td>IllegalStateException</td></tr><tr><td>checkElementIndex(int index, int size)</td><td>检查index作为索引值对某个列表、字符串或数组是否有效</td><td>IndexOutOfBoundsException</td></tr><tr><td>checkPositionIndex(int index, int size)</td><td>检查index作为位置值对某个列表、字符串或数组是否有效。</td><td>IndexOutOfBoundsException</td></tr><tr><td>checkPositionIndexes(int start, int end, int size)</td><td>检查[start, end]表示的位置范围对某个列表、字符串或数组是否有效*</td><td>IndexOutOfBoundsException</td></tr></tbody></table><p><a href="http://ifeve.com/google-guava-using-and-avoiding-null/">参考</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK1.5-JDK1.8各个新特性</title>
      <link href="/posts/JDK1-5-JDK1-8%E5%90%84%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/posts/JDK1-5-JDK1-8%E5%90%84%E4%B8%AA%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://juejin.im/entry/5ab860ce5188255587238a36?utm_source=gold_browser_extension">转载来源</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java内存模型</title>
      <link href="/posts/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/posts/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://ifeve.com/jmm-faq/">参考</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深爱不寿</title>
      <link href="/posts/%E6%B7%B1%E7%88%B1%E4%B8%8D%E5%AF%BF/"/>
      <url>/posts/%E6%B7%B1%E7%88%B1%E4%B8%8D%E5%AF%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>如果我孑身一人是个赛车手<br>无牵无挂，无畏无惧<br>即使受伤、死亡<br>也会为我爱的事倾尽所有</p><p>如果我生在乱世是个将军<br>交出我爱的人换取一时和平<br>不要和我讲大义<br>提枪上马，马革裹尸不休</p>]]></content>
      
      
      
        <tags>
            
            <tag> 散文诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爱吃西瓜</title>
      <link href="/posts/%E7%88%B1%E5%90%83%E8%A5%BF%E7%93%9C/"/>
      <url>/posts/%E7%88%B1%E5%90%83%E8%A5%BF%E7%93%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最甜的是西瓜中间的那口</p><p>可我连籽都吃掉</p><p>我爱的东西本来就不多</p><p>爱就爱它的所有</p>]]></content>
      
      
      
        <tags>
            
            <tag> 散文诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker简单结合elk、logstash</title>
      <link href="/posts/docker%E7%AE%80%E5%8D%95%E7%BB%93%E5%90%88elk%E3%80%81logstash/"/>
      <url>/posts/docker%E7%AE%80%E5%8D%95%E7%BB%93%E5%90%88elk%E3%80%81logstash/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="本文记录docker搭建elk并简单结合logstash日志输出">本文记录docker搭建elk，并简单结合logstash日志输出</span></h2><h3><span id="filebeat">filebeat</span></h3><blockquote><p>docker pull docker.elastic.co/beats/filebeat:6.2.1</p></blockquote><ul><li>filebeat.yml</li></ul><p><strong>enabled要改为true，filebeat默认为false</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filebeat.prospectors:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:</span><br><span class="line">    - D:\workspace\baidu\baiyi\baidu\dsp\dsp-main-server\log\*.log</span><br><span class="line">output:</span><br><span class="line">    logstash:</span><br><span class="line">          hosts: [&quot;192.168.99.100:5044&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>docker run -it –name filebeat -v /data/filebeat.yml::/usr/share/filebeat/filebeat.yml</p></blockquote><h3><span id="logstash">logstash</span></h3><p>改写/opt/logstash/logstash/config/logstash.yml文件</p><ul><li>logstash.yml</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">    beats &#123;</span><br><span class="line">        port =&gt; 5044</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line">    stdout&#123; codec =&gt; rubydebug &#125;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; &quot;192.168.99.100:9200&quot;</span><br><span class="line">        index =&gt;  &quot;t-server-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">        document_type =&gt; &quot;log4j_type&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> logstash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker简单部署elk服务</title>
      <link href="/posts/docker%E7%AE%80%E5%8D%95%E9%83%A8%E7%BD%B2elk%E6%9C%8D%E5%8A%A1/"/>
      <url>/posts/docker%E7%AE%80%E5%8D%95%E9%83%A8%E7%BD%B2elk%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="本文章记录自己通过docker搭建elk的过程">本文章记录自己通过docker搭建elk的过程</span></h1><h2><span id="docker下载镜像">docker下载镜像</span></h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull sebp/elk :latest</span><br></pre></td></tr></table></figure><h2><span id="docker-至少分配3g内存">docker 至少分配3g内存</span></h2><p>elasticsearch 至少需要2g，logstash至少需要1g</p><h2><span id="设置最大运行线程数">设置最大运行线程数</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大线程数要超过262144</span><br></pre></td></tr></table></figure><ul><li><p>使用docker toolbox方式 先进入虚拟机</p><blockquote><p>docker-machine ssh default</p></blockquote></li><li><p>永久生效配置</p><blockquote><p>sudo vi /etc/sysctl.conf</p></blockquote><blockquote><p>vm.max_map_count=262144</p></blockquote><blockquote><p>sudo sysctl -p //生效</p></blockquote></li><li><p>临时生效配置</p><blockquote><p>sysctl -w vm.max_map_count=262144</p></blockquote></li></ul><h2><span id="启动">启动</span></h2><p>启动，并配置端口映射</p><blockquote><p>docker run -p 5601:5601 -p 9200:9200 -p 5044:5044 -it –name elk sebp/elk</p></blockquote><h2><span id="查看kibana">查看kibana</span></h2><p>打开网址 http:\192.168.99.100:5601 若打开成功说明部署成功</p><h2><span id="配置使用">配置使用</span></h2><ol><li>进入容器</li></ol><blockquote><p>docker exec -it elk /bin/bash</p></blockquote><ol start="2"><li>配置logstash</li></ol><blockquote><p>/opt/logstash/bin/logstash -e ‘input { stdin { } } output { elasticsearch { hosts =&gt; [“localhost”] } }’</p></blockquote><blockquote><p><strong>注意</strong>：如果看到这样的报错信息 Logstash could not be started because there is already another instance using the configured data directory. If you wish to run multiple instances, you must change the “path.data” setting. 请执行命令：service logstash stop 然后在执行就可以了。</p></blockquote><blockquote><p>当命令成功被执行后，看到：Successfully started Logstash API endpoint {:port=&gt;9600} 信息后，输入：test 然后回车，模拟一条日志进行测试。</p></blockquote><blockquote><ol><li>打开浏览器，输入：<a href="http://192.168.99.100:9200/_search?pretty">http://192.168.99.100:9200/_search?pretty</a> ，就会看到我们刚刚输入的日志内容</li><li>创建kibana与logstash关联</li><li>index name or pattern 输入 logstash-*</li><li>time-field name 输入 @timestamp</li><li>create</li><li>打开kibana首页即可看到刚刚输入的内容</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> elk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性</title>
      <link href="/posts/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/posts/java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="java8新特性">java8新特性</span></h1><h2><span id="lambda表达式">lambda表达式</span></h2><blockquote><p>java8接受一个函数作为另一个函数的参数传入进去</p></blockquote><p>Arrays.asList( “a”, “b”, “d” ).forEach( e -&gt; System.out.println( e ) ); 参数的类型是编译器推断出来的</p><blockquote><p>Lambda可以引用类的成员变量与局部变量（如果这些变量不是final的话，它们会被隐含的转为final，这样效率更高）。</p></blockquote><h2><span id="默认方法和静态方法">默认方法和静态方法</span></h2><blockquote><p>在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到java.util.Collection接口中去：stream()，parallelStream()，forEach()，removeIf()，……</p></blockquote><h2><span id="重复注解">重复注解</span></h2><h2><span id="java编译器的新特性">Java编译器的新特性</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterNames</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Method method = ParameterNames.class.getMethod( <span class="string">&quot;main&quot;</span>, String[].class );</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">final</span> Parameter parameter: method.getParameters() ) &#123;</span><br><span class="line">            System.out.println( <span class="string">&quot;Parameter: &quot;</span> + parameter.getName() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Parameter: args</p></blockquote><p>对于有经验的Maven用户，通过maven-compiler-plugin的配置可以将-parameters参数添加到编译器中去。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">compilerArgument</span>&gt;</span>-parameters<span class="tag">&lt;/<span class="name">compilerArgument</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h2><span id="java-类库的新特性">Java 类库的新特性</span></h2><h3><span id="optional">Optional</span></h3><p>平时用的判空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成Optional：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  Optional&lt;String &gt; names = Opntional.of(name);</span><br><span class="line">  <span class="keyword">if</span> (names.isPresent())&#123;</span><br><span class="line">      <span class="keyword">return</span> names.get();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果单纯改成这样，还不如直接写成 ==null，看起来更加繁琐。 应该改成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Opntional.of(name).get().orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="stream">Stream</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> totalPointsOfOpenTasks = tasks</span><br><span class="line">    .stream()</span><br><span class="line">    .filter( task -&gt; task.getStatus() == Status.OPEN )</span><br><span class="line">    .mapToInt( Task::getPoints )</span><br><span class="line">    .sum();</span><br></pre></td></tr></table></figure><h4><span id="filter">filter</span></h4><blockquote><p>对于Stream中包含的元素使用给定的过滤函数进行过滤操作，新生成的Stream只包含符合条件的元素；</p></blockquote><h4><span id="map">map</span></h4><blockquote><p>映射转换</p></blockquote><h4><span id="mapto">mapTo*</span></h4><blockquote><p>映射转换成 <em>的类型，</em> 包括Integer、Double、Long</p></blockquote><h4><span id="flatmap">flatMap</span></h4><blockquote><p>合并集合,和map类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中；</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;1,2&#125;，&#123;3,4&#125;，&#123;5,6&#125;&#125; - &gt; flatMap - &gt; &#123;1,2,3,4,5,6&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#x27;a&#x27;，&#x27;b&#x27;&#125;，&#123;&#x27;c&#x27;，&#x27;d&#x27;&#125;，&#123;&#x27;e&#x27;，&#x27;f&#x27;&#125;&#125; - &gt; flatMap - &gt; &#123;&#x27;a&#x27;，&#x27;b&#x27;，&#x27;c&#x27; D&quot;， &#x27;E&#x27;， &#x27;F&#x27;&#125;</span><br></pre></td></tr></table></figure><h4><span id="flatmapto">flatMapTo*</span></h4><h4><span id="distinct">distinct</span></h4><blockquote><p>对于Stream中包含的元素进行去重操作（去重逻辑依赖元素的equals方法），新生成的Stream中没有重复的元素；</p></blockquote><blockquote><h4><span id="sorted">sorted</span></h4></blockquote><h4><span id="peek">peek</span></h4><blockquote><p>监控器</p></blockquote><p>提供一个Consumer消费函数，返回一个新的Stream，如果只写 Stream.of(“1”,”2”,”3”).peek(e-&gt; System.out.Println(e)) 是不会打印结果的 新Stream每个元素被<strong>消费</strong>的时候都会执行给定的消费函数； Stream.of(“1”,”2”,”3”).peek(e-&gt; System.out.Println(e)).collect(Collectors.toList());</p><h4><span id="limit">limit</span></h4><p>对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素；</p><h4><span id="skip">skip</span></h4><p>返回一个丢弃原Stream的前N个元素后剩下元素组成的新Stream，如果原Stream中包含的元素个数小于N，那么返回空Stream；</p><h4><span id="foreach">forEach</span></h4><blockquote><p>遍历</p></blockquote><h4><span id="foreachordered">forEachOrdered</span></h4><blockquote><p>与forEach一样，只不过每次遍历结果都是相同的，forEach不是固定的序列</p></blockquote><h4><span id="generate">generate</span></h4><p>给定一个生成函数，生成一个无限的队列 Stream.generate(Math::random);</p><h4><span id="iterate">iterate</span></h4><p>也是生成无限长度的Stream，和generator不同的是，其元素的生成是重复对给定的种子值(seed)调用用户指定函数来生成的。其中包含的元素可以认为是：seed，f(seed),f(f(seed))无限循环</p><p>Stream.iterate(1, item -&gt; item + 1).limit(10).forEach(System.out::println);</p><h4><span id="collect">collect</span></h4><blockquote><p>汇聚函数</p></blockquote><table><thead><tr><th>方法参数</th><th>返回类型</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>toList</td><td>List<code>&lt;T &gt;</code></td><td>把流中的参数汇聚成List集合</td><td>示例:List<code>&lt;Menu&gt;</code> menus=Menu.getMenus.stream().collect(Collectors.toList())</td></tr><tr><td>toSet</td><td>Set<code>&lt;T&gt;</code></td><td>把流中所有元素收集到Set中,删除重复项</td><td>Set<code>&lt;Menu&gt;</code> menus=Menu.getMenus.stream().collect(Collectors.toSet())</td></tr><tr><td>toCollection</td><td>Collection<code>&lt;T&gt;</code></td><td>把流中所有元素收集到给定的供应源创建的集合中</td><td><code>ArrayList&lt;Menu&gt; menus=Menu.getMenus.stream().collect(Collectors.toCollection(ArrayList::new))</code></td></tr><tr><td>Counting</td><td>Long</td><td>计算流中元素个数</td><td>Long count=Menu.getMenus.stream().collect(Collectors.counting());</td></tr><tr><td>SummingInt</td><td>Integer</td><td>对流中元素的一个整数属性求和</td><td>Integer count=Menu.getMenus.stream().collect(Collectors.summingInt(Menu::getCalories))</td></tr><tr><td>averagingInt</td><td>Double</td><td>计算流中元素integer属性的平均值</td><td>Double averaging=Menu.getMenus.stream().collect((Collectors.averagingInt(Menu::getCalories))</td></tr><tr><td>Joining</td><td>String</td><td>连接流中每个元素的toString方法生成的字符串</td><td>String name=Menu.getMenus.stream().map(Menu::getName).collect(Collectors.joining(“, “))</td></tr><tr><td>maxBy</td><td>Optional<code>&lt;T&gt;</code></td><td>一个包裹了流中按照给定比较器选出的最大元素的optional 如果为空返回的是Optional.empty()</td><td>Optional<code>&lt;Menu&gt;</code> fattest=Menu.getMenus.stream().collectCollectors.maxBy(Menu::getCalories))</td></tr><tr><td>minBy</td><td>Optional<code>&lt;T&gt;</code></td><td>一个包裹了流中按照给定比较器选出的最大元素的optional如果为空返回的是Optional.empty()</td><td>Optional<code>&lt;Menu&gt;</code> lessest=Menu.getMenus.stream().collect(minBy(Menu::getCalories))</td></tr><tr><td>Reducing</td><td>归约操作产生的类型</td><td>从一个作为累加器的初始值开始,利用binaryOperator与流中的元素逐个结合,从而将流归约为单个值</td><td>int count=Menu.getMenus.stream().collect(reducing(0,Menu::getCalories,Integer::sum));</td></tr><tr><td>collectingAndThen</td><td>转换函数返回的类型</td><td>包裹另一个转换器,对其结果应用转换函数</td><td>Int count=Menu.getMenus.stream().collect(collectingAndThen(toList(),List::size))</td></tr><tr><td>groupingBy</td><td>Map<code>&lt;K,List&lt;T&gt;&gt;</code></td><td>根据流中元素的某个值对流中的元素进行分组,并将属性值做为结果map的键</td><td>Map<code>&lt;Type,List&lt;Menu&gt;&gt;</code> menuType=Menu.getMenus.stream().collect(groupingby(Menu::getType))</td></tr><tr><td>partitioningBy</td><td>Map<code>&lt;Boolean,List&lt;T&gt;&gt;</code></td><td>根据流中每个元素应用谓语的结果来对项目进行分区</td><td>Map<code>&lt;Boolean,List&lt;Menu&gt;&gt;</code> menuType=Menu.getMenus.stream().collect(partitioningBy(Menu::isType));</td></tr></tbody></table><h4><span id="reduce">reduce</span></h4><ul><li><code>Optional&lt;t&gt; reduce(BinaryOperator&lt;t&gt; accumulator);</code></li></ul><p>List <code>&lt;integer&gt;</code> ints = Lists.newArrayList(1,2,3,4,5,6,7,8,9,10); System.out.println(“ints sum is:” + ints.stream().reduce((sum, item) -&gt; sum + item).get());</p><p>可以看到reduce方法接受一个函数，这个函数有两个参数，第一个参数是上次函数执行的返回值（也称为中间结果），第二个参数是stream中的元素，这个函数把这两个值相加，得到的和会被赋值给下次执行这个函数的第一个参数。要注意的是：<strong>第一次执行的时候第一个参数的值是Stream的第一个元素，第二个参数是Stream的第二个元素</strong>。这个方法返回值类型是Optional，这是Java8防止出现NPE的一种可行方法，后面的文章会详细介绍，这里就简单的认为是一个容器，其中可能会包含0个或者1个对象。</p><ul><li>T reduce(T identity, BinaryOperator<code>&lt;t&gt;</code> accumulator);<br>这个定义上上面已经介绍过的基本一致，不同的是：它允许用户提供一个循环计算的初始值，如果Stream为空，就直接返回该值。而且这个方法不会返回Optional，因为其不会出现null值。</li></ul><h4><span id="count">count</span></h4><blockquote><p>个数</p></blockquote><h4><span id="allmatch">allMatch</span></h4><p>是不是所有都满足给定的条件</p><h4><span id="anymatch">anyMatch</span></h4><p>是不是存在某一个元素满足给定的条件</p><h4><span id="findfirst">findFirst</span></h4><p>返回第一个，返回的是Optional值</p><h4><span id="nonematch">noneMatch</span></h4><p>是否没有一个元素满足给定的条件</p><h4><span id="max和min">max和min</span></h4><p>给定的比较条件，返回最大最小值</p><p><a href="http://ifeve.com/stream/">参考</a><br><a href="https://blog.csdn.net/dm_vincent/article/category/2268127">好文收藏</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud配置问题</title>
      <link href="/posts/springcloud%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
      <url>/posts/springcloud%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li>注册中心不自动上线下线</li><li>异步返回值</li><li>bean参数传值</li><li></li></ul><h3><span id="eureka-不自动下线">eureka 不自动下线</span></h3><p>Eureka Server在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%，如果出现低于的情况（在单机调试的时候很容易满足，实际在生产环境上通常是由于网络不稳定导致），Eureka Server会将当前的实例注册信息保护起来，同时提示这个警告。保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。</p><p>详见：<a href="https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication">https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication</a></p><p>解决方法：设置enableSelfPreservation:false</p><p>配置心跳检测时长，下线leaseRenewalIntervalInSeconds: 2</p><h3><span id="负载均衡在服务下掉后的重试策略"></span></h3><p>默认没有开启：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.loadbalancer.retry.enabled=<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">hystrix.command.<span class="keyword">default</span>.execution.isolation.thread.timeoutInMilliseconds=<span class="number">10000</span></span><br><span class="line"></span><br><span class="line">hello-service.ribbon.ConnectTimeout=<span class="number">250</span></span><br><span class="line">hello-service.ribbon.ReadTimeout=<span class="number">1000</span></span><br><span class="line">hello-service.ribbon.OkToRetryOnAllOperations=<span class="keyword">true</span></span><br><span class="line">hello-service.ribbon.MaxAutoRetriesNextServer=<span class="number">2</span></span><br><span class="line">hello-service.ribbon.MaxAutoRetries=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="断路器配置重试"></span></h3><p>如何处理服务挂掉后或者手动关闭服务后，Ribbon负载均衡还是一直调用这个服务，然后调用@HystrixCommand断路器注解的方法：利用Hystrix，在error callback方法中可以shutdown指定的server</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZoneAwareLoadBalancer&lt;Server&gt; lb = (ZoneAwareLoadBalancer&lt;Server&gt;) springClientFactory.getLoadBalancer(<span class="string">&quot;CLOUD-SERVICE&quot;</span>);</span><br><span class="line">Server server = lb.chooseServer();</span><br><span class="line">System.out.println(<span class="string">&quot;error-&gt;&quot;</span> + server.getHostPort());</span><br><span class="line">lb.markServerDown(server);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud集群同步、自我保护模式以及实例注册、心跳、下线配置</title>
      <link href="/posts/SpringCloud%E9%9B%86%E7%BE%A4%E5%90%8C%E6%AD%A5%E3%80%81%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E4%BE%8B%E6%B3%A8%E5%86%8C%E3%80%81%E5%BF%83%E8%B7%B3%E3%80%81%E4%B8%8B%E7%BA%BF%E9%85%8D%E7%BD%AE/"/>
      <url>/posts/SpringCloud%E9%9B%86%E7%BE%A4%E5%90%8C%E6%AD%A5%E3%80%81%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%9E%E4%BE%8B%E6%B3%A8%E5%86%8C%E3%80%81%E5%BF%83%E8%B7%B3%E3%80%81%E4%B8%8B%E7%BA%BF%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="1-概述">1. 概述</span></h1><p>本文在上文 Spring cloud系列四 Eureka 之概述和服务注册中心集群的基础上，继续介绍Eureka新的内容:</p><pre><code>集群重要类：PeerAwareInstanceRegistryImpl新的Eureka Server节点加入集群后的影响新服务注册(Register)注册时的影响服务心跳(renew)服务下线和剔除自我保护模式</code></pre><h1><span id="2-eureka-server的集群同步操作">2. Eureka Server的集群同步操作</span></h1><h2><span id="21-eureka官网的架构图">2.1. Eureka官网的架构图</span></h2><p>下方的操作需要结合下图理解：<br>这里写图片描述<br>##2.2. PeerAwareInstanceRegistryImpl</p><p>集群相关重要的类com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl: 为了保证集群里所有Eureka Server节点的状态同步，所有以下操作都会同步到集群的所有服务上：服务注册（Registers）、服务更新（Renewals）、服务取消（Cancels）,服务超时（Expirations）和服务状态变更（Status Changes）。以下是一些部分方法：</p><pre><code>syncUp：在Eureka Server重启或新的Eureka Server节点加进来的，会执行初始化，从集群其他节点中获取所有的实例注册信息，从而能够正常提供服务。当Eureka Server启动时，它会从其它节点获取所有的注册信息，如果获取同步失败，它在一定时间（此值由决定）内拒绝服务。replicateToPeers： 同步以下操作到所有的集群节点：服务注册（Registers）、服务更新（Renewals）、服务取消（Cancels）,服务超时（Expirations）和服务状态变更（Status Changes）register: 注册实例，并且复印此实例的信息到所有的eureka server的节点。如果其它Eureka Server调用此节点，只在本节点更新实例信息，避免通知其他节点执行更新renew：心跳，同步集群cancel其他</code></pre><p>Eureka Server集群之间的状态是采用异步方式同步的，所以不保证节点间的状态一定是一致的，不过基本能保证最终状态是一致的。</p><h2><span id="23-新的eureka-server节点加入集群后的影响">2.3. 新的Eureka Server节点加入集群后的影响</span></h2><p>当有新的节点加入到集群中，会对现在Eureka Server和Eureka Client有什么影响以及他们如何发现新增的Eureka Server节点：</p><pre><code>新增的Eureka Server：在Eureka Server重启或新的Eureka Server节点加进来的，它会从集群里其它节点获取所有的实例注册信息。如果获取同步失败，它会在一定时间（此值由决定eureka.server.peer-eureka-nodes-update-interval-ms决定）内拒绝服务。已有Eureka Server和Service Consumer如何发现新的Eureka Server    已有的Eureka Server：在运行过程中，Eureka Server之间会定时同步实例的注册信息。这样即使新的Application Service只向集群中一台注册服务，则经过一段时间会集群中所有的Eureka Server都会有这个实例的信息。那么Eureka Server节点之间如何相互发现，各个节点之间定时（时间由eureka.server.peer-eureka-nodes-update-interval-ms决定）更新节点信息，进行相互发现。    Service Consumer：Service Consumer刚启动时，它会从配置文件读取Eureka Server的地址信息。当集群中新增一个Eureka Server中时，那么Service Provider如何发现这个Eureka Server？Service Consumer会定时（此值由eureka.client.eureka-service-url-poll-interval-seconds决定）调用Eureka Server集群接口，获取所有的Eureka Server信息的并更新本地配置。</code></pre><h2><span id="24-新服务注册register注册时的影响">2.4. 新服务注册(Register)注册时的影响</span></h2><p>Service Provider要对外提供服务，把自己注册到Eureka Server上。如果配置参数eureka.client.registerWithEureka=true（默认值true）时，会向Eureka Server注册进行注册，Eureka Server会保存注册信息到内存中。</p><p>Service Consumer为了避免每次调用服务请求都需要向Eureka Server获取服务实例的注册信息，此时需要设置eureka.client.fetchRegistry=true，它会在本地缓存所有实例注册信息。为了保证缓存数据的有效性，它会定时（值由eureka.client.registry-fetch-interval-seconds定义，默认值为30s）向注册中心更新实例。</p><h2><span id="25-服务心跳renew">2.5. 服务心跳(renew)</span></h2><p>服务实例会通过心跳(eureka.instance.lease-renewal-interval-in-seconds定义心跳的频率，默认值为30s)续约的方式向Eureka Server定时更新自己的状态。Eureka Server收到心跳后，会通知集群里的其它Eureka Server更新此实例的状态。Service Provider/Service Consumer也会定时更新缓存的实例信息。</p><h2><span id="26-服务下线和剔除">2.6. 服务下线和剔除</span></h2><p>服务的下线有两种情况：</p><pre><code>在Service Provider服务shutdown的时候，主动通知Eureka Server把自己剔除，从而避免客户端调用已经下线的服务。Eureka Server会定时（间隔值是eureka.server.eviction-interval-timer-in-ms，默认值为0，默认情况不删除实例）进行检查，如果发现实例在在一定时间（此值由eureka.instance.lease-expiration-duration-in-seconds定义，默认值为90s）内没有收到心跳，则会注销此实例。</code></pre><p>这种情况下，Eureka Client的最多需要[eureka.instance.lease-renewal-interval-in-seconds + eureka.client.registry-fetch-interval-seconds]时间才发现服务已经下线。同理，一个新的服务上线后，Eureka Client的服务消费方最多需要相同的时间才发现服务已经上线</p><p>服务下线，同时会更新到Eureka Server其他节点和Eureka client的缓存，流程类似同以上的register过程</p><h2><span id="27-自我保护模式">2.7. 自我保护模式</span></h2><p>如果Eureka Server最近1分钟收到renew的次数小于阈值（即预期的最小值），则会触发自我保护模式，此时Eureka Server此时会认为这是网络问题，它不会注销任何过期的实例。等到最近收到renew的次数大于阈值后，则Eureka Server退出自我保护模式。</p><p>自我保护模式阈值计算：</p><pre><code>每个instance的预期心跳数目 = 60/每个instance的心跳间隔秒数阈值 = 所有注册到服务的instance的数量的预期心跳之和 *自我保护系数</code></pre><p>以上的参数都可配置的：</p><pre><code>instance的心跳间隔秒数：eureka.instance.lease-renewal-interval-in-seconds自我保护系数：eureka.server.renewal-percent-threshold</code></pre><p>如果我们的实例比较少且是内部网络时，推荐关掉此选项。我们也可以通过eureka.server.enable-self-preservation = false来禁用自我保护系数</p><h2><span id="28-配置demo">2.8 配置demo</span></h2><p>以下配置的demo如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10761</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-registration-center</span></span><br><span class="line"><span class="comment">## eureka ： 主要配置属性在EurekaInstanceConfigBean和EurekaClientConfigBean中</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment"># hostname: 127.0.0.1</span></span><br><span class="line">    <span class="comment"># 使用IP注册</span></span><br><span class="line">    <span class="attr">preferIpAddress:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 心跳间隔</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">3</span></span><br><span class="line">    <span class="comment"># 服务失效时间： 如果多久没有收到请求，则可以删除服务</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">7</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 关闭eureka client</span></span><br><span class="line">    <span class="comment"># enabled: false</span></span><br><span class="line">    <span class="comment"># 注册自身到eureka服务器</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 表示是否从eureka服务器获取注册信息</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 客户端从Eureka Server集群里更新Eureka Server信息的频率</span></span><br><span class="line">    <span class="attr">eureka-service-url-poll-interval-seconds:</span> <span class="number">60</span></span><br><span class="line">    <span class="comment"># 定义从注册中心获取注册服务的信息</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment"># 设置eureka服务器所在的地址，查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10761/eureka/</span></span><br><span class="line">       <span class="comment"># 设置eureka服务器所在的地址，可以同时向多个服务注册服务</span></span><br><span class="line">       <span class="comment"># defaultZone: http://192.168.21.3:10761/eureka/,http://192.168.21.4:10761/eureka/</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">     <span class="comment"># renewal-percent-threshold: 0.1</span></span><br><span class="line">     <span class="comment"># 关闭自我保护模式</span></span><br><span class="line">     <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line">     <span class="comment"># Eureka Server 自我保护系数，当enable-self-preservation=true时，启作用</span></span><br><span class="line">     <span class="comment"># renewal-percent-threshold:</span></span><br><span class="line">     <span class="comment"># 设置清理间隔,单位为毫秒,默认为0</span></span><br><span class="line">     <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">3000</span></span><br><span class="line">     <span class="comment"># 设置如果Eureka Server启动时无法从临近Eureka Server节点获取注册信息，它多久不对外提供注册服务</span></span><br><span class="line">     <span class="attr">wait-time-in-ms-when-sync-empty:</span> <span class="number">6000000</span></span><br><span class="line">     <span class="comment"># 集群之间相互更新节点信息的时间频率</span></span><br><span class="line">     <span class="attr">peer-eureka-nodes-update-interval-ms:</span> <span class="number">60000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="/posts/%E7%B4%A2%E5%BC%95/"/>
      <url>/posts/%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="索引介绍">索引介绍</span></h2><blockquote><p>索引对查询的速度有至关重要的影响。考虑如下情况，假设数据库中一个表有10^6^条记录，DBMS的页面大小为4K，并存储100条记录。如果没有索引，查询将对整个表进行扫描，最坏的情况下，如果所有数据页都不在内存，需要读取10^4^个页面，如果这10^4^个页面在磁盘上随机分布，需要进行10^4^次I/O，假设磁盘每次I/O时间为10ms(忽略数据传输时间)，则总共需要100s(但实际上要好很多很多)。如果对之建立B-Tree索引，则只需要进行log100(10^6^)=3次页面读取，最坏情况下耗时30ms。这就是索引带来的效果，很多时候，当你的应用程序进行SQL查询速度很慢时，应该想想是否可以建索引</p></blockquote><h2><span id="索引与优化">索引与优化</span></h2><h3><span id="索引的数据类型">索引的数据类型</span></h3><pre><code>选择索引类型原则：</code></pre><ol><li>数据整形： 越小的整形在磁盘、内存、和CPU之间都需要更少的空间，处理起来更快。    2. 简单的数据类型更好： 整形数据比起字符型，处理开销更小，因为字符串的比较更复杂，在Mysql中，应该用内置的日期和时间数据类型，而不是字符串来存储时间，以及用整形数据类型存储ip地址。    3. 尽量避免NULL： 应该指定列为NOT NULL ，除非想存储NULL。在mysql中，含有空值的列很难进行查询优化，以为他使得索引、索引的统计信息以及比较运算符更加复杂。应该用0、一个特殊值、或者一个空串代替空值。</li></ol><h4><span id="选择标识符">选择标识符</span></h4><p>  选择合适的标识符是非常重要的，选择是不仅应该考虑存储类型，而且应该考虑mysql是怎么进行运算和比较的，一旦选定数据类型，应该保证所有的表都使用相同的数据类型。<br>    1. 整形： 通常是作为标识符最好的选择，因为更苦阿爹处理，因为可以更快的处理，而且可以设置为AUTO_INCREMENT。<br>    2. 字符串：尽量避免使用字符串作为标识符，它们消耗更好的空间，处理起来也较慢。而且，通常来说，字符串都是随机的，所以它们在索引中的位置也是随机的，这会导致页面分裂、随机访问磁盘，聚簇索引分裂（对于使用聚簇索引的存储引擎）。</p><h3><span id="索引入门">索引入门</span></h3><pre><code>对于任何DBMS，索引都是进行优化的最主要的因素。对于少量的数据，没有合适的索引影响不是很大，但是，当随着数据量的增加，性能会急剧下降。如果对多列进行索引(组合索引)，**列的顺序**非常重要，MySQL仅能对索引最左边的前缀进行有效的查找。例如：</code></pre><p>假设存在组合索引 表t1 建立 c1c2(c1,c2)联合索引，查询语句select * from t1 where c1=1 and c2=2能够使用该索引。查询语句select * from t1 where c1=1也能够使用该索引。但是，查询语句select * from t1 where c2=2不能够使用该索引，因为没有组合索引的引导列，即，要想使用c2列进行查找，必需出现c1等于某值。</p><h4><span id="索引的类型">索引的类型</span></h4><p>索引是在存储引擎中实现的，而不是在服务器层中实现的。所以，每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型。</p><h5><span id="b-tree索引">B-Tree索引</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE People (</span><br><span class="line"></span><br><span class="line"> last_name varchar(50)    not null,</span><br><span class="line"></span><br><span class="line"> first_name varchar(50)    not null,</span><br><span class="line"></span><br><span class="line"> dob        date           not null,</span><br><span class="line"></span><br><span class="line"> gender     enum(&#x27;m&#x27;, &#x27;f&#x27;) not null,</span><br><span class="line"></span><br><span class="line"> key(last_name, first_name, dob)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其索引包含表中每一行的last_name、first_name和dob列。其结构大致如下：<br><img src="img/mysql%E7%B4%A2%E5%BC%95%E5%85%B3%E7%B3%BB.jpg"><br>索引存储的值按索引列中的顺序排列。可以利用B-Tree索引进行全关键字、关键字范围和关键字前缀查询，当然，如果想使用索引，你必须保证按索引的最左边前缀(leftmost prefix of the index)来进行查询。</p><ol><li>匹配全值(Match the full value)：对索引中的所有列都指定具体的值。例如，上图中索引可以帮助你查找出生于1960-01-01的Cuba Allen。</li><li>匹配最左前缀(Match a leftmost prefix)：你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。</li><li>匹配列前缀(Match a column prefix)：例如，你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。</li><li>匹配值的范围查询(Match a range of values)：可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。</li><li>匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：可以利用索引查找last name为Allen，而first name以字母K开始的人。</li><li>仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要读取元组的值。</li></ol><p>由于B-树中的节点都是<strong>顺序存储</strong>的，所以可以利用索引进行查找(找某些值)，也可以对查询结果进行ORDER BY。当然，使用B-tree索引有以下一些限制：</p><ol><li>查询必须从索引的最左边的列开始。关于这点已经提了很多遍了。例如你不能利用索引查找在某一天出生的人。</li><li>不能跳过某一索引列。例如，你不能利用索引查找last name为Smith且出生于某一天的人。</li><li>存储引擎不能使用索引中范围条件右边的列。例如，如果你的查询语句为WHERE last_name=”Smith” AND first_name LIKE ‘J%’ AND dob=’1976-12-23’，则该查询只会使用索引中的前两列，因为LIKE是范围查询。<h5><span id="hash索引">Hash索引</span></h5><blockquote><p>MySQL中，只有Memory存储引擎显示支持hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B-Tree索引。Memory存储引擎支持非唯一hash索引，这在数据库领域是罕见的，如果多个值有相同的hash code，索引把它们的行指针用链表保存到同一个hash表项中。</p></blockquote></li></ol><p>  假设创建如下一个表：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE testhash (</span><br><span class="line">   fname VARCHAR(50) NOT NULL,</span><br><span class="line">   lname VARCHAR(50) NOT NULL,</span><br><span class="line">   KEY USING HASH(fname)</span><br><span class="line">) ENGINE=MEMORY;</span><br></pre></td></tr></table></figure><br>  假设索引使用hash函数f( )，如下：</p><blockquote><p>  f(‘Arjen’) = 2323<br>    f(‘Baron’) = 7437<br>  f(‘Peter’) = 8784<br>  f(‘Vadim’) = 2458<br>此时，索引的结构大概如下：<br><img src="img/mysqlHash%E7%B4%A2%E5%BC%95%E5%9B%BE.jpg"></p></blockquote><p>Slots是有序的，但是记录不是有序的。当你执行<br>mysql&gt; SELECT lname FROM testhash WHERE fname=’Peter’;<br>MySQL会计算’Peter’的hash值，然后通过它来查询索引的行指针。因为f(‘Peter’) = 8784，MySQL会在索引中查找8784，得到指向记录3的指针。<br>因为索引自己仅仅存储很短的值，所以，索引非常紧凑。Hash值不取决于列的数据类型，一个TINYINT列的索引与一个长字符串列的索引一样大。<br>Hash索引有以下一些<strong>限制</strong>：</p><ol><li>由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录。但是访问内存中的记录是非常迅速的，不会对性造成太大的影响。</li><li>不能使用hash索引排序。</li><li>Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。</li><li>Hash索引只支持等值比较，例如使用=，IN( )和&lt;=&gt;。对于WHERE price&gt;100并不能加速查询。</li></ol><h5><span id="空间r-tree索引">空间(R-Tree)索引</span></h5><pre><code>MyISAM支持空间索引，主要用于地理空间数据类型，例如GEOMETRY。</code></pre><h5><span id="全文full-text索引">全文(Full-text)索引</span></h5><pre><code>全文索引是MyISAM的一个特殊索引类型，主要用于全文检索。</code></pre><h2><span id="高性能的索引策略">高性能的索引策略</span></h2><h3><span id="聚簇索引clustered-indexes">聚簇索引(Clustered Indexes)</span></h3><blockquote><p>mysql聚簇索引保证关键字的值相近的元组存储的物理位置也相同（所以字符串类型不宜建立聚簇索引，特别是随机字符串，会使得系统进行大量的移动操作），且一个表只能有一个聚簇索引。因为由存储引擎实现索引，所以，并不是所有的引擎都支持聚簇索引。目前，只有solidDB和InnoDB支持。<br> 结构如下：<br> <img src="img/mysql%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg"><br>注：叶子页面包含完整的元组，而内节点页面仅包含索引的列(索引的列为整型)。一些DBMS允许用户指定聚簇索引，但是MySQL的存储引擎到目前为止都不支持。InnoDB对主键建立聚簇索引。如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。一般来说，DBMS都会以聚簇索引的形式来存储实际的数据，它是其它二级索引的基础。</p></blockquote><h4><span id="innodb和myisam的数据布局的比较">InnoDB和MyISAM的数据布局的比较</span></h4><blockquote><p>为了更加理解聚簇索引和非聚簇索引，或者primary索引和second索引(MyISAM不支持聚簇索引)，来比较一下InnoDB和MyISAM的数据布局，对于如下表：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE layout_test (</span><br><span class="line"></span><br><span class="line">col1 int NOT NULL,</span><br><span class="line"></span><br><span class="line">col2 int NOT NULL,</span><br><span class="line"></span><br><span class="line">PRIMARY KEY(col1),</span><br><span class="line"></span><br><span class="line">KEY(col2)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>假设主键的值位于1—10,000之间，且按随机顺序插入，然后用OPTIMIZE TABLE进行优化。col2随机赋予1—100之间的值，所以会存在许多重复的值。</p><ol><li>MyISAM的数据布局<br>其布局十分简单，MyISAM按照插入的顺序在磁盘上存储数据，如下：<br><img src="img/mysqlMyisam%E7%B4%A2%E5%BC%95.jpg"></li></ol><p><a href="http://www.cnblogs.com/hustcat/archive/2009/10/28/1591648.html">参考</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程间通信</title>
      <link href="/posts/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/posts/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://mp.weixin.qq.com/s/Nij2KMBmDn5E5nFhpwn24w">参考如下</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EffectiveJava读书笔记</title>
      <link href="/posts/EffectiveJava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/posts/EffectiveJava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>#EffectiveJava 读书笔记</p><p>本文于2017年10月26日再读一遍，对书中的内容进行整理提取，方便以后查阅</p><p>[TOC]</p><h2><span id="第一章创建和销毁对象">第一章：创建和销毁对象</span></h2><h3><span id="创建对象的方法">创建对象的方法</span></h3><ul><li>构造器方法new一个；</li><li>公共静态方法返回实例；</li><li>Build工程模式。<blockquote><p>一般来说创建对象最简单的方法就是使用的时候new一个，如Person  person = new Person();既通过构造器创建对象。这种使用方法不适用于所有情况，例如一个单例工具类，不需要每次使用都new，而是通过一个公共静态方法返回类的实例。</p></blockquote></li></ul><h4><span id="构造器方式">构造器方式</span></h4><p>  <em>缺点</em></p><blockquote><p>每一个构造器都与类名相同，无法知其寓意。</p></blockquote><p>  构造器方法时最常用的方法；</p><h4><span id="公共静态方法">公共静态方法</span></h4><p>  <em>优点1</em></p><blockquote><p>每一个公共静态方法都有名字，顾名思义。</p></blockquote><p>  <em>优点2</em></p><blockquote><p>不必为每次调用都产生一个新的实例，可以重复利用。</p></blockquote><p>  <em>优点3</em></p><blockquote><p>可以返回原返回类型的任何子类型对象。</p></blockquote><p>  <em>优点3</em></p><blockquote><p>创建参数化类型实例，使代码变得更简洁。</p></blockquote><p>  <em>缺点1</em></p><blockquote><p>类如果不含有共有的或者受保护的构造器，就不能被子类化。</p></blockquote><p>  <em>缺点2</em></p><blockquote><p>与其他静态方法没有任何区别。</p></blockquote><h4><span id="使用情景1-通过方法名知其方法作用">使用情景1 通过方法名知其方法作用</span></h4><p>  如BigInteger(int,int,Random)返回的BitInteger可能为素数，但如果用BigInteger.probablePrime静态方法来表示，更加清楚方法寓意。</p><p>  如果两个构造器方法中只是参数类型顺序上不同，很容易造成寓意混乱，需要进一步查询文档才能确定用哪一个，容错率很低。</p><h4><span id="使用场景2-使用预先定义好的实例">使用场景2 使用预先定义好的实例。</span></h4><p>  公共静态方法返回的实例可以控制是否是单例,或者控制是否可以实例化。</p><ul><li>getInstance和newInstance区别：<blockquote><p>getInstance方法重点是返回已经创建好的实例。<br>newInstance方法重点是返回一个新的实例。</p></blockquote></li></ul><h4><span id="使用场景3-collections的32个便利实现-通过适配器提供更丰富的服务接口">使用场景3 Collections的32个便利实现、通过适配器提供更丰富的服务接口</span></h4><p>  分别提供了不可修改的集合、同步集合等。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Service interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Service provider interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span></span>&#123;</span><br><span class="line">  <span class="function">Service <span class="title">newService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Services</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Services</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,Provider&gt; providers = <span class="keyword">new</span> ConcurrentHashMap&lt;String,Provider&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PROVIDER_NAME = <span class="string">&quot;&lt;def&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerDefaultProvider</span><span class="params">(Provider p)</span></span>&#123;</span><br><span class="line">    registerProvider(DEFAULT_PROVIDER_NAME,p););</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerProvider</span><span class="params">(String name,Provider p)</span></span>&#123;</span><br><span class="line">    providers.put(name,p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Service <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newInstance(DEFAULT_PROVIDER_NAME);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Service <span class="title">newInstance</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    Provider p = provider.get(name);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No provider registered with name:&quot;</span>+ name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p.newService();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="使用场景4-代替繁琐的参数声明">使用场景4  代替繁琐的参数声明。</span></h4><h4><span id="使用场景6">使用场景6</span></h4><p>  valueOf – 返回的实例与参数具有相同的值，实际上是类型转换方法。<br>  of  – valueOf的简洁替代。<br>  getInstance  – 返回的实例是通过方法的参数来描述的，但是不能说与参数有相同的值。对于Singleton来说，该方法没有参数。<br>  newInstance  – 跟getInstance一样，但是该方法确保返回的实例与其他实例不同。<br>  getType  – 跟getInstance一样，但是在工厂方法中处于不同的类中的时候使用，Type表示工厂方法锁返回的对象类型。<br>  newType  – 像newInstance一样，但是在工厂方法中处于不同的类中的时候使用。</p><h3><span id="构建器">构建器</span></h3><p>  静态工厂和构造器都有个局限性，都不能很好的扩展到大量的可选参数。<br>  参数量大的情况下通常有两种方法：</p><ul><li><p>重叠构造器</p><blockquote><p>可行，但很难编写，难以阅读。</p></blockquote></li><li><p><em>工厂模式</em></p><blockquote><p>build构造参数很简单明了，链式调用很少出错。<br>  但是在构造Bean的时候，可能出现不一致的状态，类无法仅仅通过构造器参数的有效性来保证一致性。</p></blockquote></li></ul><h3><span id="用私有构造器或者枚举类型强化singleton属性">用私有构造器或者枚举类型强化Singleton属性</span></h3><p>  构造器私有，公开一个公共静态方法返回实例。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java类解析</title>
      <link href="/posts/java%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
      <url>/posts/java%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="java对象头">Java对象头</span></h2><p>  一般占用两个机器码，在32位虚拟机中，一个机器码占用4个字节，就是32位，但是如果是数组，需要占用3个机器码，需要1位确认数组大小。</p><ul><li>标记字段<ul><li>哈希码</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul></li><li>类型指针</li></ul><table><thead><tr><th>25bit</th><th>4bit</th><th>1bit</th><th>2bit</th></tr></thead><tbody><tr><td>对象的hashCode</td><td>分代年龄</td><td>是否是偏向锁</td><td>锁标记位</td></tr></tbody></table><p>  <img src="img/java%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>求m的n次方</title>
      <link href="/posts/%E6%B1%82m%E7%9A%84n%E6%AC%A1%E6%96%B9/"/>
      <url>/posts/%E6%B1%82m%E7%9A%84n%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="初步设想">初步设想</span></h2><p>  最简单的方法，就是for循环一下。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> result = <span class="number">1L</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">     result *= m;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>  这种方法结果肯定正确，但是时间复杂度上，需要O(n)。很是不理想。于是我想着改进一下。</p><h2><span id="探求乘法原理">探求乘法原理</span></h2><p>  乘法原理就是n个m相乘，例如m=10，n=5， 那么表达式为 10<em>10</em>10<em>10</em>10,有人说这不是废话嘛，当然不是，之所以展开，是因为可以改写法，如：(10<em>10)</em> (10<em>10)</em> 10,又有人说了，这不是还是废话嘛，别急往下看，你会发现(10*10)重复了。</p><p>  什么意思？</p><p>  如果单纯用for循环10的4次幂，需要 <em>循环4次运算</em>，现在我先用10<em>10,<em>第1次运算</em>，再用得出的结果乘以得出的结果，也就是(10</em>10)* (10*10),<em>第2次运算</em>。就这么简单，此次运算节省了2次，节省了百分之50啊，重大发现啊。</p><p>  如果是10的8次幂呢？单纯for循环需要8次，新的方法需要几次？<em>3次</em>。怎么算的？(10<em>10)</em> (10<em>10)</em> (10<em>10)</em> (10<em>10)。发现就是算10</em>10的4次方，算出10*10需要 <em>第一次</em>，4次方刚刚算了是2次，一共是3次，这么神奇啊，节省了5次运算啊。这是节省了百分之。。。ummmm，管他百分之多少呢，反正很多。</p><p>  照这么下去，16次方需要 <em>4</em> 次运算，32次方需要 <em>5</em> 次运算，64次方需要 <em>6</em> 次运算，重大发现，也就是说，<em>如果n是2的i次幂，那么就需要i次运算就可以算出m的n次方了。</em></p><p>  天晴了， 世界和平了，我又拯救了世界了，可以回家睡懒觉了。</p><p>  咦，等等，如果n不是2的多少次幂怎么办？比如10的5次幂？</p><p>  ummmm，我想了想，把5拆成4+1呢？也就是10的4次幂再乘以10，这个方法可以。</p><p>  那10的6次幂就可以拆成4+2.</p><p>  7次方就可以拆成4+2+1.嗯，不错。</p><p>  于是，我写了个代码，如下</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pow</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> m = <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">int</span> n = <span class="number">134</span>;</span><br><span class="line">      <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">&quot;for循环版，结果为 ： &quot;</span> + Double.toString(pow(m, n)));</span><br><span class="line">      <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">&quot;for循环版，总耗时： &quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      start = System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">&quot;叠乘法，结果为 ： &quot;</span> + Double.toString(pow2(m, n)));</span><br><span class="line">      end = System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">&quot;叠乘法，总耗时： &quot;</span> + (end - start));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * m的n次方,for循环版</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> m 底数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> n 幂数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          n = -n;</span><br><span class="line">          negative = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 循环乘法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">double</span> result = <span class="number">1L</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          result *= m;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (negative) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span> / result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * m的n次方,折中叠乘法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> m 底数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> n 幂数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          n = -n;</span><br><span class="line">          negative = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//        当m是2的时候，直接位移就可以。</span></span><br><span class="line">      <span class="keyword">if</span> (m == <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span> &lt;&lt; n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 叠乘法</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="comment">//        最后结果。</span></span><br><span class="line">      <span class="keyword">double</span> result = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">//        定义一个指针，从右向左按位与。</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//            按位与，如果大于0，说明此位为1,需要m的i次方。</span></span><br><span class="line">          <span class="keyword">if</span> ((i &amp; n) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">double</span> resultTemp = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">//                m的i次方不能写成循环i次的m相乘，而是m叠乘，次数为ln(i)。    例如m的8次方，就是((m*m)*(m*m))*((m*m)*(m*m)),也就是 ((m*m)2)2</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">                      resultTemp = m;</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">if</span> (greatThanMax(resultTemp, resultTemp)) &#123;</span><br><span class="line">                          <span class="keyword">return</span> Double.MAX_VALUE;</span><br><span class="line">                      &#125;</span><br><span class="line">                          resultTemp *= resultTemp;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (greatThanMax(resultTemp, result)) &#123;</span><br><span class="line">                  <span class="keyword">return</span> Double.MAX_VALUE;</span><br><span class="line">              &#125;</span><br><span class="line">              result *= resultTemp;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (negative) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span> / result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 检查两个数相乘是否大于double的最大值。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">greatThanMax</span><span class="params">(<span class="keyword">double</span> m, <span class="keyword">double</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (m &gt; (Double.MAX_VALUE / n));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果为</p><blockquote><p>for循环版，结果为 ： 4.591774807899563E93<br>    for循环版，总耗时： 1<br>    叠乘法，结果为 ： 4.591774807899562E93<br>    叠乘法，总耗时： 0</p></blockquote><h2><span id="彩蛋">彩蛋</span></h2><p>  如果m是2的话，只需要返回2&lt;&lt;n就行了。自行判断是否越界。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java学习路线</title>
      <link href="/posts/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/posts/java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="本文作为收藏用">本文作为收藏用</span></h1><h2><span id></span></h2><p>作者：匿名用户<br>链接：<a href="https://www.zhihu.com/question/39890405/answer/83676977">https://www.zhihu.com/question/39890405/answer/83676977</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><ul><li><p>第一个是基础。</p><blockquote><p>比如对集合类，并发包，IO/NIO，JVM，内存模型，泛型，异常，反射，等有深入了解，最好是看过源码了解底层的设计。比如一般面试都会问ConcurrentHashMap，CopyOnWrite，线程池，CAS，AQS，虚拟机优化等知识点，因为这些对互联网的企业是绝对重要的。而且一般人这关都过不了，还发闹骚说这些没什么用，为什么要面试。举一例子，在使用线程池时，因为使用了无界队列，在远程服务异常情况下导致内层飙升，怎么去解决？你要是连线程池都不清楚，你怎么去玩？再举一例，由于对ThreadLocal理解出错，使用它做线程安全的控制，导致没能实现真的线程安全。所以作为一个拿两万的JAVA程序员这点基础是要有的。</p></blockquote></li><li><p>第二你需要有全面的互联网技术相关知识。</p><blockquote><p>从底层说起，你起码得深入了解mysql，redis，mongodb，nginx，tomcat，rpc，jms等方面的知识。你要问需要了解到什么程度，我可以给你说个大慨。首先对于MySQL，你要知道常见的参数设置，存储引擎怎么去选择，还需要了解常见的索引引擎，知道怎么去选择。知道怎么去设计表，怎么优化sql，怎么根据执行计划去调优。高级的你需要去做分库分表的设计和优化，一般互联网企业的数据库都是读写分离，还会垂直与水平拆分，所以这个也有经验的成分在里面。然后redis，mongodb都是需要了解原理，需要会调整参数的，而nginx和tomcat几乎都是JAVA互联网方面必配，其实很阿里的技术栈选择有点关系。至于rpc相关的就多的去，必须各种网络协议，序列化技术，SOA等等，你要有一个深入的理解。现在应用比较广的rpc框架，在国内就是dubbo了，可以自行搜索。至于jms相关的起码得了解原理吧，一般情况下不是专门开发中间件系统和支撑系统的不需要了解太多细节，国内企业常用的主要是activeMQ和kafka。你能对我说的都研究的比较深入，阿里p7都不是太大问题的，当然这个还需要看你的架构能力方面的面试表现了。</p></blockquote></li><li><p>第三就是编程能力</p><blockquote><p>编程思想，算法能力，架构能力。首先2W程序员对算法的要求我觉得还是比较低，再高级也最多红黑树吧，但是排序和查询的基本算法得会。编程思想是必须的，问你个AOP和IOC你起码的清清楚楚，设计模式不说每种都用过，但也能了解个几种吧。编程能力这个我觉得不好去评价，但是拿一个2000W用户根据姓名年龄排序这种题目也能信手拈来。最后就是架构能力，这种不是说要你设计个多牛逼多高并发的系统，起码让你做一个秒杀系统，防重请求的设计能快速搞定而没有坑吧。</p></blockquote></li></ul><h3><span id="感谢">感谢</span></h3><p><a href="https://www.zhihu.com/question/39890405/answer/83676977">在北京做Java开发如何月薪达到两万，需要技术水平达到什么程度？</a><br><a href="https://www.zhihu.com/question/40801731/answer/91814769">零基础应该选择学习 java、php、前端 还是 python？</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库架构设计（转发）</title>
      <link href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%BD%AC%E5%8F%91%EF%BC%89/"/>
      <url>/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%BD%AC%E5%8F%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://gitbook.cn/books/59be67b577cac00b9c2362fa/index.html">链接地址</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库跨库分页实践（转发）</title>
      <link href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B7%A8%E5%BA%93%E5%88%86%E9%A1%B5%E5%AE%9E%E8%B7%B5%EF%BC%88%E8%BD%AC%E5%8F%91%EF%BC%89/"/>
      <url>/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B7%A8%E5%BA%93%E5%88%86%E9%A1%B5%E5%AE%9E%E8%B7%B5%EF%BC%88%E8%BD%AC%E5%8F%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://gitbook.cn/books/58a98f512bd83c246b6b8866/index.html">转载链接</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基本类型和包装类型差别</title>
      <link href="/posts/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%B7%AE%E5%88%AB/"/>
      <url>/posts/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%B7%AE%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="基本类型以及包装类型">基本类型以及包装类型</span></h2><p>   java中定义了基本类型：<br>        * 整形： byte、short、int、long<br>        * 浮点型：float、double<br>        * 逻辑型： boolean<br>        * 字符型： char<br>   以及对应的包装类型：<br>        * 整形： Byte、Short、Integer、Long<br>        * 浮点型： Float、Double<br>        * 逻辑型： Boolean<br>        * 字符型： Char </p><h2><span id="自动装箱-拆箱">自动装箱、拆箱</span></h2><p>   java为满足程序员基本类型和包装类型混合使用，按需自动装箱拆箱。<br>   自动装箱拆箱使基本类型和包装类型之间的区别逐渐模糊，但是语义上有些许差别，性能上也有明显差别。</p><h2><span id="基本类型和包装类型差别">基本类型和包装类型差别</span></h2><ul><li>基本类型有默认值，例如int值默认为0 ，而Integer没有默认引用，默认为null。<br>  所以在写数据库实体类或者网络请求接收字段的时候要使用包装类型，防止接受参数为null的情况。</li><li>包装类的频繁更改并不是在原来的基础上更改，而是产生新的对象，所以包装类的频繁更改性能很差.<blockquote><p>使用Long情况</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        Long sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;using Long total time = &quot;</span> + (end - now));</span><br></pre></td></tr></table></figure><p> 耗费时间为</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2305843005992468481</span></span><br><span class="line">all time = <span class="number">8832</span></span><br></pre></td></tr></table></figure><p>使用long情况</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testlongAutoBoxing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;using long ,sum =&quot;</span> + sum);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;using long total time = &quot;</span> + (end - now));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 总耗费时间为</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2305843005992468481</span></span><br><span class="line">all time = <span class="number">787</span></span><br></pre></td></tr></table></figure></blockquote> 在使用Long的时间比long增加10倍，原因是Long的操作过程中会构造大概2^31个实例。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> EffectJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java单例的七种写法</title>
      <link href="/posts/java%E5%8D%95%E4%BE%8B%E7%9A%84%E4%B8%83%E7%A7%8D%E5%86%99%E6%B3%95/"/>
      <url>/posts/java%E5%8D%95%E4%BE%8B%E7%9A%84%E4%B8%83%E7%A7%8D%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="懒汉">懒汉</span></h1><h2><span id="线程不安全">线程不安全</span></h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;   </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">           instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">       &#125;  </span><br><span class="line">     <span class="keyword">return</span> instance;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2><span id="线程安全">线程安全</span></h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">      instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> instance;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h1><span id="饿汉">饿汉</span></h1>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">return</span> instance;  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="饿汉变种">饿汉变种</span></h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">  <span class="keyword">static</span> &#123;  </span><br><span class="line">  instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.instance;  </span><br><span class="line">  &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><h2><span id="静态内部类">静态内部类</span></h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure><h2><span id="枚举">枚举</span></h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">     INSTANCE;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h2><span id="双重校验锁">双重校验锁</span></h2>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;   </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">          <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">          <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">              singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">          &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> singleton;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java线程详解</title>
      <link href="/posts/java%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/posts/java%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="线程状态">线程状态</span></h2><ul><li>新建状态(New) : <blockquote><p>线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</p></blockquote></li><li>就绪状态(Runnable): <blockquote><p>也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</p></blockquote></li><li>运行状态(Running) : <blockquote><p>线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</p></blockquote></li><li>阻塞状态(Blocked) : <blockquote><p>阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：</p></blockquote><ul><li>等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li><li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li><li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li><li>死亡状态(Dead) : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。<blockquote><p>这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。</p></blockquote></li></ul></li><li>Object类，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。</li><li>Thread类，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。</li><li>synchronized，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。</li></ul><h2><span id="实现多线程的两种方式thread和runnable">实现多线程的两种方式：Thread和Runnable</span></h2><ul><li>Runnable 是一个接口，该接口中只包含了一个run()方法。它的定义如下：<br>public interface Runnable {<br> public abstract void run();<br>}<br>Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；然后，通过new Thread(new A())等方式新建线程。<br>Thread 是一个类。Thread本身就实现了Runnable接口。它的声明如下：<br>public class Thread implements Runnable {}<br>Thread的作用，实现多线程。</li></ul><h3><span id="thread和runnable的异同点">Thread和Runnable的异同点：</span></h3><ul><li>Thread 和 Runnable 的相同点：<blockquote><p>都是“多线程的实现方式”。</p></blockquote></li><li>Thread 和 Runnable 的不同点：<blockquote><p>Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。<br>此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。<br>通常，建议通过“Runnable”实现多线程！</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java并发锁</title>
      <link href="/posts/java%E5%B9%B6%E5%8F%91%E9%94%81/"/>
      <url>/posts/java%E5%B9%B6%E5%8F%91%E9%94%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="实现方式">实现方式</span></h2><ul><li>锁<br>   -[ ] 公平锁<br>   -[ ] 非公平锁<ul><li>隐式锁Synchronized</li><li>显式锁Lock<ul><li>ReentrantLock</li><li>ReadWriteLock</li><li>ReentrantReadWriteLock</li><li>StampedLock </li></ul></li><li></li></ul></li><li>无锁<ul><li>atomic</li><li>concurrent</li><li>blocking</li><li>threadLocal</li><li>volatile</li><li>CAS</li></ul></li></ul><h2><span id="锁">锁</span></h2><ul><li>Synchronized<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ++count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Lock<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">int</span> newCount = ++count;</span><br><span class="line">lock.unlock();</span><br><span class="line"><span class="keyword">return</span> newCount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>不可重入自旋锁的简单实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(isLocked)&#123;</span><br><span class="line">wait();</span><br><span class="line">&#125;</span><br><span class="line">isLocked = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">isLocked = <span class="keyword">false</span>;</span><br><span class="line">notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2><span id="threadlocal">threadLocal</span></h2><p>   如果想知道为什么使用ThreadLocal，就得先了解局部变量和全局变量对线程安全的影响。<br>   局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的。<br>   当多个线程引用同一个对象时，因为对象引用是放在栈上的，但是对象实例存储在堆中，所以不是线程安全的。</p><p>   ThreadLocal就是拷贝一份到线程缓存中，Thread正是操作这个对象，就不会出现安全问题。</p><ul><li>InheritableThreadLocal</li></ul><p>   InheritableThreadLocal类是ThreadLocal的子类。为了解决ThreadLocal实例内部每个线程都只能看到自己的私有值，所以InheritableThreadLocal允许一个线程创建的所有子线程访问其父线程的值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入分析Synchronized</title>
      <link href="/posts/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronized/"/>
      <url>/posts/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Synchronized/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="java同步关键字synchronzied">Java同步关键字（synchronzied）</span></h1><blockquote><p>所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。</p></blockquote><h2><span id="使用方法">使用方法</span></h2><ul><li>实例方法同步    <blockquote><p>作用在实例上</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.count += value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote></li><li>静态方法同步<blockquote><p>作用在对象上</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.count += value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote></li><li>实例方法中同步块<blockquote><p>作用在this这个实例上</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">       <span class="keyword">this</span>.count += value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote></li><li>静态方法中同步块<blockquote><p>作用在MyClass这个class上</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">log1</span><span class="params">(String msg1, String msg2)</span></span>&#123;</span><br><span class="line">       log.writeln(msg1);</span><br><span class="line">       log.writeln(msg2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log2</span><span class="params">(String msg1, String msg2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(MyClass.class)&#123;</span><br><span class="line">          log.writeln(msg1);</span><br><span class="line">          log.writeln(msg2);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>[参考]{<a href="http://ifeve.com/synchronized-blocks/%7D">http://ifeve.com/synchronized-blocks/}</a></p><p>[参考2]{<a href="http://cmsblogs.com/?hmsr=toutiao.io&amp;p=2071&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io%7D">http://cmsblogs.com/?hmsr=toutiao.io&amp;p=2071&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io}</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡</title>
      <link href="/posts/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/posts/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="什么是负载均衡">什么是负载均衡</span></h2><p>   负载均衡（Load Balance）是分布式系统架构设计中必须考虑的因素之一，它通常是指，将请求/数据【均匀】分摊到多个操作单元上执行，负载均衡的关键在于【均匀】。</p><p>   常见互联网分布式架构如上，分为客户端层、反向代理nginx层、站点层、服务层、数据层。可以看到，每一个下游都有多个上游调用，只需要做到，每一个上游都均匀访问每一个下游，就能实现“将请求/数据【均匀】分摊到多个操作单元上执行”。</p><ul><li>“客户端层-&gt;反向代理层”的负载均衡<br> 【客户端层】到【反向代理层】的负载均衡，是通过“DNS轮询”实现的：DNS-server对于一个域名配置了多个解析ip，每次DNS解析请求来访问DNS-server，会轮询返回这些ip，保证每个ip的解析概率是相同的。这些ip就是nginx的外网ip，以做到每台nginx的请求分配也是均衡的。</li><li>“反向代理层-&gt;站点层”的负载均衡<br>  【反向代理层】到【站点层】的负载均衡，是通过“nginx”实现的。通过修改nginx.conf，可以实现多种负载均衡策略：<ul><li>请求轮询：和DNS轮询类似，请求依次路由到各个web-server</li><li>最少连接路由：哪个web-server的连接少，路由到哪个web-server</li><li>ip哈希：按照访问用户的ip哈希值来路由web-server，只要用户的ip分布是均匀的，请求理论上也是均匀的，ip哈希均衡方法可以做到，同一个用户的请求固定落到同一台web-server上，此策略适合有状态服务，例如session.</li></ul></li><li>“站点层-&gt;服务层”的负载均衡<br>   【站点层】到【服务层】的负载均衡，是通过“服务连接池”实现的。<br>   上游连接池会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。</li><li>“数据层”的负载均衡<br> 在数据量很大的情况下，由于数据层（db，cache）涉及数据的水平切分，所以数据层的负载均衡更为复杂一些，它分为“数据的均衡”，与“请求的均衡”。<ul><li>数据的均衡是指：水平切分后的每个服务（db，cache），数据量是差不多的。</li><li>请求的均衡是指：水平切分后的每个服务（db，cache），请求量是差不多的。<br>业内常见的水平切分方式有这么几种：<ul><li>按照range水平切分        <ul><li>好处<ul><li>规则简单，service只需判断一下uid范围就能路由到对应的存储服务</li><li>数据均衡性较好</li><li>比较容易扩展，可以随时加一个uid[2kw,3kw]的数据服务</li></ul></li><li>不足是：<ul><li>请求的负载不一定均衡，一般来说，新注册的用户会比老用户更活跃，大range的服务请求压力会更大</li></ul></li></ul></li><li>按照id哈希水平切分<ul><li>好处：<ul><li>规则简单，service只需对uid进行hash能路由到对应的存储服务</li><li>数据均衡性较好</li><li>请求均匀性较好</li></ul></li><li>不足：<ul><li>不容易扩展，扩展一个数据服务，hash方法改变时候，可能需要进行数据迁移</li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代理</title>
      <link href="/posts/%E4%BB%A3%E7%90%86/"/>
      <url>/posts/%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="代理分类">代理分类</span></h1><h2><span id="正向代理">正向代理</span></h2><pre><code>&gt;服务器ip地址不变，用户ip地址变。例如用户(1.1.1.1)使用正向代理(2.2.2.2)访问服务器(3.3.3.3),那么服务器收到的消息来自2.2.2.2.服务器不知道用户真正的地址。</code></pre><h2><span id="反向代理">反向代理</span></h2><pre><code>&gt; 反之，用户不知道服务器的地址。</code></pre><h3><span id="场景">场景</span></h3><pre><code>对用户屏蔽高可用、屏蔽web-server扩展、内网等一些细节。由于web-server有多台，需要进行负载均衡。</code></pre><h1><span id="负载均衡">[负载均衡]{}</span></h1><h2><span id="软件">软件</span></h2><ul><li>nginx/apache</li><li>F5</li><li>lvs</li></ul><h2><span id="什么是四层转发交换什么是七层转发交换">什么是四层（转发/交换），什么是七层（转发/交换）？</span></h2><p>   <img src="img/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE7%E5%B1%82%E4%B8%8E5%E5%B1%82%E5%8D%8F%E8%AE%AE.png" alt="这个是来源于OSI七层模型"><br>   由图可见，4层指传输层，7层指应用层<br>   更具体的，对应到nginx反向代理hash：</p><ul><li>四层：根据用户ip+port来做hash</li><li>七层：根据http协议中的某些属性来做hash</li></ul><h2><span id="为什么中间少了几层">为什么中间少了几层？</span></h2><pre><code>OSI应用层、表示层、会话层合并到TCP/IP的应用层啦。</code></pre><h2><span id="上面有四层七层那有没有二层三层呢">上面有四层，七层，那有没有二层，三层呢？</span></h2><ul><li>二层：根据数据链路层MAC地址完成数据交换</li><li>三层：根据网络层IP地址完成数据交换</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>炸了那个Jvm</title>
      <link href="/posts/%E7%82%B8%E4%BA%86%E9%82%A3%E4%B8%AAJvm/"/>
      <url>/posts/%E7%82%B8%E4%BA%86%E9%82%A3%E4%B8%AAJvm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://zhuanlan.51cto.com/art/201709/550451.htm">http://zhuanlan.51cto.com/art/201709/550451.htm</a></p><h2><span id="jvm内存模型">JVM内存模型</span></h2><p>   <img src="img/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg"></p><p>   打印出来的信息：</p><pre><code>PSYoungGen      total 3072K, used 128K     eden space 2560K, 5% used      survivor  space         from space 512K, 0% used           to   space 512K, 0% used   ParOldGen       total 6656K, used 408K     object space 6656K, 6% used    PSPermGen       total 4096K, used 3039K        object space 4096K, 74% used      </code></pre><h2><span id="gc过程">GC过程</span></h2><ul><li>年轻代：<br>  存放对象的特点： 生命周期短，多为临时变量。<blockquote><p>新实例化的对象都会在eden中new出来，经过手动System.gc()（本质上也是调用Runtime的gc）、Runtime.getRuntime().gc()（本地方法）或者一段时间后系统自动触发gc，年轻代使用 <em>复制清除</em>算法 ，从Root对象开始标记为存活，存活的对象引用的对象也会标记为存活，扫描整个eden区后，将存活的对象存放到其中一个survivor区，清除eden区和另外一个eden区。下次再产生新的对象仍然是放到eden区内，再gc时将eden区和有对象存储的survivor存活的对象复制到另外一个survivor区内，清除这两个区，反复如此，清除一定次数后（之前看过介绍15次，不太确定）将仍然存活的放到年老代。</p></blockquote></li><li>年老代<br>  存放对象特点： 生命周期长。<blockquote><p>年老代使用<em>标记整理</em>算法，还是从Root对象开始搜索，标记所有存活的对象，把所有存活的对象复制到一个区域内，再清除其他区域。</p></blockquote></li></ul><h2><span id="示例">示例</span></h2><h3><span id="栈内存溢出javalangstackoverflowerror">栈内存溢出(java.lang.StackOverflowError)</span></h3><pre><code> &gt; -Xmx10m   -XX:MaxPermSize=5m   -XX:MaxDirectMemorySize=5m   -XX:+PrintGCDetails</code></pre><h3><span id="永久代溢出javalangoutofmemoryerror-gc-overhead-limit-exceeded">永久代溢出(java.lang.OutOfMemoryError: GC overhead limit exceeded)</span></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Collections类全解析</title>
      <link href="/posts/Collections%E7%B1%BB%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
      <url>/posts/Collections%E7%B1%BB%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql内连接、左外连接、右外连接、全连接</title>
      <link href="/posts/Mysql%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E5%85%A8%E8%BF%9E%E6%8E%A5/"/>
      <url>/posts/Mysql%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5%E3%80%81%E5%85%A8%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="指定方式">指定方式</span></h2><blockquote><p>连接条件可以在FROM或WHERE语句中指定。</p></blockquote><h2><span id="分类">分类</span></h2><ul><li><p>内连接</p><blockquote><p>典型的连接运算，使用=或者&lt;&gt;之类的比较运算。包括相等连接和自然连接。<br>内连接使用比较运算符根据每个表共有的值匹配两个表中的行。</p></blockquote></li><li><p>外连接</p><ul><li><p>左外连接</p><blockquote><p>left join 结果集包括左表中的所有行，如果左表的某行在右表中没有匹配行，结果集中显示为空。</p></blockquote></li><li><p>右外连接</p><blockquote><p>与左外连接相反。</p></blockquote></li></ul></li><li><p>全连接</p><blockquote><p>返回左表和右表中所有的行。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql索引</title>
      <link href="/posts/Mysql%E7%B4%A2%E5%BC%95/"/>
      <url>/posts/Mysql%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="概念">概念</span></h2><blockquote><p>由用户创建的，能够被修改和删除的，实际存储在数据库中的物理存在。它是某一表中一列或者若干列值得集合和相应的指向表中物理标志这些值的数据页的逻辑指针清单</p></blockquote><h2><span id="优点">优点</span></h2><ul><li>通过创建唯一索引，可以保证数据库中每一行数据的唯一性。</li><li>大大加快数据的检索速度。</li><li>加速表与表之间的联系。</li><li>在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统性能。</li></ul><h2><span id="缺点">缺点</span></h2><ul><li>创建和维护索引需要耗费时间，时间随数据量增加而增加。</li><li>索引占据物理空间，如果建立聚簇索引，占用空间更大。</li></ul><h2><span id="分类">分类</span></h2><ul><li>聚集索引，表中数据按照索引的顺序来存储。叶子节点存储了真实的数据行，没有另外单独的数据页。</li><li>非聚集索引，表数据存储顺序与索引顺序无关，叶节点包含索引字段值及指向数据页数据行的逻辑指针。</li><li>一张表上只能创建一个聚集索引，因为真实数据的物理顺序只能是一种。如果一张表没有聚集索引，它被称为“堆集”，没有特定的顺序，新加的元行被添加到末尾。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList原理</title>
      <link href="/posts/ArrayList%E5%8E%9F%E7%90%86/"/>
      <url>/posts/ArrayList%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="实现方式">实现方式</span></h2><p>  存储数据是通过数组： transient Objectp[] elementData<br>  size字段： 存储整个数组的大小，<br>    &gt; 注意的是： size是每次add和remove都会自增和自减的，所以增加null也会size+1.</p><ul><li>是否允许空：<br>允许</li><li>是否允许重复数据：<br>允许</li><li>是否有序：<br>是</li><li>是否线程安全：<br>不是</li></ul><h2><span id="默认大小-10">默认大小 : 10</span></h2>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="扩容">扩容</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">( <span class="keyword">int</span> minCapacity)</span></span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  <span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;</span><br><span class="line">      Object oldData[] = elementData;</span><br><span class="line">      <span class="keyword">int</span> newCapacity = (oldCapacity * <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (newCapacity &lt; minCapacity)</span><br><span class="line">      newCapacity = minCapacity;</span><br><span class="line">             <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">             elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="删除元素">删除元素</span></h2><ul><li>根据下标删除。</li><li>根据元素删除。<blockquote><p>删除跟元素匹配的 <em>第一个</em> 元素</p></blockquote></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line"></span><br><span class="line">         numMoved);</span><br><span class="line"></span><br><span class="line">elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br></pre></td></tr></table></figure><ul><li>1、把指定元素后面位置的所有元素，利用System.arraycopy方法整体向前移动一个位置</li><li>2、最后一个位置的元素指定为null，这样让gc可以去回收它<blockquote><p>因为删除的时候，需要将后面所有元素向前移动一个位置，所以删除的时候，很消耗性能。</p></blockquote></li></ul><h2><span id="插入元素">插入元素</span></h2><ul><li>add(T t)</li><li>add(int position,T t)<blockquote><p>插入时候会将所有后面的元素向后移动一个位置，很消耗性能。</p></blockquote></li></ul><h2><span id="arraylist的优缺点">ArrayList的优缺点</span></h2><ul><li>底层以数组方式存储，是一种随机访问方式，并且实现了RandomAccess接口，因此查找十分快速。</li><li>添加很方便，往数组的最后添加一个就行了。</li><li>删除和添加的时候涉及到移动后面所有数据，性能消耗比较大。    </li></ul><h2><span id="线程安全">线程安全</span></h2><blockquote><p>不是线程安全的，所有方法都没有Synchronized修饰，在并发情况下会出现安全问题。可以使用Collections.synchronizedList方式</p></blockquote><h2><span id="为什么arraylist的elementdata是用transient修饰的">为什么ArrayList的elementData是用transient修饰的？</span></h2><blockquote><p>private transient Object[] elementData;</p></blockquote><blockquote><p>ArrayList 实现了Serializable接口，所以是可以序列化的。但是elementData不一定是满的，没必要全部序列化。所以ArrayList重写了writeObject方法实现，增快了序列化的速度，见笑了序列化后的大小：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line"><span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line"><span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">s.defaultWriteObject();</span><br><span class="line">        <span class="comment">// Write out array length</span></span><br><span class="line">       s.writeInt(elementData.length);</span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">           s.writeObject(elementData[i]);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新增功能</title>
      <link href="/posts/java8%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD/"/>
      <url>/posts/java8%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>[TOC]</p><h1><span id="接口中default关键字修饰方法可以增加默认实现">接口中default关键字修饰方法可以增加默认实现。</span></h1>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="lambda表达式">Lambda表达式</span></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names,(a,b)-&gt;b.compareTo(a));</span><br></pre></td></tr></table></figure><h1><span id="函数式接口">函数式接口</span></h1> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Coverter</span>&lt;<span class="title">F</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Convert&lt;String,Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1><span id="方法和构造函数引用">方法和构造函数引用</span></h1><ul><li>静态方法引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Convert&lt;String,Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>通过:: 关键字获取方法或者构造函数的引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span></span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Something something = <span class="keyword">new</span> Something();</span><br><span class="line">Converter&lt;String,String&gt; converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>引用构造函数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  String firstName；</span><br><span class="line">  String lastName；</span><br><span class="line">  Person()&#123;&#125;;</span><br><span class="line">  Person(String firstName,String lastName)&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName=firstName;</span><br><span class="line">    <span class="keyword">this</span>.lastName=lastName;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新建工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function">P <span class="title">create</span><span class="params">(String firstName,String lastName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过构造函数引用将所有东西拼到一起，通过手动实现。</span></span><br><span class="line"></span><br><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person = personFactory.create(<span class="string">&quot;earyant&quot;</span>,<span class="string">&quot;Lee&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h1><span id="类库示例">类库示例</span></h1><h2><span id="predicates断言">Predicates(断言)</span></h2><blockquote><p>是一个布尔类型的函数，该函数只有一个输入函数，它实现了多种默认方法，用于处理复杂的逻辑动词。(and ,or,negate(否定))</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s)-&gt;s.length()&gt;<span class="number">0</span>;</span><br><span class="line">predicate.test(<span class="string">&quot;earyant&quot;</span>)  <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">&quot;earyant&quot;</span>); <span class="comment">//false  </span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure><h2><span id="functions">Functions</span></h2><blockquote><p>接收一个参数，并返回单一的结果，默认方法可以将多个函数穿在一起(compose，andThen)：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String,Integer&gt; toInteger = Integer:valueOf;</span><br><span class="line">Function&lt;String,String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line">backToString.apply(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><h2><span id="suppliers">Suppliers</span></h2><blockquote><p>Supplier 接口产生一个给定类型的结果，与Function不同的是，Supplier没有输入参数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person:<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring中的事务管理</title>
      <link href="/posts/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/posts/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="基本特征">基本特征</span></h2><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性<h2><span id="事务的分类">事务的分类</span></h2></li><li>声明式事务</li><li>编程式事务</li></ul><h2><span id="数据错误类型">数据错误类型</span></h2><ul><li><p>脏读(dirty read)</p><blockquote><p>当前有两个事务A和B，当A事务对数据进行更改，但是还没提交（会有缓存），此时被事务B读取，然后事务A因其他原因导致失败数据回滚，此时的事务A的操作都是失败的，对数据的操作也是失败的，但是B事务已经读取了A没提交的数据，导致B读到了错误的数据。</p></blockquote></li><li><p>不可重复读(no-repeatable-read)</p><blockquote><p>当前有两个事务A和B，A事务将会对数据进行两次操作，当A事务操作一次成功后，B事务此时对数据操作更改了值并提交，随后A事务再进行读取数据，发现数据已经被更改，造成A事务的数据混乱。</p></blockquote></li><li><p>幻读(phantom read)</p><blockquote><p>与不可重复读同样都是多次读数据不一致的问题，但是no-repeatable-read强调的是本身需要的数据集改变了， phantom read强调多次查询得出的条件数据集改变了。</p></blockquote></li></ul><h2><span id="事务的隔离级别">事务的隔离级别</span></h2><ul><li>ISOLATION_DEFAULT 默认级别</li><li>ISOLATION_READ_UNCOMMIT   事务最低级别，允许其他事务看到此事务中未提交的数据。   <strong>这种级别会导致脏读、幻读、不可重复读</strong></li><li>ISOLATION_READ_COMMIT   保证数据提交后才能被另外一个事务看到。  <strong>这种级别可以防止脏读，但是不能防止不可重复读和幻读</strong></li><li>ISOLATION_REPEATABLE_READ       <strong>这种级别可以防止脏读、不可重复读，但是不能防止幻读</strong></li><li>ISOLATION_SERALIZABLE     <strong>最强级别，可以防止脏读、不可重复读、幻读</strong></li></ul><h2><span id="事务的传播行为">事务的传播行为</span></h2><ul><li><p>PROPAGATION_REQUIRED 如果存在一个事务，就是用这个事务，如果没有事务，就开启一个新的事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    methodB();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>PROPAGATION_SUPPORTS 如果存在一个事务，就用这个事务，如果没有事务，就非事务执行，但是对于事务同步管理器，PROPAGATION_SUPPORTS和不使用事务有少许区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    methodB();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_SUPPORTS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当通过methodA调用methodB时，methodB就是用methodA的事务，如果单独调用methodB的时候，methodB就非事务执行。</p></li><li><p>PROPAGATION_MANDATORY 如果存在一个事务，就是用当前事务，如果不存在事务，就抛出一个异常。</p></li><li><p>PROPAGATION_REQUIRED_NEW 开启一个新的事务，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  doSomeThingA();</span><br><span class="line">  methodB();</span><br><span class="line">  doSomeThingB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRES_NEW</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">TransactionManager tm = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//获得一个JTA事务管理器</span></span><br><span class="line">  tm = getTransactionManager();</span><br><span class="line">  tm.begin();<span class="comment">//开启一个新的事务</span></span><br><span class="line">  Transaction ts1 = tm.getTransaction();</span><br><span class="line">  doSomeThing();</span><br><span class="line">  tm.suspend();<span class="comment">//挂起当前事务</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    tm.begin();<span class="comment">//重新开启第二个事务</span></span><br><span class="line">    Transaction ts2 = tm.getTransaction();</span><br><span class="line">    methodB();</span><br><span class="line">    ts2.commit();<span class="comment">//提交第二个事务</span></span><br><span class="line">  &#125;</span><br><span class="line">  Catch(RunTimeException ex)&#123;</span><br><span class="line">    ts2.rollback();<span class="comment">//回滚第二个事务</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span>&#123;</span><br><span class="line">   <span class="comment">//释放资源</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//methodB执行完后，复恢第一个事务</span></span><br><span class="line">  tm.resume(ts1);</span><br><span class="line">  doSomeThingB();</span><br><span class="line">  ts1.commit();<span class="comment">//提交第一个事务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(RunTimeException ex)&#123;</span><br><span class="line">  ts1.rollback();<span class="comment">//回滚第一个事务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里，我把ts1称为外层事务，ts2称为内层事务。从上面的代码可以看出，ts2与ts1是两个独立的事务，互不相干。Ts2是否成功并不依赖于ts1。如果methodA方法在调用methodB方法后的doSomeThingB方法失败了，而methodB方法所做的结果依然被提交。而除了methodB之外的其它代码导致的结果却被回滚了。使用PROPAGATION_REQUIRES_NEW,需要使用JtaTransactionManager作为事务管理器。</p></blockquote></li><li><p>PROPAGATION_NOT_SUPPORTED 总是非事务执行，并挂起任何事务，也需要JTATransctionManager作为事务管理器</p></li><li><p>PROPAGATION_NEVER  总是非事务执行，如果存在一个事务，则抛出异常。</p></li><li><p>PROPAGATION_NESTED 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。这是一个嵌套事务,使用JDBC 3.0驱动时,仅仅支持DataSourceTransactionManager作为事务管理器。需要JDBC 驱动的java.sql.Savepoint类。有一些JTA的事务管理器实现可能也提供了同样的功能。使用PROPAGATION_NESTED，还需要把PlatformTransactionManager的nestedTransactionAllowed属性设为true;而nestedTransactionAllowed属性值默认为false;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务属性 PROPAGATION_REQUIRED</span></span><br><span class="line">methodA()&#123;</span><br><span class="line">doSomeThingA();</span><br><span class="line">methodB();</span><br><span class="line">doSomeThingB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事务属性 PROPAGATION_NESTED</span></span><br><span class="line">methodB()&#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果单独调用methodB方法，则按REQUIRED属性执行。如果调用methodA方法，相当于下面的效果：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  Connection con = <span class="keyword">null</span>;</span><br><span class="line">Savepoint savepoint = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> con = getConnection();</span><br><span class="line"> con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"> doSomeThingA();</span><br><span class="line"> savepoint = con2.setSavepoint();</span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">     methodB();</span><br><span class="line"> &#125;<span class="keyword">catch</span>(RuntimeException ex)&#123;</span><br><span class="line">    con.rollback(savepoint);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">finally</span>&#123;</span><br><span class="line">   <span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br><span class="line">  doSomeThingB();</span><br><span class="line">  con.commit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(RuntimeException ex)&#123;</span><br><span class="line">  con.rollback();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"> <span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用PROPAGATION_REQUIRES_NEW时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要JTA事务管理器的支持。<br>  使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager使用savepoint支持PROPAGATION_NESTED时，需要JDBC 3.0以上驱动及1.4以上的JDK版本支持。其它的JTA TrasactionManager实现可能有不同的支持方式。<br>  PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。<br>  另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务,  它是已经存在事务的一个真正的子事务. 潜套事务开始执行时,  它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。<br>  由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 潜套事务也会被 commit, 这个规则同样适用于 roll back.<br>  PROPAGATION_REQUIRED应该是我们首先的事务传播行为。它能够满足我们大多数的事务需求。</p></blockquote></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ结合Aop实现高并发Log记录</title>
      <link href="/posts/RabbitMQ%E7%BB%93%E5%90%88Aop%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91Log%E8%AE%B0%E5%BD%95/"/>
      <url>/posts/RabbitMQ%E7%BB%93%E5%90%88Aop%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91Log%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li>[] <a href="https://mp.weixin.qq.com/s?src=11&timestamp=1505634383&ver=397&signature=4eGGO7W4eNN4mhNGRac0hSUTD4tyNwjT0H7tPfYWtEtLPR-TQ0VZAn2dItajttVRP-XgFlJCnrNjkPB95EHmxv-H2k1*uzuHen-VibsJg-464Y8MjAZPKAeuZPBjzBhn&new=1">参考</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>aop原理及实现</title>
      <link href="/posts/aop%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/posts/aop%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="静态代理-动态代理">静态代理、动态代理</span></h2><p>1、AspectJ 使用静态代理，生成class文件时，会侵入到代码中。<br>2、Spring AOP 使用动态代理，不会侵入代码，而是在内存中临时为代码生成一个AOP对象，这个AOP对象包含目标对象的全部方法，并且在特定切点进行增强处理，并且调原对象的方法。</p><ul><li>Jvm动态代理： 通过反射接收代理的类，并要求被代理的类必须实现一个接口。JVM代理的核心是InvocationHandler接口和proxy类。</li><li>CGLib(Code Generation Library)： 如果目标没有实现接口，那么Spring会使用CGLib动态代理目标类。它是一个代码生成的类库，可以在运行时动态生成某个类的子类。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意： CGLib是通过继承方式实现的，如果某个类被标记为final，是不能通过CGLib实现动态代理的。</span><br></pre></td></tr></table></figure><h2><span id="示例使用了cglib">示例(使用了CGLib)：</span></h2>定义Person类，其中sayHello方法是切点，切点被Timer注解修饰。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="meta">@Timer</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>配置切点：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdviceTest</span></span>&#123;</span><br><span class="line">  <span class="meta">@Pointcut(&quot;@annotation(com.earyant.aop.Timer)&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在Mail类中调用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> Person person;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    person.sayHello();</span><br><span class="line">    System.out.println(person.getClass().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出结果：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">sayHello</span><br><span class="line">com.earyant.aop.Person$$EnhancerBySpringCGLIB$$56b89168</span><br></pre></td></tr></table></figure><h2><span id="示例jvm代理">示例(JVM代理)</span></h2>定义一个接口：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Chinese</span></span>&#123;</span><br><span class="line">  sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>令Person类继承自Chinese类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Chinese</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Timer</span></span><br><span class="line">  sayHello()&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>此代码运行的结果是：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before</span><br><span class="line">sayHello</span><br><span class="line">com.sun.proxy.$Proxy53</span><br></pre></td></tr></table></figure>证明使用了JVM代理。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM调优</title>
      <link href="/posts/JVM%E8%B0%83%E4%BC%98/"/>
      <url>/posts/JVM%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从敲下www.baidu.com到浏览器显示页面，都发生了什么？</title>
      <link href="/posts/%E4%BB%8E%E6%95%B2%E4%B8%8Bwww-baidu-com%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/posts/%E4%BB%8E%E6%95%B2%E4%B8%8Bwww-baidu-com%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="名词定义">名词定义</span></h1><h2><span id="url">URL</span></h2><pre><code>URL（Uniform Resource Locator），统一资源定位符，实际就是网站网址，又称域名。在茫茫网络世界中，浏览器就是靠URL来查找资源位置。URL包含协议部分，是浏览器和www万维网之间的沟通方式，它会告诉浏览器正确在网路上找到资源位置。常见的协议有http、https、ftp、file、telnet等。其中http是最常见的网络传输协议，而https则是进行加密的网络传输。</code></pre><h2><span id="ip">IP</span></h2><pre><code>为了便于记忆或辨识，人们使用域名来登录网站，每个域名背后有对应的IP地址。每个网站就是靠IP来定位的。IP是因特网中的每台连接到网络的计算机为实现相互通信而遵循的规则协议。IP分为局域网IP和全网IP。办公中常用的飞秋工具，就是使用办公室局域网IP进行通信的典型表现。每台计算机的本机IP都是127.0.0.1（即localhost）。浏览器并不能识别URL是什么，因此从输入URL开始，浏览器就要做域名解析，也就是IP寻址的工作。</code></pre><h2><span id="dns">DNS</span></h2><pre><code>DNS（Domain Name System，域名系统）——记录域名和IP地址相互映射的信息，人们可以免于记住IP数串。全国DNS信息可在网上查找到，各省都有对应分配不同的IP网段。大型企业会有自己的DNS服务器，专门存储域名和IP的映射关系，例如为大多数人熟知的谷歌DNS服务器，地址8.8.8.8。</code></pre><h1><span id="查找">查找</span></h1><h2><span id="域名解析">域名解析</span></h2><p>  当用户在浏览器中输入url后,你使用的电脑会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动,DNS请求到达本地DNS服务器之后会有以下几个步骤：</p><h3><span id="1-浏览器缓存">1. 浏览器缓存</span></h3><p>  浏览器对本地缓存进行查找，查看是否有该域名历史记录，如果有首先直接对缓存地址访问。<br>  Chrome浏览器看本身的DNS缓存时间比较方便，在地址栏输入chrome://net-internals/#dns，就可以看到了</p><h3><span id="2-本地hosts文件查找ip地址">2. 本地hosts文件查找ip地址</span></h3><p>  浏览器若无缓存或者缓存地址访问无效，则首先对hosts文件查找对应域名对应ip地址。</p><h3><span id="3-查找路由器缓存">3. 查找路由器缓存</span></h3><p>  如果系统缓存中也找不到，那么查询请求就会发向路由器，路由器一般会有自己的DNS缓存。</p><h3><span id="4-查找ispinternet-service-provider-dns-缓存">4. 查找ISP(Internet Service Provider) DNS 缓存</span></h3><p>如果路由器缓存中也找不到，那么就查询ISP DNS 缓存服务器了。<br>我们都知道在我们的网络配置中都会有”DNS服务器地址”这一项，操作系统会把这个域名发送给这里设置的DNS，比如114.114.114.114,也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。而114.114.114.114是国内移动、电信和联通通用的DNS。</p><h3><span id="5-迭代查询">5. 迭代查询</span></h3><p>  如果前面都找不到DNS缓存的话，会有以下几个步骤：</p><ol><li>本地 DNS服务器将该请求转发到互联网上的根域（根域没有名字，在DNS系统中就用一个空字符串来表示。例如<a href="http://www.baidu.com.现在的dns系统都不会要求域名以.来结束,即www.baidu.com就可以解析了,但是现在很多dns解析服务商还是会要求在填写dns记录的时候以.来结尾域名.)/">www.baidu.com.现在的DNS系统都不会要求域名以.来结束，即www.baidu.com就可以解析了，但是现在很多DNS解析服务商还是会要求在填写DNS记录的时候以.来结尾域名。）</a></li><li>根域将所要查询域名中的顶级域（比如要查询<a href="http://www.baidu.com,该域名的顶级域就是com)的服务器ip地址返回到本地dns./">www.baidu.com，该域名的顶级域就是com）的服务器IP地址返回到本地DNS。</a></li><li>本地DNS根据返回的IP地址，再向顶级域（就是com域）发送请求， com域服务器再将域名中的二级域（即<a href="http://www.baidu.com中的baidu.com)的ip地址返回给本地dns./">www.baidu.com中的baidu.com）的IP地址返回给本地DNS。</a></li><li>本地DNS再向二级域发送请求进行查询。</li><li>之后不断重复这样的过程，直到本地DNS服务器得到最终的查询结果，并返回到主机。这时候主机才能通过域名访问该网站。<br>下图能很好的说明这个迭代查询:<br><img src="./dns%E5%AF%BB%E5%9D%80%E8%BF%87%E7%A8%8B.gif"><br>当查找到对应的IP地址之后，通过IP地址查找到对应的服务器，浏览器将用户发起的http请求发送给服务器。例如：GET <a href="http://www.baidu.com/">http://www.baidu.com/</a> HTTP/1.1<h3><span id="6-cdn">6. CDN</span></h3>CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。<h1><span id="服务器处理用户请求">服务器处理用户请求</span></h1><h2><span id="代理">代理</span></h2><h3><span id="正向代理">正向代理</span></h3>正向代理是一种最终用户知道并主动使用的代理方式，比如三台支付服务服务器在微服务SpringCloud中的服务注册中心中注册了三个地址（1.1.1.1,2.2.2.2,3.3.3.3），用户服务服务器访问服务注册中心请求地址正向代理返回某一个地址（1.1.1.1），支付服务缓存到本地，在缓存有效期时间内，直接访问1.1.1.1服务器就可以了。<h3><span id="反向代理">反向代理</span></h3>在计算机世界里，由于单个服务器的处理客户端（用户）请求能力有一个极限，当用户的接入请求蜂拥而入时，会造成服务器忙不过来的局面，可以使用多个服务器来共同分担成千上万的用户请求，这些服务器提供相同的服务，对于用户来说，根本感觉不到任何差别。比如你只需要敲下<a href="http://www.baidu.com这一个域名,其实背后有很多服务器支持着,每个人的请求会被分发到不同的服务器中./">www.baidu.com这一个域名，其实背后有很多服务器支持着，每个人的请求会被分发到不同的服务器中。</a></li></ol><p>  反向代理需要有一个负载均衡设备来分发用户请求，将用户请求分发到空闲的服务器上，负载均衡设备本身也可以有多个。</p><p>  <strong>好处</strong>：<br>  用户服务做域名解析时，解析到的ip地址是负载均衡设备的ip地址，不会暴露服务器地址。当需要增加、减少服务器数量时，用户一点都察觉不到。</p><h2><span id="负载均衡反向代理的实现">负载均衡（反向代理的实现）</span></h2><h3><span id="硬件负载均衡">硬件负载均衡</span></h3><p>  F5</p><h3><span id="软件负载均衡">软件负载均衡</span></h3><ul><li>LVS(七层协议第四层)<br>  LVS是Linux Virtual Server。lvs工作在4层，所以它可以对几乎所有应用做负载均衡，包括http、数据库、聊天室等等。同时，若跟硬件负载均衡相比它的缺点也不容忽视，LVS要求技术水平很高，操作上也比较复杂，配置也很繁琐，没有赖以保障的服务支持，稳定性来说也相对较低（人为和网络环境因素更多一些）。</li><li>nginx(七层协议第七层)<br>  Nginx是工作在第七层，对于网络的依赖性就小的多。与LVS相比，Nginx的安装和配置也相对简单一些，另外测试方面也更简单，主要还是因为对网络依赖性小的缘故。Nginx有一点不好的就是应用要比LVS少。一般我们做软件负载均衡的时候，通常会先考虑LVS，但是遇到比较复杂的网络环境时，用LVS可能会遇到很多麻烦，不妨就考虑尝试一下Nginx。</li></ul><h3><span id="容器处理">容器处理</span></h3><ul><li>常用Java EE容器<ul><li>tomcat</li><li>jetty</li><li>jBoss<br>tomcat服务器启动main方法，当command命令行是start，就执行start方法。反射调用Catalina类的start()方法。这里面会弄出一个StandardServer对象（内部会使用Digester库去解析server.xml，那个里面的东西），并调用它的start()方法，把那些组件都启动起来。<br>其中在连接器的启动过程中，会弄出一个叫做endpoint的东西去和底层的网络IO打交道，会调用其bind()方法，绑定端口号。<br>connector将请求交给他所在的service里对应的engine，来处理；<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>每当HttpConnector的ServerSocket得到客户端的连接时，会创建一个Socket。<br>考虑到客户端同时发来的请求数可能有很多， 所以tomcat 中默认维护着一个连接池<br>NioChannel channel = nioChannels.pop();<br>channel.setIOChannel(socket);<br>channel.reset();<br>getPoller0().register(channel);<br>context随后在自己的mapping table里寻找servlet-mapping拦截路径为*.jsp的servlet，这里找到得是JSPServlet处理<br>找到JSPServlet后，调用JSPServlet的doGet或doPOST方法；<br>context执行完毕后，将HttpServletResponse 返回给Host；<br>host将HttpServletResponse 返回给engine；<br>engine 将HttpServletResponse 返回给 connector；<br>connector 将 HttpServletResponse 返回给用户的browser；</li></ul></li></ul><p>  tomcat容器在启动后，context对应的项目在初始化的时候，要加载相应的servlet，加载的顺序为：<br>  $CATALINA_HOME/conf/web.xml里定义的servlet（对应于上面第5步的JSPServlet）；<br>  context对应的项目WEB-INF下的web.xml中定义的servlet；</p><h3><span id="应用处理">应用处理</span></h3><ol><li>Controller接收到请求，转发给service；</li><li>service进行逻辑处理，如果有redis、ehcache等缓存则优先查询缓存；</li><li>如果是dubbo或者springcloud分布式，则通过dubbo服务或者restful请求调用其他服务模块请求信息；</li><li>调用dao查询数据库；</li><li>返回数据给service再给controller，controller再组装数据以及view返回；</li><li>view层jsp或者velocity等模板引擎解析数据</li></ol><h3><span id="mysql架构">Mysql架构</span></h3><ol><li>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。</li><li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；</li><li>将结果返回给客户端。<h4><span id="mysql能够处理的优化类型">MySQL能够处理的优化类型：</span></h4></li><li>重新定义关联表的顺序<br>数据表的关联并不总是按照在查询中指定的顺序进行，决定关联的顺序是优化器很重要的一部分功能。</li><li>将外连接转化成内连接<br>并不是所有的outer join语句都必须以外连接的方式执行。诸多因素，例如where条件、库表结构都可能会让外连接等价于一个内连接。MySQL能够识别这点并重写查询，让其可以调整关联顺序。</li><li>使用等价变换规则<br>MySQL可以使用一些等价变换来简化并规范表达式。它可以合并和减少一些比较，还可以移除一些恒成立和一些恒不成立的判断。例如：（5=5 and a&gt;5）将被改写为a&gt;5。类似的，如果有（a<b and b="c）and" a="5，则会被改写为">5 and b=c and a=5。</b></li><li>优化count()、min()和max()<br>索引和列是否为空通常可以帮助MySQL优化这类表达式。例如，要找到一列的最小值，只需要查询对应B-tree索引最左端的记录，MySQL可以直接获取索引的第一行记录。在优化器生成执行计划的时候就可以利用这一点，在B-tree索引中，优化器会讲这个表达式最为一个常数对待。类似的，如果要查找一个最大值，也只需要读取B-tree索引的最后一个记录。如果MySQL使用了这种类型的优化，那么在explain中就可以看到“select tables optimized away”。从字面意思可以看出，它表示优化器已经从执行计划中移除了该表，并以一个常数取而代之。<br>类似的，没有任何where条件的count(*)查询通常也可以使用存储引擎提供的一些优化，例如，MyISAM维护了一个变量来存放数据表的行数。</li><li>预估并转化为常数表达式</li><li>覆盖索引扫描<br>当索引中的列包含所有查询中需要使用的列的时候，MySQL就可以使用索引返回需要的数据，而无需查询对应的数据行。</li><li>子查询优化<br>MySQL在某些情况下可以将子查询转换成一种效率更高的形式，从而减少多个查询多次对数据进行访问。</li><li>提前终止查询<br>在发现已经满足查询需求的时候，MySQL总是能够立即终止查询。一个典型的例子就是当使用了limit子句的时候。除此之外，MySQL还有几种情况也会提前终止查询，例如发现了一个不成立的条件，这时MySQL可以立即返回一个空结果。<br>上面的例子可以看出，查询在优化阶段就已经终止。</li><li>等值传播</li><li>列表in()的比较<br>在很多数据库系统中，in()完全等同于多个or条件的字句，因为这两者是完全等价的。在MySQL中这点是不成立的，MySQL将in()列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件，这是一个o(log n)复杂度的操作，等价转换成or的查询的复杂度为o(n)，对于in()列表中有大量取值的时候，MySQL的处理速度会更快。</li></ol><h1><span id="浏览器渲染">浏览器渲染</span></h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMvc工作流程</title>
      <link href="/posts/SpringMvc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
      <url>/posts/SpringMvc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="springmvc核心流程主要在dodispatch方法中">SpringMVC核心流程,主要在doDispatch方法中</span></h2><ul><li> 1、用户发送请求，被SpringMvc的DispatcherServlet捕获到</li><li> 2、DispatcherServlet对获取到的URL进行解析，得到统一定位符URI，然后根据URI调用HandlerMapping获得Handler对象以及跟handler相关的拦截器，最后以HandlerExecutionChain对象形式返回。</li><li> 3、DispatcherServlet根据返回的Handler选择合适的HandlerAdapter，如果找到了HandlerAdapter,在之前就会执行preHandler方法</li><li>4、提取request中的模型数据，填充Handler入参，开始执行Handler<ul><li>在填充的过程中，SpringMvc会做一些操作：<ul><li>HttpMessageConvert ： 将消息转换成一个对象，将对象转换成指定的响应信息。</li><li>数据转换： 比如将String转换成Integer等</li><li>数据格式化： 日期格式化等</li><li>数据验证： 验证数据的有效性，包括长度、类型等等，验证结果存储到BindingResult或者Error中。</li></ul></li></ul></li><li> 5、Handler执行完成后，像DispatcherServlet返回一个ModelAndView。</li><li> 6、根据返回的ModelAndView选择一个合适的ViewResolver返回给DispatcherServlet</li><li> 7、ViewResolveModel和View来渲染视图</li><li> 8、将渲染结果返回给客户端</li></ul><h2><span id="处理关键">处理关键</span></h2><ul><li>DispatcherServlet的HandlerMapping集合中根据请求的URL匹配每一个handlerMapping对象中的某个handler,匹配成功后将会返回这个handler的处理连接handlerExecutorChain对象，而这个对象中包括多个handlerInterceptor。</li><li>HandlerInterceptor中包含三个方法<ul><li>preHandler，在Handler执行之前调用。</li><li>postHandler，在Handler执行之后调用。</li><li>afterComplete，在view渲染完成后，dispatchServlet返回之前调用。</li></ul></li><li>当preHandler返回false时，请求将在执行afterComplete后直接返回，不会执行handler。    </li></ul><h2><span id="首先有几个类需要声明modelandview-handlerexecutionchain-handlermapping-handlermethod-handleradapter">首先有几个类需要声明,ModelAndView、HandlerExecutionChain、HandlerMapping、HandlerMethod、HandlerAdapter。</span></h2><ul><li>1、HandlerMethod(org.springframework.web.method.HandlerMethod)，这个类为中存放了某个bean对象和该bean对象的某个要处理的Method对象。</li><li>2、HandlerMapping,作用为通过request对象，获取对应的HandlerMethod对象。</li><li>3、HandlerExecutionChain作用为通过加入Interceptor拦截器包装HandlerMapping返回的HandlerMethod对象。让待处理的方法对象与拦截器称为一个整体,即执行链。</li><li>4、ModelAndView,顾名思义。Model即MVC的M，View即MVC的V。其对象存放的正是数据与视图信息。</li><li>5、HandlerAdapter:作用为具体处理HandlerMethod,即通过它调用某个方法。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>取余和取模的区别</title>
      <link href="/posts/%E5%8F%96%E4%BD%99%E5%92%8C%E5%8F%96%E6%A8%A1%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/posts/%E5%8F%96%E4%BD%99%E5%92%8C%E5%8F%96%E6%A8%A1%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList和LinkedList对比</title>
      <link href="/posts/ArrayList%E5%92%8CLinkedList%E5%AF%B9%E6%AF%94/"/>
      <url>/posts/ArrayList%E5%92%8CLinkedList%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="接口">接口</span></h2><ul><li>ArrayList ： 继承自List接口</li><li>LinkedList ： 继承自List和Deque接口</li></ul><h2><span id="存储结构">存储结构</span></h2><ul><li>ArrayList ：底层用数组进行存储</li><li>LinkedList ： 底层用双链表进行存储 </li></ul><h2><span id="优点">优点</span></h2><ul><li>ArrayList ： 访问速度快，插入和删除比较慢 ，需要移动元素</li><li>LinkedList ： 访问比较慢，插入和删除比较快 ， 需要链式查询</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java集合框架</title>
      <link href="/posts/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/posts/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="顶级接口">顶级接口：</span></h2><ul><li>Collection<br>  <img src="img/Collection%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.jpg"></li><li>Map<br>  <img src="img/Map%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.jpg"></li></ul><h2><span id="顶级类">顶级类：</span></h2><ul><li>Collections</li></ul><h3><span id="接口描述">接口描述</span></h3><ul><li>Collection ：  不提供直接子类继承，只提供继承的子接口（List和Set）<ul><li><p>List : 有序的Collection，控制元素的插入位置，和通过索引访问List数据，允许相同的Key。</p><ul><li><p>Verctor</p><ul><li>Stack</li></ul></li><li><p>ArrayList</p></li><li><p>LinkedList( 也继承自 Deque)</p></li><li><p><a href="https://earyant.github.io/2017/09/10/ArrayList%E5%92%8CLinkedList%E5%AF%B9%E6%AF%94/">ArrayList和LinkedList对比</a></p></li></ul></li><li><p>Set ： 不保存重复数据</p><ul><li>HashSet<ul><li>LinkedHashSet</li></ul></li><li>SortedSet<ul><li>TreeSet</li></ul></li><li>EnumSet</li></ul></li><li><p>Queue</p><ul><li>DeQue<ul><li>LinkedList</li></ul></li><li>PriorityQueue</li></ul></li></ul></li><li>Map<ul><li>EnumMap</li><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>IdentityMap</li><li>HashTable<ul><li>Properties</li></ul></li><li>SortedMap<ul><li>TreeMap</li></ul></li><li>WeakHashMap</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java整理</title>
      <link href="/posts/java%E6%95%B4%E7%90%86/"/>
      <url>/posts/java%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="算法和数据结构性能场景">算法和数据结构（性能，场景）：</span></h2><h3><span id="数据结构">数据结构：</span></h3><ul><li><p>  数组</p></li><li><p>  链表</p></li><li><p>树</p><ul><li>二叉树<ul><li>  满二叉树</li><li>  完美二叉树</li><li>  完全二叉树</li><li>二叉搜索树： 其任何节点中的值都会大于或者等于其做字数中存储的值并小于或者等于其右子树的值。<ul><li>时间复杂度：<ul><li>  索引: O(log(n))</li><li>  搜索: O(log(n))</li><li>  插入: O(log(n))</li><li>  删除: O(log(n))</li></ul></li></ul></li></ul></li><li>  红黑树</li><li>  AVL树</li><li>  Hash树</li><li>  tire树</li><li>  b-树（读b树，也叫balance树，不读b减树 “-”代表横杠）</li><li>  b+树</li><li>  LSM（Log-Structured Merge-Trees）树</li><li>  Trie 字典树，基数树或者前缀树，能够存储键为字符串的动态集合或者关联数组的搜索树，树中节点没有存储键值，而是在该节点在树中的挂载位置决定了其关联键值，某个节点的所有子节点都拥有相同的前缀，整树根节点则是空字符串</li><li>Fenwick Tree：树状数组，又称为 Binary Indexed Tree，其表现形式为树，不过本质上是以数组实现，数组的下标代表着树中的顶点，每个顶点的父节点或者子节点的下标能够通过位运算获得，数组中的每个元素包含了预计算的区间值之和，在整颗数更新的过程中同样会更新这些预计算的值。<ul><li>时间复杂度：<ul><li>  区间求值： O(log(n))</li><li>  更新： O(log(n))</li></ul></li></ul></li><li>Segment Tree<ul><li>线段树是用于存放间隔或者线段的树形数据结构，它允许快速查找某一个节点在某若干条线段中出现的次数。<ul><li>  区间查询： O(log(n))</li><li>  更新: O(log(n))</li></ul></li></ul></li></ul></li><li><p>  队列</p></li><li><p>  栈</p></li><li><p>堆<br>   堆是一种特殊的基于树的满足某些特性的数据结构，整个堆中的所有父子节点的键值都会满足相同的排序条件。堆更准确地可以分为最大堆与最小堆，在最大堆中，父节点的键值永远大于或者等于子节点的值，并且整个堆中的最大值存储于根节点；而最小堆中，父节点的键值永远小于或者等于其子节点的键值，并且整个堆中的最小值存储于根节点。</p></li><li><p>Hashing</p><ul><li>  哈希能够将任意长度的数据映射到固定长度的数据，哈希函数返回的即是哈希值，如果两个不同的键得到相同的哈希值，将这种现象称为碰撞。</li><li>Hash Map<br>   是一种能够建立起键与值之间关系的数据结构，Hash Map能够使用哈希函数将键转化为桶或者槽中的下标，从而优化对于目标值的搜索速度。</li><li>碰撞解决：<ul><li>链地址法：<br>   每个桶都是互相独立的，包含一系列索引的列表，搜索操作的时间复杂度即是搜索桶的时间（固定时间）与遍历列表的时间之和。</li><li>开地址法：<br>   当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法一次选择下一个可能的位置，知道找到一个尚未被占用的地址，所谓开地址法也是只某个元素的位置并不永远由其哈希值决定。</li></ul></li></ul></li><li><p>Graph</p><pre><code>       图是一种数据元素间为多对多关系的数据结构，加上一组基本操作构成的抽象数据类型       \- 无向图：          无向图具有对称的邻接矩阵，因此如果存在某条从节点u到节点v的边，反之从v到u的边也存在。       \- 有向图：          有向图的邻接矩阵是非对称的，即如果存在从u到v的表并不意味着存在v到u的边。</code></pre><h3><span id="算法">：</span></h3></li><li><p>查找：</p><ul><li>  二分查找，以及变种二分查找。</li><li>  <a href="https://www.cnblogs.com/0kk470/p/7555033.html">深度优先、广度优先</a></li><li><a href="https://www.cnblogs.com/MrSaver/p/8641971.html">贪心算法</a><ul><li>  <a href="https://blog.csdn.net/a345017062/article/details/52443781">参考二</a></li></ul></li><li>  <a href="https://blog.csdn.net/qfikh/article/details/51960331">回溯算法</a></li><li>  <a href="https://blog.csdn.net/luningcsdn/article/details/50930276">剪枝算法</a></li><li><a href="https://www.cnblogs.com/little-YTMM/p/5372680.html">动态规划</a><ul><li>  <a href="https://blog.csdn.net/yao_zi_jie/article/details/54580283">参考二</a></li></ul></li><li><a href="https://blog.csdn.net/amds123/article/details/70173402">朴素贝叶斯</a><ul><li>  <a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html">参考二</a></li><li>  <a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html">参考三</a></li></ul></li><li>  <a href="http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01">推荐算法</a></li><li>  <a href="https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems">参考二</a></li><li>  <a href="https://blog.csdn.net/luoshixian099/article/details/51908175">最小生成树算法</a></li><li>  <a href="https://blog.csdn.net/qq_35644234/article/details/60870719">最短路径算法</a></li></ul></li><li><p>排序：</p><ul><li>7种排序<pre><code>  \- [选择排序](https://www.cnblogs.com/shen-hua/p/5424059.html)    &gt; 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。  - [冒泡排序](https://blog.csdn.net/shuaizai88/article/details/73250615)      &gt; 相邻元素前后交换、把最大的排到最后。      &gt; 时间复杂度 O(n²)  - [插入排序](https://www.cnblogs.com/hapjin/p/5517667.html)  -   [快速排序](http://developer.51cto.com/art/201403/430986.htm)      -   稳定： 否      -   时间复杂度：          -   最优时间：O(nlog(n))          -   最坏时间: O(n^2)          -   平均时间：O(nlog(n))  -   [归并排序：](http://www.cnblogs.com/chengxiao/p/6194356.html)      -   分治算法，不断将某个数组分为两个部分，分别对左子数组与右子数组进行排序，然后将两个数组合并为新的有序数组      -   稳定：是      -   时间复杂度          -   最优时间： O(nlog(n))          -   最坏时间： O(nlog(n))          -   平均时间： O(nlog(n))  -   [桶排序：](http://blog.51cto.com/ahalei/1362789)      - [参考二](https://blog.csdn.net/sunjinshengli/article/details/70738527)      -   桶排序将数组分到有限数量的筒子里，每个桶子再个别排序，有可能在使用别的排序算法或者以地柜方式继续使用桶排序。      -   时间复杂度：          -   最优时间： O(n+k)          -   最坏时间： O(n^2)          -   平均时间： O(n+k)              [参考](https://github.com/kdn251/interviews/blob/master/README-zh-cn.md)  -  [计数排序](https://www.cnblogs.com/suvllian/p/5495780.html)  -   时间、空间复杂度（理解并分析）  -   动态规划、贪心算法</code></pre><h3><span id="计算机网络">计算机网络</span></h3></li></ul></li><li><p>OSI7层协议（TCP四层）</p><ul><li>  URL到页面的过程</li></ul></li><li><p>http&#x3A;</p><ul><li>  http/https 1.0、1.1、2.0</li><li>  get/post 以及幂等性</li><li>  http相关头协议</li></ul></li><li><p>  网络攻击（CSRF、XSS）</p></li><li><p>TCP/IP</p><ul><li>  三次握手、四次握手</li><li>  拥塞控制（过程、阙值）</li><li>  TCP与UDP比较</li><li>  子网掩码</li><li>  DDos攻击</li></ul></li><li><p>BIO、IO、NIO、AIO</p><ul><li>  原理</li><li>  Netty</li><li>  linux内核的select poll epoll</li></ul></li></ul><h3><span id="数据库mysql">数据库(mysql)</span></h3><ul><li>索引<ul><li>分类<ul><li>  全文索引</li><li>  HASH索引</li><li>  BTree索引</li><li>  RTree索引</li><li>  普通索引</li><li>  唯一索引</li><li>  主索引</li><li>  外键索引</li><li>  复合索引</li></ul></li></ul></li><li>优化方式<ul><li>  失效条件</li><li>  底层结构</li></ul></li><li>sql语法<ul><li>  join、union、子查询、having、group by</li></ul></li><li>引擎对比<ul><li>  InnoDB</li><li>  MyISAM</li></ul></li><li>[锁]{}<ul><li>  行锁、表锁、页级锁、意向锁、读锁、写锁、悲观锁、乐观锁、以及枷锁的select sql方式</li></ul></li><li>隔离级别<ul><li>  脏读</li><li>  不可重复读</li><li>  幻读</li></ul></li><li>  事务的ACID</li><li>  B树</li><li>  B+树</li><li>优化<ul><li>  explain</li><li>  慢查询</li><li>  show profile</li><li>  数据库的范式</li><li>  分库分表</li><li>  主从复制</li><li>  读写分离</li></ul></li></ul><h3><span id="nosql">NoSql</span></h3><ul><li>  redis</li><li>  memcached</li><li>  mongdb</li><li>  <a href="http://www.runoob.com/Memcached/Memcached-tutorial.html">《Memcached 教程》</a></li><li>  <a href="https://blog.csdn.net/chenleixing/article/details/47035453">《深入理解Memcached原理》</a></li><li>  <a href="https://www.jianshu.com/p/36e5cd400580">《Memcached软件工作原理》</a></li><li>  <a href="http://zhihuzeye.com/archives/2361">《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》</a></li><li>  <a href="https://blog.csdn.net/liu251890347/article/details/37690045">《memcache 中 add 、 set 、replace 的区别》</a></li><li>  <a href="https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=">《memcached全面剖析》</a></li></ul><h3><span id="设计模式">设计模式</span></h3><ul><li><p><a href="https://blog.csdn.net/q291611265/article/details/48465113">设计模式的六大原则</a></p><ul><li>  开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。</li><li>  里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li><li>  依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。</li><li>  接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。</li><li>  迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li><li>  合成复用原则：尽量使用合成/聚合,而不是使用继承。</li></ul></li><li><p><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html">23种常见设计模式</a></p><ul><li>  <a href="https://www.cnblogs.com/susanws/p/5510229.html">参考二</a></li></ul></li><li><p><a href="http://blog.jobbole.com/62314/">《细数JDK里的设计模式》</a></p><ul><li><p>结构型模式：</p><ul><li>  适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。</li><li>  桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li><li>  组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。</li><li>  装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li><li>  享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li><li>  代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy</li></ul></li><li><p>创建模式:</p><ul><li>  抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。</li><li>  建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。</li><li>  工厂方法：就是 一个返* 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li><li>  原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。</li><li>  单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。</li></ul></li><li><p>行为模式：</p><ul><li>  责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。</li><li>  命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。</li><li>  解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。</li><li>  迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。</li><li>  中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。</li><li>  空对象模式：如 java.util.Collections#emptyList()。</li><li>  观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。</li><li>  模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。</li></ul></li></ul></li><li><p>  <a href="https://www.cnblogs.com/hwaggLee/p/4510687.html">《Spring-涉及到的设计模式汇总》</a></p></li><li><p>  <a href="https://blog.csdn.net/u012387062/article/details/54719114">《Mybatis使用的设计模式》</a></p></li></ul><h3><span id="操作系统">操作系统</span></h3><ul><li><p>  进程通信IPC，与线程区别</p></li><li><p>  OS集中策略、进程调度</p></li><li><p>  互斥与死锁</p></li><li><p>linux相关命令</p><ul><li>  cpu命令</li><li>  内存</li><li>  部署</li><li>vim<h3><span id="java">java</span></h3></li></ul></li><li><p>  面向对象</p></li><li><p><a href="https://earyant.github.io/2017/09/10/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">集合</a></p><ul><li><p>map</p><ul><li>  <a href="https://earyant.github.io/2017/08/09/HashMap%E5%85%A8%E8%A7%A3%E6%9E%90/">Hashmap</a></li><li>  EnumMap: 枚举类型座位键值的Map，效率要高于HashMap</li><li>  HashTable：</li><li>ConcurrentHashMap：<ul><li>  get操作全并发访问，put操作可配置并发操作的哈希表，并发级别可以通过构造参数中的concurrentLevel参数设置(默认级别为16).该参数会在Map内部划分一些分区，在put的时候，只有更新的分区是锁住的。</li></ul></li><li>  ConcurrentSkipListMap： 基于跳跃表的ConcurrentNavigableMap实现。本质上这种集合可以当做TreeMap的线程安全版本来使用。</li><li>  IdentityHashMap</li><li>  LinkedHashMap</li><li>  TreeMap</li><li>  WeakHashMap</li></ul></li><li><p>list</p><ul><li>ArrayList<ul><li>  内部用一个整形数字或者数组存储了集合的大小。</li><li>  访问速度稳定；</li><li>  在尾部添加成本低，在头部添加成本高(线性复杂度)。</li></ul></li><li>LinkedList<ul><li>Deque实现，每一个节点都保存着上一个节点和下一个节点的指针。所以数据的存取和更新都具有线性复杂度。<br>  <a href="https://earyant.github.io/2017/09/10/ArrayList%E5%92%8CLinkedList%E5%AF%B9%E6%AF%94/">ArrayList和LinkedList对比</a></li><li>时间复杂度：<ul><li>  索引:  O(n)</li><li>  搜索:  O(n)</li><li>  插入:  O(1)</li><li>  移除:  O(1)</li></ul></li></ul></li><li>  Vector</li></ul></li><li><p>set</p><ul><li>  HashSet</li><li>  EnumSet</li><li>  BitSet</li><li>  LinkedHashMap</li><li>  TreeSet</li><li>  ConcurrentSkipListSet ： 使用ConcurrentSkipListMap来存储线程安全的Set。</li><li>  CopyOnWriteArraySet： 使用CopyOnWriteArrayList存储的线程安全的Set</li></ul></li><li><p>Queues/Deques</p><ul><li><p>  ArrayDeQue ： Deque是基于有首尾指针的数组（环形缓冲区）实现的。和LinkedList不同，这个类没有实现List接口，因此，如果没有收尾元素的话，就不能去除任何元素。比LinkedList好一点，产生的垃圾数量较少。</p></li><li><p><a href="https://www.cnblogs.com/lemon-flm/p/7877898.html">Queue</a></p><ul><li>  enqueue： 插入到队列中</li><li>  dequeue： 将队头移除</li><li>时间复杂度：<ul><li>  索引: O(n)</li><li>  搜索: O(n)</li><li>  插入: O(1)</li><li>  移除: O(1)</li></ul></li></ul></li><li><p>Stack ：后进先出的队列</p><ul><li>  push： 将元素压入栈</li><li>  pop：  将栈顶元素移除</li><li>时间复杂度：<ul><li>  索引: O(n)</li><li>  搜索: O(n)</li><li>  插入: O(1)</li><li>  移除: O(1)</li></ul></li></ul><p>  -- 并发 –</p></li><li><p>  ArrayBlockingQueue： 基于书实现的一个有界阻塞对，大小不能重新定义，试图向一个满的队列添加元素的时候，就会受到阻塞，知道另一个方法从队列中取出元素。</p></li><li><p>  ConcurrentLinkedDeque、ConcurrentLinkedQueue：基于链表实现的无解队列，添加元素不阻塞。要求消费者的速度至少要比生产一样快，不然内存就会耗尽，严重依赖于CAS操作。</p></li><li><p>  DelayQueue ： 无界的保存Delayed元素的集合，元素只有在延时已经过期的时候才能被取出。队列的第一个元素延期最小(包含负值，延时已经过期)，要实现一个延期任务的队列的时候使用(不要自己手动实现–使用ScheduledThreadPoolExecutor)</p></li><li><p>  LinkedBlockingDeque/LinkedBlockingQueue： 可选择有界或者无界基于链表的实现。在队列为空或者满的情况下使用ReentrantLock</p></li><li><p>  LinkedTransferQueue: 基于链表的无界队列，除了通常的队列操作，还有一系列的transfer方法，可以让生产者直接给等待的消费者传递信息，这样就不用将元素存储到队列中了，这是一个基于CAS的无锁集合</p></li><li><p>  PriorityBlockingQueue：PriorityQueue的无界的版本。</p></li><li><p>  SynchronousQueue：一个有界队列，其中没有任何内存容量。这就意味着任何插入操作必须等到响应的取出操作才能执行，反之亦反。如果不需要Queue接口的话，通过Exchanger类也能完成响应的功能。</p></li></ul></li><li><p>Lists类</p><ul><li>  CopyOnWriteArrayList ： list的实现每一次都会产生一个新的隐含数组副本，所以这个操作成本很高，适合遍历操作比更新操作多的集合，例如listeners/observers集合</li></ul></li><li><p>Collections 工具类</p><ul><li>checked* : 检查要添加的元素的类型并返回结果，尝试添加非法类型的变量都会抛出一个ClassCastException<ul><li>  checkedCollection</li><li>  checkedList</li><li>  checkedMap</li><li>  checkSet</li><li>  checkedSortedMap</li><li>  checkedSortedSet</li></ul></li><li>empty* : 返回一个固定的空集合。<ul><li>  emptyList</li><li>  emptyMap</li><li>  emptySet</li></ul></li><li>singleton* : 返回一个只有一个入口的set、list、map集合<ul><li>  singletonList</li><li>  singletonMap</li></ul></li><li>synchronized* ： 获得集合的线程安全版本<ul><li>  synchronizedCollection</li><li>  synchronizedList</li><li>  synchronizedMap</li><li>  synchronizedSet</li><li>  synchronizedSortedMap</li><li>  synchronizedSortedSet</li></ul></li><li>unmodifiable* : 返回一个不可变的集合<ul><li>  unmodifiableCollection</li><li>  unmodifiableList</li><li>  unmodifiableMap</li><li>  unmodifiableSet</li><li>  unmodifiableSortedMap</li><li>  unmodifiableSortedSet</li></ul></li><li>  addAll : 添加一些元素或者一个数组的内容到集合中</li><li>  binarySearch ： 和数组的Arrays.binarySearch功能相同</li><li>  disjoint : 检查两个集合是不是没有相同元素</li><li>  fill ： 用一个指定的值代替集合中的所有元素</li><li>  frequency: 集合中有多少元素是和给定元素相同的。</li><li>  indexOfSubList、lastIndexOfSubList\indexOf\lashIndexOf 找出给定list中第一个出现和最后一个出现的子表</li><li>  max、min 找出基于自然顺序或者比较器排序的集合、最大或者最小的元素</li><li>  replaceAll： 替换所有</li><li>  reverse: 掉到排序元素和集合中的顺序</li><li>  rotate ： 根据给定的距离旋转元素</li><li>  shuffle： 随机排放List集合中的节点，而已给定自己的生成器</li><li>  sort ： 自然排序或者指定的排序器排序</li><li>  swap 交换集合中的两个元素的位置</li></ul></li><li><p>Arrays</p><ul><li>  Arrays.asList(): 可以将Array转换成List。</li><li>  Arrays.binarySearch : 在一个已排序的或者其中一段中快速查找</li><li>  Arrays.copyOf : 如果扩大数组容量又不想改变内容时候用这个方法</li><li>  Arrays.copyOfRange :  可以复制整个数组或者其中一个部分</li><li>  Arrays.deepEquals、Arrays.deepHashCode : Arrays.equals、hashCode的高级版本，支持子数据操作。</li><li>  Arrays.equals : 比较两个数组是否想相等。</li><li>  Arrays.fill  : 用一个给定的值填充整个数组或者其中一个部分</li><li>  Arrays.hashCode : 根据数组内容计算器hash值。</li><li>  Arrays.sort : 对整个数组或者数组一部分进行排序。</li><li>  Arrays.toString : 打印数组的内容</li><li>所有集合都可以用 T[] Collection.toArray(T[] a)方法复制到整个数组：<pre><code>return coll.toArray(new T[coll.size()]);</code></pre></li></ul></li></ul></li></ul><ul><li><p>并发和多线程</p><ul><li><p>参考：</p><ul><li>  <a href="https://github.com/CL0610/Java-concurrency">Java 并发知识合集</a></li><li>  <a href="https://github.com/CL0610/Java-concurrency/blob/master/Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.png">JAVA并发知识图谱</a></li><li>  java并发编程网</li><li>  <a href="http://www.importnew.com/18459.html">《40个Java多线程问题总结》</a></li><li>  <a href="https://www.cnblogs.com/zhanht/p/5450325.html">《Java并发编程——线程安全及解决机制简介》</a></li></ul></li><li><p>锁</p><ul><li>  ReetrantLock</li><li>  ReetranReadWriteLock</li><li>  Condition</li></ul></li><li><p>开发工具类</p><ul><li>  CyclicBarrier</li><li>  CountDownLatch</li><li>  Semphere</li></ul></li><li><p>并发集合</p><ul><li>  ConcurrentHashMap</li><li>  ConcurrentLinkedQueue</li></ul></li><li><p>线程池</p><ul><li>  Excutor</li><li>  ThreadPoolExcutor</li><li>  Callable和Future</li><li>  ScheduledExecutorService</li></ul></li><li><p>原子操作</p><ul><li>基本类型<ul><li>  AtomicBoolean</li><li>  AtomicInteger</li><li>  AtomicLong</li></ul></li><li>引用类型<ul><li>  AtomicReference</li><li>  AtomicReferenceArrayFieldUpdater</li></ul></li><li>数组<ul><li>  AtomicIntegerArray</li><li>  AtomicLongArray</li><li>  AtomicReferenceArray</li></ul></li></ul></li><li><p>synchronized</p><ul><li>  同步、重量级锁，synchronized原理</li><li>锁优化<ul><li>  自旋锁</li><li>  轻量级锁</li><li>  重量级锁</li><li>  偏向锁</li></ul></li></ul></li><li><p>  Lock机制</p></li><li><p>  线程通信</p></li><li><p>volatile</p><ul><li>  实现机制</li><li>  内存语义</li><li>  内存模型</li></ul></li><li><p>  ThreadLocal</p></li><li><p>  Fork\Join</p></li><li><p>  concurrent包</p></li><li><p>AQS</p><ul><li>  AbstractqueuedSynchronized同步器</li><li>  CLH同步队列</li><li>  同步状态的获取及释放</li><li>  线程阻塞和唤醒</li></ul></li><li><p>CAS</p><ul><li>  Compare And Swap缺陷</li></ul></li></ul></li><li><p>优化调优</p><ul><li>工具<ul><li>  MAT</li><li>  Jmeter</li></ul></li><li>理解性能优化<ul><li>  性能基准</li><li>  性能优化到底是什么</li><li>  衡量维度</li></ul></li><li>JVM调优<ul><li>  什么是JVM内存模型JMM</li><li>  各垃圾回收气使用场景</li><li>  理解GC日志</li><li>  实战MAT分析DUMP文件</li></ul></li><li>Tomcat调优<ul><li>  tomcat运行机制</li><li>  线程模型</li><li>  系统参数认识及调优</li><li>  基准测试</li></ul></li><li>MySQL调优<ul><li>  理解MySQL底层B+树</li><li>  SQL执行计划详解索引优化详解</li><li>  SQL语句优化</li></ul></li></ul></li><li><p>JVM</p><blockquote><p>《深入理解Java虚拟机：JVM高级特性与最佳实践》</p></blockquote><ul><li>内存模型<ul><li>  重排序</li><li>  顺序一致性</li><li>  happens-hefore</li><li>  as-if-serial</li></ul></li><li>  GC垃圾回收机制</li><li>  分代算法，GC算法</li><li>  收集器</li><li>  类加载、双亲委派</li><li>JVM调优<ul><li>  jvm参数</li></ul></li><li>  内存泄露和内存溢出</li></ul></li><li><p>  IO和NIO</p></li><li><p>  反射和代理、异常、java8、序列化</p></li><li><p>设计模式：</p><ul><li>24中常用的设计模式<ul><li>  proxy代理模式</li><li>  Factory工厂模式</li><li>  Singleton单例模式</li><li>  Delegate委派模式</li><li>  Strategy策略模式</li><li>  prototype原型模式</li><li>  Adapter适配器模式</li></ul></li><li>  java源码中或者spring中用到哪些</li></ul></li><li><p>web</p><ul><li>  servlet</li><li>  cookie、session</li><li>spring<ul><li>aop<ul><li>  AOP设计原理</li></ul></li><li>ioc<ul><li>  IOC容器设计原理及高级特性</li></ul></li><li>  FactoryBean与BeanFactory</li><li>  mvc</li><li>  <a href="https://earyant.github.io/2017/09/17/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/">事务</a></li><li>  基于SpringJDBC手写ORM框架</li><li>  SpringMVC九大组件</li><li>  手写实现SpringMVC框架</li><li>  SpringMVC与Struts2对比分析</li><li>  Spring5新特性</li><li>  动态代理</li></ul></li><li>mybatis<ul><li>  代码自动生成器</li><li>  关联查询、嵌套 查询</li><li>  缓存使用场景及选择策略</li><li>  Spring集成下的SqlSession与Mapper</li><li>  事务</li><li>  分析MyBatis的动态代理</li><li>  手写实现Mini版的MyBatis</li></ul></li><li>tomcat<ul><li>参考<ul><li>  <a href="https://www.cnblogs.com/hggen/p/6264475.html">《TOMCAT原理详解及请求过程》</a></li><li>  <a href="https://www.cnblogs.com/crazylqy/p/4706223.html">《Tomcat服务器原理详解》</a></li><li>  <a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/">《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》</a></li><li>  <a href="https://blog.csdn.net/xlgen157387/article/details/79006434">《四张图带你了解Tomcat系统架构》</a></li><li><a href="https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/">《JBoss vs. Tomcat: Choosing A Java Application Server》</a><ul><li>  Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。</li><li>  Jboss 实现全部了JEE特性，软件开源免费、文档收费。</li><li>  <a href="https://www.cnblogs.com/sunfenqing/p/7339058.html">《Tomcat 调优方案》</a></li><li>  启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）；</li><li>  <a href="http://blog.chinaunix.net/uid-20662363-id-3012760.html">《tomcat http协议与ajp协议》</a></li><li><a href="http://dmouse.iteye.com/blog/1354527">《AJP与HTTP比较和分析》</a><ul><li>  AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。</li><li>  并发高时，AJP协议优于HTTP协议。</li></ul></li></ul></li></ul></li><li>  类加载机制</li></ul></li><li>Jetty<ul><li>参考<ul><li>  <a href="https://www.ibm.com/developerworks/cn/java/j-lo-jetty/">《Jetty 的工作原理以及与 Tomcat 的比较》</a></li><li>  <a href="https://blog.csdn.net/doutao6677/article/details/51957288">《jetty和tomcat优势比较》</a></li></ul></li></ul></li><li>  hibernate</li></ul></li><li><p>  源码</p></li><li><p>  Guava</p></li></ul><h3><span id="脚本语言">脚本语言</span></h3><ul><li>  python</li><li>  shell</li></ul><h2><span id="架构">架构</span></h2><h3><span id="微服务">微服务</span></h3><ul><li><p>微框架</p><ul><li>  与微服务之间的关系</li><li>  热部署实战</li><li>  核心组件Starter\Actuator\AutoConfiguration\Cli</li><li>  集成Mybatis实现多数据源路由实战</li><li>  集成Dubbo实战</li><li>  集成Redis缓存实战</li><li>  集成Swagger2实战</li><li>  API管理及测试体系</li><li>  实现多环境配置动态解析</li></ul></li><li><p>SpringCloud</p><ul><li>注册中心<ul><li>  Eureka</li><li>  Zookeeper</li></ul></li><li>  Ribbon集成REST实现负载均衡</li><li>  Fegion生命是服务调用</li><li>  Hystrix服务熔断降级方式</li><li>  Zuul实现微服务网管</li><li>  Config分布式统一配置中心（与disconf作对比）</li><li>  Sleuth调用链路跟踪</li><li>  BUS消息总线</li><li>  基于Hystrix实现接口降级实战</li><li>  集成SpringCloud实现统一整合方案</li></ul></li><li><p>Docker虚拟化</p><ul><li>  Docker的镜像、仓库、容器</li><li>  Docker File文件</li><li>  Docker Compose</li><li>  Swarm K8s</li></ul></li><li><p>漫谈微服务架构</p><pre><code>  \-  SOA架构和微服务架构之间的区别和联系  \- 如何设计微服务及设计原则  \- 全局分析Spring Cloud各个组件所能解决的问题</code></pre><h3><span id="分布式">分布式</span></h3></li><li><p>分布式架构原理</p><ul><li>  分布式架构严谨过程</li><li>  如何把应用从单机扩展到分布式</li><li>  CDN加速静态文件访问</li><li>  系统监控、容灾、存储动态扩容</li><li>  架构设计及业务驱动划分</li><li>  CAP原理和BASE理论</li></ul></li><li><p>分布式架构策略</p><ul><li>  分布式架构网络通信原理剖析</li><li>  通信协议中的序列化和反序列化</li><li>基于框架的RPC技术<ul><li>  WebService、RMI、Hession</li></ul></li><li>  深入分析Zookeeper在disconf配置中心的应用</li><li>  基于Zookeeper实现分布式服务器动态上下线感知</li><li>  深入分析Zookeeper Zab协议及选举机制源码解读</li><li>  Dubbo管理中心及监控平台安装部署</li><li>  基于Dubbo的分布式系统架构实战</li><li>  Dubbo容错机制及高扩展性分析</li></ul></li><li><p>分布式架构中间件</p><ul><li>  分布式消息通信</li><li>  ActiveMq\Kafka\RabbitMQ</li><li>  Redis主从复制原理及无磁盘复制分析</li><li>  图解Redis中AOF和RDB持久化策略的原理</li><li>  MongoDb企业级集群解决方案</li><li>  MongoDb数据分片、转存及恢复策略</li><li>  基于OpenResty部署应用层Nginx以及Nginx+lua实践</li><li>  Nginx反向代理服务器及负载均衡服务配置实战</li><li>  基于Netty实现高性能IM聊天</li><li>  基于Netty实现Dubbo多协议通信支持</li><li>  Netty无锁化串行设计及高并发处理机制</li></ul></li><li><p>分布式架构实战</p><ul><li>  分布式全局ID生成方案</li><li>  Session跨域共享及企业级单点登录解决方案实战</li><li>  分布式事务解决方案实战</li><li>  高并发下的服务降级、限流实战</li><li>  基于分布式架构下的分布式锁的解决方案实战</li><li>  分布式架构下实现分布式定时调度</li></ul></li><li><p>  NoSql和KV存储(redis,hbase,mongodb,etcd,springcloud)</p></li><li><p>  负载均衡(原理，cdn，一致性hash)</p></li><li><p>RPC框架</p><ul><li>  通信 netty</li><li>  序列化协议 thrift，protobuff</li></ul></li><li><p>消息队列</p><ul><li>  原理</li><li>  kafka</li><li>  activeMQ</li><li>  rocketMQ</li></ul></li><li><p>分布式存储系统</p><ul><li>  GFS</li><li>  HDFS</li><li>  fastDFS</li><li>存储模型<ul><li>  skipList</li><li>  LSM</li></ul></li></ul></li><li><p>分布式事务</p><ul><li>  redis分布锁</li></ul></li><li><p>分布式锁</p><h3><span id="大数据">大数据</span></h3></li><li><p>hadoop生态圈</p><ul><li>  hive</li><li>  hbase</li><li>  hdfs</li><li>  zoopkeeper</li><li>  storm</li><li>  kafka</li></ul></li><li><p>  spark</p></li><li><p>  搜索引擎与技术</p></li><li><p>  机器学习与技术</p></li><li><p>  人工智能</p></li></ul><h3><span id="运维-amp-统计-amp-技术支持">运维 &amp; 统计 &amp; 技术支持</span></h3><ul><li><p>常规监控</p><ul><li><p><a href="https://blog.csdn.net/enweitech/article/details/77849205">《腾讯业务系统监控的修炼之路》</a></p><ul><li>  监控的方式：主动、被动、旁路(比如舆情监控)</li><li>  监控类型： 基础监控、服务端监控、客户端监控、 监控、用户端监控</li><li>  监控的目标：全、块、准</li><li>  核心指标：请求量、成功率、耗时</li></ul></li><li><p><a href="https://www.oschina.net/news/67525/monitoring-tools">《开源还是商用？十大云运维监控工具横评》</a></p><blockquote><p>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。</p></blockquote></li><li><p>  <a href="http://developer.51cto.com/art/201612/525373.htm">《监控报警系统搭建及二次开发经验》</a></p></li></ul></li><li><p>命令行监控工具</p><ul><li>  <a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html">《常用命令行监控工具》</a></li><li>  <a href="http://blog.jobbole.com/96846/">《20个命令行工具监控 Linux 系统性能》</a></li><li>  <a href="https://my.oschina.net/feichexia/blog/196575">《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》</a></li><li>  <a href="https://earyant.github.io/2018/05/04/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">日志分析常用命令</a></li><li>  <a href="https://earyant.github.io/2018/05/04/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E8%84%9A%E6%9C%AC/">日志分析脚本</a></li></ul></li><li><p>统计分析</p><ul><li><a href="https://zhuanlan.zhihu.com/p/25195217">《流量统计的基础：埋点》</a><blockquote><p>常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度</p></blockquote></li><li><a href="http://www.25xt.com/company/17066.html">《APP埋点常用的统计工具、埋点目标和埋点内容》</a><blockquote><p>第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。</p></blockquote></li><li><a href="https://tech.meituan.com/mt-mobile-analytics-practice.html">《美团点评前端无痕埋点实践》</a><blockquote><p>所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。</p></blockquote></li></ul></li><li><p>持续集成(CI/CD)</p><ul><li>  <a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">《持续集成是什么？》</a></li><li>  <a href="https://www.testwo.com/article/1170">《8个流行的持续集成工具》</a></li><li>  <a href="https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000">《使用Jenkins进行持续集成》</a></li></ul></li><li><p>环境分离</p><ul><li>  <a href="https://my.oschina.net/sancuo/blog/214904">《开发环境、生产环境、测试环境的基本理解和区》</a></li></ul></li></ul><h3><span id="测试">测试</span></h3><ul><li>TDD 理论<ul><li>-<a href="https://www.jianshu.com/p/62f16cd4fef3">《深度解读 - TDD（测试驱动开发）》</a><ul><li>  基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.</li><li>  好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈；</li></ul></li></ul></li><li>单元测试<ul><li>  <a href="https://www.cnblogs.com/happyzm/p/6482886.html">《Java单元测试之JUnit篇》</a></li><li>  <a href="TestNG%20%E8%A6%86%E7%9B%96%20JUnit%20%E5%8A%9F%E8%83%BD%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E5%9C%BA%E6%99%AF%E3%80%82">《JUnit 4 与 TestNG 对比》</a></li><li>  <a href="%E6%A8%A1%E5%9D%97%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E3%80%81%E5%B1%80%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B5%8B%E8%AF%95%E3%80%81%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95%20%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%B5%8B%E8%AF%95%E3%80%81%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95%20%E3%80%82">《单元测试主要的测试功能点》</a></li></ul></li><li>压力测试<ul><li>  <a href="https://blog.csdn.net/blueheart20/article/details/52170790">《Apache ab 测试使用指南》</a></li><li>  <a href="https://www.cnblogs.com/binyue/p/6141088.html">《大型网站压力测试及优化方案》</a></li><li>  <a href="http://news.chinabyte.com/466/14126966.shtml">《10大主流压力/负载/性能测试工具推荐》</a></li><li>  <a href="http://quentinxxz.iteye.com/blog/2249799">《真实流量压测工具 tcpcopy应用浅析》</a></li><li>  <a href="https://www.cnblogs.com/jwentest/p/7136727.html">《nGrinder 简易使用教程》</a></li></ul></li><li>全链路压测<ul><li>  <a href="http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot">《京东618：升级全链路压测方案，打造军演机器人ForceBot》</a></li><li>  <a href="https://zhuanlan.zhihu.com/p/30306892">《饿了么全链路压测的探索与实践》</a></li><li>  <a href="https://zhuanlan.zhihu.com/p/28355759">《四大语言，八大框架｜滴滴全链路压测解决之道》</a></li><li>  <a href="https://www.jianshu.com/p/27060fd61f72">《全链路压测经验》</a></li></ul></li><li>A/B 、灰度、蓝绿测试<ul><li>  <a href="https://testerhome.com/topics/11165">《技术干货 | AB 测试和灰度发布探索及实践》</a></li><li>  <a href="http://blog.51cto.com/purplegrape/1403123">《nginx 根据IP 进行灰度发布》</a></li><li>  <a href="https://www.v2ex.com/t/344341">《蓝绿部署、A/B 测试以及灰度发布》</a></li></ul></li></ul><h2><span id="书单">书单</span></h2><ul><li>算法与数据结构<ul><li>  数据结构（严蔚敏）/大话数据结构              * 剑指Offer/程序员面试金典/编程珠玑/编程之美/牛客网+leetcode</li><li>  程序员笔试面试最优解（左程云）/不如直接看左神的笔试面试指南视频</li><li>  数据结构与算法经典问题解析（Java语言描述）</li><li>  图解数据结构（使用Java）</li></ul></li><li>计算机网络：<ul><li>  计算机网络（谢希仁）</li><li>  TCP/IP 详解</li><li>  HTTP权威指南</li><li>  图解TCP/IP</li><li>  图解HTTP</li></ul></li><li>数据库：//数据库主要是多用，书上主要看索引和性能的部分<ul><li>  高性能MySQL/深入浅出MySQL</li></ul></li><li>操作系统：<ul><li>  OS原理：操作系统（课本，黑色的那个）</li><li>Linux：<ul><li>  Linux私房菜 //鸟哥写的，很全，包括bash部分</li><li>  跟阿铭学Linux //主要偏重于命令和操作，比较浅显</li></ul></li></ul></li><li>java：<ul><li>  Java疯狂讲义/Java编程思想/Java核心技术 卷1</li><li>  深入理解Java虚拟机</li><li>  并发编程的艺术/多线程编程核心技术</li><li>  Effective Java</li><li>  Java程序员面试笔试宝典 //何昊的那本，个人感觉是突击知识点的神器</li><li>  Java程序性能优化</li><li>  实战Java高并发程序设计</li></ul></li><li>Java Web：<ul><li>  Spring实战/轻量级JavaEE 企业应用（红皮，讲SSH的） //主要看最后一部分Spring的就可以</li><li>  深入JavaWeb技术内幕（阿里 许令波）//这个讲的还是比较深的</li><li>  SpringBoot实战/深入实践SpringBoot</li></ul></li><li>设计模式：<ul><li>  大话设计模式 //通俗易懂</li><li>  各类博客的总结</li></ul></li><li>分布式与大数据：<ul><li>  分布式服务框架原理与实践</li><li>  大型网站技术架构</li><li>  Hadoop实战（hadoop体系包括得很全）</li></ul></li><li>其他：<ul><li>Git：<ul><li>  Git权威指南</li><li>  Git官方讲解视频（牛客网有带字幕的）</li></ul></li><li>Redis：<ul><li>  Redis实战</li></ul></li></ul></li><li>  docker</li><li>  springcloud</li></ul><h2><span id="实战">实战</span></h2><h3><span id="实践一个双十一电商项目">实践一个双十一电商项目</span></h3><ul><li>用户认证<ul><li>  用户注册</li><li>  SSO单点登录</li><li>  第三方登陆</li><li>  UI界面拦截</li><li>  业务拦截</li></ul></li><li>店铺、商品<ul><li>  聚合检索</li><li>  动静分离</li><li>  店铺管理</li><li>  商品管理</li></ul></li><li>订单、支付<ul><li>  订单号统一生成规则</li><li>  下单流程管理</li><li>  库存管理</li><li>  购物车</li><li>  优惠券支付</li><li>  积分支付</li><li>  第三方支付</li></ul></li><li>数据统计分析<ul><li>  用户行为分析</li><li>  行业分析</li><li>  区域分析</li></ul></li><li>通知推送<ul><li>  融云推送</li><li>  消息中间件</li><li>  用户群聊</li><li>  点对点聊天</li><li>  文件断点续传</li></ul></li></ul><p>感谢：<br><a href="https://www.nowcoder.com/discuss/29890?hmsr=toutiao.io&source=rss&utm-medium=toutiao.io&utm-source=toutiao.io">这可能不只是一篇面经</a><br><a href="https://github.com/kdn251/interviews/blob/master/README-zh-cn.md">java整理</a><br><a href="https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98">后端架构师技术图谱</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高可用+高并发+负载均衡架构设计(转发)</title>
      <link href="/posts/%E9%AB%98%E5%8F%AF%E7%94%A8-%E9%AB%98%E5%B9%B6%E5%8F%91-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E8%BD%AC%E5%8F%91/"/>
      <url>/posts/%E9%AB%98%E5%8F%AF%E7%94%A8-%E9%AB%98%E5%B9%B6%E5%8F%91-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E8%BD%AC%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651960393&idx=1&sn=23cf8438b436c531c81b3f09a3d5e8fb&chksm=bd2d01958a5a88838e6ef493ccb1fe0854f7216f3863fbe9798eec5019dc58d73d4e95b3132f&mpshare=1&scene=1&srcid=09082gOCvZ5mjeN9YZ8HSg0o#rd" alt="原地址"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微信机器人流程</title>
      <link href="/posts/%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/posts/%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>[TOC]</p><h2><span id="获取uuid和二维码">获取uuid和二维码：</span></h2><ul><li>在公众号输入8，即可返回二维码图片；<ul><li>生成uuid；</li><li>生成二维码；</li><li>redis中保存要登陆用户的信息；</li><li>返回二维码。</li></ul></li></ul><h2><span id="后台守护进程">后台守护进程：</span></h2><ul><li>开启一个守护线程：<ul><li>获取redis中保存的用户信息；</li><li>判断如果未登陆则继续执行以下操作，如果已经登陆了，返回，不做任何操作。</li><li>loginService.login()<ul><li>代码登陆逻辑，如果登陆了，将状态setAlive置为已经登陆，若未登陆，sleep1秒继续。</li><li>将联系人信息保存到redis中</li></ul></li><li>webWxInit()<ul><li>获取user信息，并保存到数据库。</li><li>获取用户的联系人信息，并保存到数据库；</li><li>获取SyncKeyBean信息，并保存到数据库；</li></ul></li><li>wxStatusNotify()<ul><li>微信通知状态改变，手机端提示网页端登陆成功。</li></ul></li><li>startReceiving()<ul><li>开启消息接收。</li><li>开启新线程：<ul><li>syncCheck() 检查是否有新消息<ul><li>状态为0(收到正常报文)：<ul><li>webWxSync() 联网获取新消息；<ul><li>通过初始化过去的SyncKey参数进行获取，返回成功后，要把新返回的SyncKey保存到数据库中，下次用新SyncKey进行获取新信息。</li><li>对获取到的新信息进行操作。 MsgCenter.produceMsg();</li><li>保存消息到数据库。</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>webWxGetContact() 获取好友列表</li><li>WebWxBatchGetContact()</li><li>setUserInfo() 缓存本次好友信息。</li><li>CheckLoginStatusThread开启登陆状态线程。</li></ul></li></ul><h2><span id="20170904">2017.09.04</span></h2><p>  做好微信机器人，在微信公众平台界面发送8将返回一个二维码，扫码登陆后即可开启机器人。<br>  机器人功能： //TODO<br>    * 集成聊天机器人功能。<br>    * 备份聊天记录。<br>    * 爬取所有用户，并分析用户联系人的男女比例，整合头像。<br>    * 爬取公众号文章。<br>    * 撤回消息备份<br>    * 关键词监听<br>    * 消息搜索<br>    * 信息分析<br>    * 查看/删除文件[文件名] e.g. 查看文件[123345234.mp3]<br>    * 撤回附件列表 (查看都有哪些保存在电脑中的已撤回附件)<br>    * 清空附件列表 (清空已经保存在电脑中的附件)<br>    * 添加关键词[关键词] e.g. 设置关键词[在不在]<br>    * 删除关键词[关键词] e.g. 删除关键词[在不在]<br>    * 清空关键词 清空已经设置的所有关键词<br>    * 查看关键词 查看目前设置的关键词<br>    * 添加签到口令#公众号:签到口令# e.g. 添加签到口令#招商银行信用卡:签到#<br>    * 删除签到口令#公众号# e.g. 删除签到口令#招商银行信用卡#<br>    * 查看签到口令 查看已经存在的公众和和对应的签到口令<br>    * 清空签到口令 清空所有签到口令<br>    * 截图 截取当前屏幕发送到文件助手<br>    * 添加自动回复#针对的关键词:回复内容# e.g.添加自动回复#在不在:我现在有事情，待会儿回复你#<br>    * 删除自动回复#针对的关键词# e.g.删除自动回复#在不在#<br>    * 清空自动回复 清空所有的自定义回复规则<br>    * 关闭自动回复<br>    * 打开自动回复<br>    * 退出程序</p><h2><span id="备份聊天功能">备份聊天功能：</span></h2><pre><code>* 发送 “开启**回复” 即可回复 ** 信息  后台将配置记录到sql中，并缓存到redis中。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql引擎myisam和innodb的异同</title>
      <link href="/posts/Mysql%E5%BC%95%E6%93%8Emyisam%E5%92%8Cinnodb%E7%9A%84%E5%BC%82%E5%90%8C/"/>
      <url>/posts/Mysql%E5%BC%95%E6%93%8Emyisam%E5%92%8Cinnodb%E7%9A%84%E5%BC%82%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="myisam和innodb不同之处">myisam和innodb不同之处</span></h2><ul><li>1事务的支持不同：<ul><li>innodb支持事务；</li><li>myisam不支持事务；</li></ul></li><li>2锁粒度<ul><li>indodb行锁应用</li><li>myisam表锁</li></ul></li><li>3存储空间<ul><li>innodb既缓存索引文件又缓存数据文件；</li><li>myisam只缓存索引文件。</li></ul></li><li>4存储结构<ul><li>myisam数据文件的扩展名为.myd myData，索引文件的扩展名是.myi myIndex</li><li>innodb所有的表都保存在同一个数据文件里面 即为 .ibd</li></ul></li><li>统计记录行数<ul><li>myisam保存表的总行数，select count(*) from table 会直接取出该值</li><li>innodb没有保存表的中行书，select count(*) from table 就会遍历整个表，消耗相当大。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap全解析</title>
      <link href="/posts/HashMap%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
      <url>/posts/HashMap%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="定义">定义</span></h1><p>HashMap实现了Map接口，继承自AbstactMap。其中Map接口定义了键映射到值的规则。<br>    public class HashMap&lt;K,V&gt;<br>    extends AbstractMap&lt;K,V&gt;<br>    implements Map&lt;K,V&gt;, Cloneable, Serializable<br>    <img src="../img/java.util.map%E7%B1%BB%E5%9B%BE.png"><br><em>注意</em><br>    * HashMap: 它根据键的hashCode值存储数据，大多数情况下可以直接定位到他的值，因此有很乖的访问速度，但是遍历的顺序是不确定的，HashMap最多只允许一条记录为null，允许多条记录的值为null，HashMap不是线程安全的，即任意时刻有多线程同时写HashMap可能会导致数据不一致问题。<br>    * HashTable: HashTable是遗留类，很多映射的功能和HashMap类似，但是他是继承自Dictionary类，并且是线程安全的，任何时间只有一个线程能写hashTable。<br>    * ConcurrentHashMap：<br>    * LinkedHashMap: 是HashMap的一个自雷，保存了插入顺序，在用iterator遍历LinkedHashMap时，先得到的肯定是新插入的，也可以在构造式带参数，按照访问次数进行排序。<br>    * TreeMap: TreeMap实现了SortMap接口，能够把保存的记录根据键排序，默认是按照键值升序排序，也可以指定排序的比较器，在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出ClassCastExeption。</p><h1><span id="构造函数">构造函数</span></h1><ul><li>HashMap()：默认构造器，构造一个初始容量为10和默认加载银子为0.75的空HashMap</li><li>HashMap(int initialCapacity):构造一个指定容量的和默认加载银子为0.75的空HashMap</li><li>HashMap(int initialCapacity, float loadFactor)： 构造一个指定初始容量和加载银子的空HashMap；<br>*其中initialCapacity不能小于0，当它大于1 &lt;&lt; 30的时候，它就等于1 &lt;&lt; 30*<br>   if (initialCapacity &gt; MAXIMUM_CAPACITY)<pre><code>      initialCapacity = MAXIMUM_CAPACITY;</code></pre></li></ul><p>初始容量：代表哈希表中通的数量，<br>加载因子： 代表哈希表在自动增加之前可以达到的尺度。</p><h1><span id="数据结构">数据结构</span></h1><p>列表散列：<br><img src="http://images.cnitblog.com/blog/381060/201401/152128351581.png"><br>数组+链表+红黑树(jdk8中增加红黑树)<br><img src="../img/hashMap%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"><br>HashMap的底层实现还是数组，只不过数组的每一项都是一条链，其中initialCapacity参数代表了该数组额长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段表示将初始容量变成向下靠近2的幂次方的数。</p><h1><span id="node">Node</span></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是一个映射（键值对）。</p><p>HashMap就是使用哈希表来存储的，哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，java中HashMap采用了链地址法，简单来说就是数组加链表的结合。在每个数组元素都是一个链表结构，当数据被hash后，得到数组下标，把数据放在对应下标元素的链表上，例如：<br>    <code>map.put(&quot;name&quot;,&quot;earyant&quot;)</code><br>系统将”name”这个key的HashCode()方法得到其hashCode值，然后再通过Hash算法的后两步运算（高位运算和取模运算）来定位该键值对应的存储位置，有时候两个key会定位到相同的位置，表示发生了Hash碰撞，当然hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map存取效率就会更高。<br>如果哈希桶数很大，即使较差的hash算法也会比较分散，如果哈希桶数组很小，就很容易发生碰撞。</p><h1><span id="容量">容量</span></h1><p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int threshold;             // 所能容纳的key-value对极限</span><br><span class="line">final float loadFactor;    // 负载因子</span><br><span class="line">int modCount;</span><br><span class="line">int size;</span><br></pre></td></tr></table></figure><p>首先，Node[] table的初始化长度length为默认16，loadFactor为负载因子，默认为0.75.threshold是HashMap所能容纳的最大数据量的Node（键值对）个数。threshold=length*loadFactor，也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p><ul><li>size：实际存在的键值对数量</li><li>threshold：length*loadFactor</li><li>modCount：记录HashMap内部结构发生裱花的次数，主要用于迭代的快速失败，内部结构变化指的是结构发生变化，比如put，但是某个key对应的value值被覆盖部署于结构变化。</li></ul><p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159%EF%BC%8CHashtable%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A1%B6%E5%A4%A7%E5%B0%8F%E4%B8%BA11%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%A1%B6%E5%A4%A7%E5%B0%8F%E8%AE%BE%E8%AE%A1%E4%B8%BA%E7%B4%A0%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88Hashtable%E6%89%A9%E5%AE%B9%E5%90%8E%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E8%BF%98%E6%98%AF%E7%B4%A0%E6%95%B0%EF%BC%89%E3%80%82HashMap%E9%87%87%E7%94%A8%E8%BF%99%E7%A7%8D%E9%9D%9E%E5%B8%B8%E8%A7%84%E8%AE%BE%E8%AE%A1%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E4%B8%BA%E4%BA%86%E5%9C%A8%E5%8F%96%E6%A8%A1%E5%92%8C%E6%89%A9%E5%AE%B9%E6%97%B6%E5%81%9A%E4%BC%98%E5%8C%96%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B8%BA%E4%BA%86%E5%87%8F%E5%B0%91%E5%86%B2%E7%AA%81%EF%BC%8CHashMap%E5%AE%9A%E4%BD%8D%E5%93%88%E5%B8%8C%E6%A1%B6%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE%E6%97%B6%EF%BC%8C%E4%B9%9F%E5%8A%A0%E5%85%A5%E4%BA%86%E9%AB%98%E4%BD%8D%E5%8F%82%E4%B8%8E%E8%BF%90%E7%AE%97%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82">http://blog.csdn.net/liuqiyao_01/article/details/14475159，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</a></p><p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考。<br><a href="http://blog.csdn.net/v_july_v/article/details/6105630%E3%80%82">http://blog.csdn.net/v_july_v/article/details/6105630。</a></p><p>#方法</p><ul><li><p>确定哈希桶数组索引位置。<br>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 方法一：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p></li></ul><p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p><ul><li>put方法<br>![](../img/hashMap put方法执行流程图.png)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> <span class="number">4</span> &#125;</span><br><span class="line"> <span class="number">5</span></span><br><span class="line"> <span class="number">6</span> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="number">7</span>                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"> <span class="number">8</span>     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"> <span class="number">9</span>     <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line"><span class="number">10</span>     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"><span class="number">11</span>         n = (tab = resize()).length;</span><br><span class="line"><span class="number">12</span>     <span class="comment">// 步骤②：计算index，并对null做处理</span></span><br><span class="line"><span class="number">13</span>     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">14</span>         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">15</span>     <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">16</span>         Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="number">17</span>         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line"><span class="number">18</span>         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">19</span>             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">20</span>             e = p;</span><br><span class="line"><span class="number">21</span>         <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line"><span class="number">22</span>         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">23</span>             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="number">24</span>         <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line"><span class="number">25</span>         <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">26</span>             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="number">27</span>                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">28</span>                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line"><span class="number">29</span>                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line"><span class="number">30</span>                         treeifyBin(tab, hash);</span><br><span class="line"><span class="number">31</span>                     <span class="keyword">break</span>;</span><br><span class="line"><span class="number">32</span>                 &#125;</span><br><span class="line">                    <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line"><span class="number">33</span>                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">34</span>                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))                                            <span class="keyword">break</span>;</span><br><span class="line"><span class="number">36</span>                 p = e;</span><br><span class="line"><span class="number">37</span>             &#125;</span><br><span class="line"><span class="number">38</span>         &#125;</span><br><span class="line"><span class="number">40</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="number">41</span>             V oldValue = e.value;</span><br><span class="line"><span class="number">42</span>             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">43</span>                 e.value = value;</span><br><span class="line"><span class="number">44</span>             afterNodeAccess(e);</span><br><span class="line"><span class="number">45</span>             <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">46</span>         &#125;</span><br><span class="line"><span class="number">47</span>     &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">48</span>     ++modCount;</span><br><span class="line"><span class="number">49</span>     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line"><span class="number">50</span>     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line"><span class="number">51</span>         resize();</span><br><span class="line"><span class="number">52</span>     afterNodeInsertion(evict);</span><br><span class="line"><span class="number">53</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">54</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#扩容（resize）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">    <span class="number">2</span>     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line"> <span class="number">5</span>         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line"> <span class="number">6</span>         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">7</span>     &#125;</span><br><span class="line"> <span class="number">8</span></span><br><span class="line"> <span class="number">9</span>     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line"><span class="number">10</span>     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line"><span class="number">11</span>     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line"><span class="number">12</span>     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line"> <span class="number">5</span>         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line"> <span class="number">6</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">7</span>             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line"> <span class="number">8</span>             <span class="keyword">do</span> &#123;</span><br><span class="line"> <span class="number">9</span>                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line"><span class="number">10</span>                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line"><span class="number">11</span>                 e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line"><span class="number">12</span>                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line"><span class="number">13</span>                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line"><span class="number">14</span>             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line"><span class="number">15</span>         &#125;</span><br><span class="line"><span class="number">16</span>     &#125;</span><br><span class="line"><span class="number">17</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="感谢参考">感谢参考</span></h2><p><a href="http://www.importnew.com/20386.html">参考</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>这可能不只是一篇面经(转发)</title>
      <link href="/posts/%E8%BF%99%E5%8F%AF%E8%83%BD%E4%B8%8D%E5%8F%AA%E6%98%AF%E4%B8%80%E7%AF%87%E9%9D%A2%E7%BB%8F-%E8%BD%AC%E5%8F%91/"/>
      <url>/posts/%E8%BF%99%E5%8F%AF%E8%83%BD%E4%B8%8D%E5%8F%AA%E6%98%AF%E4%B8%80%E7%AF%87%E9%9D%A2%E7%BB%8F-%E8%BD%AC%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://www.nowcoder.com/discuss/29890?hmsr=toutiao.io&source=rss&utm_medium=toutiao.io&utm_source=toutiao.io">原文链接在此</a></p><p>mark，有很多地方还是需要学习的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud使用docker部署注册eureka找不到地址</title>
      <link href="/posts/SpringCloud%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E6%B3%A8%E5%86%8Ceureka%E6%89%BE%E4%B8%8D%E5%88%B0%E5%9C%B0%E5%9D%80/"/>
      <url>/posts/SpringCloud%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E6%B3%A8%E5%86%8Ceureka%E6%89%BE%E4%B8%8D%E5%88%B0%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>跟随大神学习SpringCloud的时候，在使用docker部署时，遇到了提供者注册不到eureka上去，<a href="http://blog.csdn.net/forezp/article/details/70198649#reply">教程地址在此</a></p><p>之后我搜了下docker进程间通信找到了一个<strong>解决办法</strong>：</p><p>我弄了一整天也是一直注册不进去，后来又搜了搜docker进程间通信，发现一个方法，<br>eureka-server部署的时候给一个名字： docker run –name eureka-server -p 8761:8761<br>server-hi中部署使用link参数 docker run –link eureka-server（server部署时赋予的名字）:eureka-server(配置中写的地址) ……<br>注册不进去的可以试试。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库的count的区别</title>
      <link href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84count%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84count%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springBot配置大全（转载）</title>
      <link href="/posts/springBot%E9%85%8D%E7%BD%AE%E5%A4%A7%E5%85%A8%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <url>/posts/springBot%E9%85%8D%E7%BD%AE%E5%A4%A7%E5%85%A8%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>七大查找算法</title>
      <link href="/posts/%E4%B8%83%E5%A4%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/posts/%E4%B8%83%E5%A4%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://blog.jobbole.com/111629/">原文链接</a></p><h3><span id="查找算法分类">查找算法分类：</span></h3><ul><li>1）静态查找和动态查找；<br> 注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。</li><li>2）无序查找和有序查找。<ul><li>无序查找：被查找数列有序无序均可；</li><li>有序查找：被查找数列必须为有序数列。</li></ul></li></ul><h2><span id="1-顺序查找">1. 顺序查找</span></h2><p>   挨个查找，不用多说，时间复杂度为O(n);</p><h2><span id="2-二分查找">2. 二分查找</span></h2><ul><li>说明元素必须是有序的，如果是无序的则要先进行排序操作。</li><li>基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。     </li><li>复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    //二分查找（折半查找），版本1</span><br><span class="line">int BinarySearch1(int a[], int value, int n)</span><br><span class="line">&#123;</span><br><span class="line"> int low, high, mid;</span><br><span class="line"> low = 0;</span><br><span class="line"> high = n-1;</span><br><span class="line"> while(low&lt;=high)</span><br><span class="line"> &#123;</span><br><span class="line">     mid = (low+high)/2;</span><br><span class="line">     if(a[mid]==value)</span><br><span class="line">     return mid;</span><br><span class="line">     if(a[mid]&gt;value)</span><br><span class="line">     high = mid-1;</span><br><span class="line">     if(a[mid]&lt;value)</span><br><span class="line">     low = mid+1;</span><br><span class="line"> &#125;</span><br><span class="line">     return -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//二分查找，递归版本</span><br><span class="line">int BinarySearch2(int a[], int value, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">   int mid = low+(high-low)/2;</span><br><span class="line">   if(a[mid]==value)</span><br><span class="line">   return mid;</span><br><span class="line">   if(a[mid]&gt;value)</span><br><span class="line">   return BinarySearch2(a, value, low, mid-1);</span><br><span class="line">   if(a[mid]&lt;value)</span><br><span class="line">   return BinarySearch2(a, value, mid+1, high);</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 3. 插值查找</span><br><span class="line"></span><br><span class="line">在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？</span><br><span class="line"></span><br><span class="line">打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。&lt;</span><br><span class="line"></span><br><span class="line">同样的，比如要在取值范围1 ~ 10000 之间 100 个元素从小到大均匀分布的数组中查找5， 我们自然会考虑从数组下标较小的开始查找。</span><br><span class="line"></span><br><span class="line">经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：</span><br><span class="line"></span><br><span class="line">mid=(low+high)/2, 即mid=low+1/2*(high-low);</span><br><span class="line"></span><br><span class="line">通过类比，我们可以将查找的点改进为如下：</span><br><span class="line"></span><br><span class="line">mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，</span><br><span class="line"></span><br><span class="line">也就是将上述的比例参数1/2改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。</span><br><span class="line"></span><br><span class="line">* 基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。</span><br><span class="line"></span><br><span class="line">* 注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</span><br><span class="line">**如果分布比较均匀，插值查找比二分查找快，如果分布不均匀，二分查找比较快**</span><br><span class="line">* 复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。</span><br><span class="line"></span><br></pre></td></tr></table></figure>//插值查找<br>int InsertionSearch(int a[], int value, int low, int high)<br>{<br>int mid = low+(value-a[low])/(a[high]-a[low])*(high-low);<br>if(a[mid]==value)<br>   return mid;<br>if(a[mid]&gt;value)<br>   return InsertionSearch(a, value, low, mid-1);<br>if(a[mid]&lt;value)<br>   return InsertionSearch(a, value, mid+1, high);<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 4. 斐波那契查找</span><br><span class="line"></span><br><span class="line">在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。</span><br><span class="line"></span><br><span class="line">黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。</span><br><span class="line"></span><br><span class="line">0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。</span><br><span class="line"></span><br><span class="line">大家记不记得斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。</span><br><span class="line"></span><br><span class="line">相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：</span><br><span class="line">   * 1）相等，mid位置的元素即为所求</span><br><span class="line"></span><br><span class="line">   * 2）&gt;，low=mid+1;</span><br><span class="line"></span><br><span class="line">   * 3）&lt;，high=mid-1。</span><br><span class="line"></span><br><span class="line">斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;</span><br><span class="line"></span><br><span class="line">开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</span><br><span class="line"></span><br><span class="line">   * 1）相等，mid位置的元素即为所求</span><br><span class="line"></span><br><span class="line">   * 2）&gt;，low=mid+1,k-=2;</span><br><span class="line"></span><br><span class="line">说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。</span><br><span class="line"></span><br><span class="line">   * 3）&lt;，high=mid-1,k-=1。</span><br><span class="line"></span><br><span class="line">说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。</span><br><span class="line"></span><br><span class="line">复杂度分析：最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。</span><br><span class="line"></span><br><span class="line">```const int max_size=20;//斐波那契数组的长度</span><br><span class="line">    </span><br><span class="line">   /*构造一个斐波那契数组*/</span><br><span class="line">   void Fibonacci(int * F)</span><br><span class="line">   &#123;</span><br><span class="line">      F[0]=0;</span><br><span class="line">      F[1]=1;</span><br><span class="line">      for(int i=2;i&lt;max_size;++i)</span><br><span class="line">      F[i]=F[i-1]+F[i-2];</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   /*定义斐波那契查找法*/</span><br><span class="line">   int FibonacciSearch(int *a, int n, int key) //a为要查找的数组,n为要查找的数组长度,key为要查找的关键字</span><br><span class="line">   &#123;</span><br><span class="line">      int low=0;</span><br><span class="line">      int high=n-1;</span><br><span class="line">    </span><br><span class="line">      int F[max_size];</span><br><span class="line">      Fibonacci(F);//构造一个斐波那契数组F</span><br><span class="line">    </span><br><span class="line">      int k=0;</span><br><span class="line">      while(n&gt;F[k]-1)//计算n位于斐波那契数列的位置</span><br><span class="line">      ++k;</span><br><span class="line">    </span><br><span class="line">      int * temp;//将数组a扩展到F[k]-1的长度</span><br><span class="line">      temp=new int [F[k]-1];</span><br><span class="line">      memcpy(temp,a,n*sizeof(int));</span><br><span class="line">    </span><br><span class="line">      for(int i=n;i&lt;F[k]-1;++i)</span><br><span class="line">      temp[i]=a[n-1];</span><br><span class="line">    </span><br><span class="line">      while(low&lt;=high)</span><br><span class="line">   &#123;</span><br><span class="line">      int mid=low+F[k-1]-1;</span><br><span class="line">      if(key&lt;temp[mid])</span><br><span class="line">   &#123;</span><br><span class="line">      high=mid-1;</span><br><span class="line">      k-=1;</span><br><span class="line">   &#125;</span><br><span class="line">      else if(key&gt;temp[mid])</span><br><span class="line">   &#123;</span><br><span class="line">      low=mid+1;</span><br><span class="line">      k-=2;</span><br><span class="line">   &#125;</span><br><span class="line">      else</span><br><span class="line">   &#123;</span><br><span class="line">      if(mid&lt;n)</span><br><span class="line">      return mid; //若相等则说明mid即为查找到的位置</span><br><span class="line">      else</span><br><span class="line">      return n-1; //若mid&gt;=n则说明是扩展的数值,返回n-1</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">      delete [] temp;</span><br><span class="line">      return -1;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">      int main()</span><br><span class="line">   &#123;</span><br><span class="line">      int a[] = &#123;0,16,24,35,47,59,62,73,88,99&#125;;</span><br><span class="line">      int key=100;</span><br><span class="line">      int index=FibonacciSearch(a,sizeof(a)/sizeof(int),key);</span><br><span class="line">      cout&lt;&lt;key&lt;&lt;&quot; is located at:&quot;&lt;&lt;index;</span><br><span class="line">      return 0;</span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure></li></ul><h2><span id="5-树表查找">5. 树表查找</span></h2><p>  ###5.1 最简单的树表查找算法——二叉树查找算法。</p><ul><li>基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；3）任意节点的左、右子树也分别为二叉查找树。二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。不同形态的二叉查找树如下图所示：</li><li>复杂度分析：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</li></ul><p>基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。</p><h3><span id="52-平衡查找树之2-3查找树2-3-tree">5.2 平衡查找树之2-3查找树（2-3 Tree）</span></h3><p>2-3查找树定义：和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：</p><ul><li><p>1）要么为空，要么：</p></li><li><p>2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。</p></li><li><p>3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。   </p></li><li><p>2-3查找树的性质：</p></li></ul><p>  1）如果中序遍历2-3查找树，就可以得到排好序的序列；</p><p>  2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）</p><ul><li>复杂度分析：</li></ul><p>  2-3树的查找效率与树的高度是息息相关的。</p><p>  在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN<br>  在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN<br>  距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。</p><h3><span id="53-平衡查找树之红黑树red-black-tree">5.3 平衡查找树之红黑树（Red-Black Tree）</span></h3><p>  2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。</p><p>  基本思想：红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>跳跃表</title>
      <link href="/posts/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
      <url>/posts/%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://blog.jobbole.com/111731/">看这篇文章</a></p><p>和B+树很像，不过B+树插入需要Rebalance进行树重调整。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql索引B+树</title>
      <link href="/posts/Mysql%E7%B4%A2%E5%BC%95B-%E6%A0%91/"/>
      <url>/posts/Mysql%E7%B4%A2%E5%BC%95B-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="http://blog.jobbole.com/111757/">看这篇文章讲的很好</a></p><h2><span id="b-树balance-tree">B - 树（Balance Tree）</span></h2><pre><code>二叉查找树的时间复杂度是O(log(n)) 已经够快了，但是二叉查找树的查找速度取决于树的高度。B - 树，每个节点包含最多k个孩子，k被称为阶，k的大小取决于磁盘页的大小。</code></pre><h3><span id="一个-m-阶的-b-树具有如下几个特征">一个 m 阶的 B 树具有如下几个特征</span></h3><ul><li>根节点至少有两个子女。 </li><li>每个中间节点包含k-1个元素和k个孩子，其中m/2 &lt;= k &lt;= m</li><li>每个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;=m</li><li>所有叶子节点都位于同一层</li><li>每个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划。</li></ul><h2><span id="b树">B+树</span></h2><p>   在b-树基础上进行改造，将索引全部建在叶子节点上，非叶子节点指向叶子节点的大小。</p><p>   <a href="http://blog.jobbole.com/105644/">看这篇文章</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>100块钱可以兑换50块、10块、5块、1块的算法</title>
      <link href="/posts/100%E5%9D%97%E9%92%B1%E5%8F%AF%E4%BB%A5%E5%85%91%E6%8D%A250%E5%9D%97%E3%80%8110%E5%9D%97%E3%80%815%E5%9D%97%E3%80%811%E5%9D%97%E7%9A%84%E7%AE%97%E6%B3%95/"/>
      <url>/posts/100%E5%9D%97%E9%92%B1%E5%8F%AF%E4%BB%A5%E5%85%91%E6%8D%A250%E5%9D%97%E3%80%8110%E5%9D%97%E3%80%815%E5%9D%97%E3%80%811%E5%9D%97%E7%9A%84%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3><span id="最先想到的当然是for循环了">最先想到的当然是for循环了：</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   long time1 = System.currentTimeMillis();</span><br><span class="line">           System.out.println(&quot;当前时间为&quot;+time1);</span><br><span class="line">           int n = 0;</span><br><span class="line">           int n1, n5, n10, n50;</span><br><span class="line">           for (n1 = 0; n1 &lt; 100; n1++) &#123;</span><br><span class="line">               for (n5 = 0; n5 &lt; 20; n5++) &#123;</span><br><span class="line">                   for (n10 = 0; n10 &lt; 10; n10++) &#123;</span><br><span class="line">                       for (n50 = 0; n50 &lt; 2; n50++) &#123;</span><br><span class="line">                           if (n1 * 1 + n5 * 5 + n10 * 10 + n50 * 50 == 100) &#123;</span><br><span class="line">                               n++;</span><br><span class="line">                               System.out.println(&quot;1块的：&quot; + n1 + &quot;张 5块的： &quot; + n5 + &quot;张 10块的 ：&quot; + n10 + &quot;张 50块的：&quot; + n50 + &quot;张&quot;);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           long time2 = System.currentTimeMillis();</span><br><span class="line">           System.out.println(&quot;结束时间为&quot;+time2);</span><br><span class="line">           long time = time2 - time1;</span><br><span class="line">           System.out.println(n + &quot; 耗费时间为 &quot; + time);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><pre><code>很容易得出结果154.但是耗费时间为 1501038954420 - 1501038954413 =7;虽然时间耗费不是很多，但是通过打印信息可以看出来，50为2的时候只有一种情况，却空跑了很多空循环。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习5路由网关(zuul)</title>
      <link href="/posts/SpringCloud%E5%AD%A6%E4%B9%A05%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3-zuul/"/>
      <url>/posts/SpringCloud%E5%AD%A6%E4%B9%A05%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3-zuul/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在微服务架构中，需要几个关键的组件，服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个组件可以组建一个简单的微服务架构，如下图：</p><p><img src="img/%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3.png" alt="image"></p><p>注意：A 服务和 B 服务是可以相互调用的，作图的时候忘记了。并且配置服务也是注册到服务注册中心的。</p><p>客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul 集群），然后再到具体的服务，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理（下一篇文章讲述），配置服务的配置文件放在 Git 仓库，方便开发人员随时改配置。</p><p>一、Zuul 简介</p><p>Zuul 的主要功能是路由和过滤器。路由功能是微服务的一部分，比如／api/user 映射到 user 服务，/api/shop 映射到 shop 服务。zuul 实现了负载均衡。</p><p>zuul 有以下功能：</p><p>Authentication<br>Insights<br>Stress Testing<br>Canary Testing<br>Dynamic Routing<br>Service Migration<br>Load Shedding<br>Security<br>Static Response handling<br>Active/Active traffic management</p><p>二、准备工作</p><p>继续使用上一节的工程。在原有的工程上，创建一个新的工程。</p><p>三、创建 service-zuul 工程</p><pre><code> &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    </code></pre><p>在其入口 applicaton 类加上注解 @EnableZuulProxy，开启 zuul：</p><p>filterType：返回一个字符串代表过滤器的类型，在 zuul 中定义了四种不同生命周期的过滤器类型，具体如下：<br>pre：路由之前<br>routing：路由之时<br>post： 路由之后<br>error：发送错误调用<br>filterOrder：过滤的顺序<br>shouldFilter：这里可以写逻辑判断，是否要过滤，本文 true, 永远过滤。<br>run：过滤器的具体逻辑。可用很复杂，包括查 sql，nosql 去判断该请求到底有没有权限访问。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习4断路器（Hystrix）</title>
      <link href="/posts/SpringCloud%E5%AD%A6%E4%B9%A04%E6%96%AD%E8%B7%AF%E5%99%A8%EF%BC%88Hystrix%EF%BC%89/"/>
      <url>/posts/SpringCloud%E5%AD%A6%E4%B9%A04%E6%96%AD%E8%B7%AF%E5%99%A8%EF%BC%88Hystrix%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以相互调用（RPC）。为了保证其高可用，单个服务又必须集群部署。由于网络原因或者自身的原因，服务并不能保证服务的 100% 可用，如果单个服务出现问题，调用这个服务就会出现网络延迟，此时若有大量的网络涌入，会形成任务累计，导致服务瘫痪，甚至导致服务 “雪崩”。<br>为了解决这个问题，就出现断路器模型。</p><h3><span id="断路器简介">断路器简介</span></h3><ul><li>Netflix 已经创建了一个名为 Hystrix 的库来实现断路器模式。 在微服务架构中，多层服务调用是非常常见的。</li><li>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用达到一个阀值（hystric 是 5 秒 20 次） 断路器将会被打开。</li><li>断路打开后，可用避免连锁故障，fallback 方法可以直接返回一个固定值。</li></ul><h3><span id="在-ribbon-使用断路器">在 ribbon 使用断路器</span></h3><ul><li>改造 serice-ribbon 工程的代码：在 pox.xml 文件中加入：</li></ul><pre><code>&lt;dependency&gt;      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; </code></pre><ul><li>在程序的入口类加 @EnableHystrix：   </li><li>改造 HelloService 类，加上 @HystrixCommand，并指定 fallbackMethod 方法。</li></ul><h3><span id="feign-中使用断路器">Feign 中使用断路器</span></h3><ul><li>如果你使用了 feign，feign 是自带断路器的，并且是已经打开了。如果使用 feign 不想用断路器的话，可以在配置文件中关闭它，配置如下：feign.hystrix.enabled=false</li></ul><h3><span id="circuit-breaker-hystrix-dashboard-断路器hystrix-仪表盘">Circuit Breaker: Hystrix Dashboard (断路器：hystrix 仪表盘)</span></h3><ul><li>基于 service-ribbon 改造下：pom.xml 加入：</li></ul><pre><code>&lt;dependency&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;             &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;         &lt;/dependency&gt;          &lt;dependency&gt;             &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;             &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;         &lt;/dependency&gt;        </code></pre><h3><span id="在主程序入口中加入-enablehystrixdashboard-注解开启-hystrixdashboard">在主程序入口中加入 @EnableHystrixDashboard 注解，开启 hystrixDashboard：</span></h3><pre><code>  该仪表盘可以查看错误率</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习3服务消费者feign</title>
      <link href="/posts/SpringCloud%E5%AD%A6%E4%B9%A03%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85feign/"/>
      <url>/posts/SpringCloud%E5%AD%A6%E4%B9%A03%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85feign/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3><span id="使用feign">使用feign</span></h3><p>spring-cloud-starter-eureka<br>spring-cloud-starter-feign<br>spring-boot-starter-web<br>spring-boot-starter-test</p><h3><span id="配置文件">配置文件</span></h3><p>eureka:<br>  client:<br>    serviceUrl:<br>      defaultZone: <a href="http://localhost:8761/eureka/">http://localhost:8761/eureka/</a><br>server:<br>  port: 8765<br>spring:<br>  application:<br>    name: service-feign</p><h3><span id="开启feign">开启feign</span></h3><ul><li>在程序的入口类，需要通过注解 @EnableFeignClients 来开启 feign:<h3><span id="调用服务">调用服务</span></h3></li><li>定义一个 feign 接口类, 通过 @ FeignClient（“服务名”），来指定调用哪个服务：</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习2服务消费者</title>
      <link href="/posts/SpringCloud%E5%AD%A6%E4%B9%A02%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85/"/>
      <url>/posts/SpringCloud%E5%AD%A6%E4%B9%A02%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在上一篇文章，讲了服务的注册和发现。在服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于 http restful 的。spring cloud 有两种调用方式，一种是 ribbon+restTemplate，另一种是 feign。在这一篇文章首先讲解下基于 ribbon+rest。</p><h2><span id="ribbon">ribbon</span></h2><ul><li><p>是一个负载均衡客户端，可以很好的控制 http 和 tcp 的一些行为。Feign 也用到 ribbon，当你使用 @ FeignClient，ribbon 自动被应用。</p></li><li><p>ribbon 已经默认实现了这些配置 bean：</p><ul><li><p>IClientConfig ribbonClientConfig: DefaultClientConfigImpl</p></li><li><p>IRule ribbonRule: ZoneAvoidanceRule</p></li><li><p>IPing ribbonPing: NoOpPing</p></li><li><p>ServerList ribbonServerList: ConfigurationBasedServerList</p></li><li><p>ServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter</p></li><li><p>ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer</p></li></ul></li></ul><h3><span id="准备工作">准备工作</span></h3><ul><li>基于上一节的工程，启动 eureka-server 工程；启动 service-hi 工程，它的端口为 8762；将 service-hi 的配置文件的端口改为 8763, 并启动它，这时你会发现：service-hi 在 eureka-server 注册了 2 个，这就相当于一个小的集群。访问 localhost:8761 如图所示：</li></ul><h2><span id="新建一个service-ribbon">新建一个service-ribbon</span></h2><ul><li>spring-cloud-starter-eureka</li><li>spring-cloud-starter-ribbon</li><li>spring-boot-starter-web</li><li>spring-boot-starter-test</li></ul><h3><span id="想eureka注册一个客户端">想eureka注册一个客户端</span></h3><pre><code>eureka:   client:     serviceUrl:       defaultZone: http://localhost:8761/eureka/ server:   port: 8764 spring:   application:     name: service-ribbon       </code></pre><h3><span id="启动类">启动类</span></h3><ul><li>在工程的启动类中, 通过 @EnableDiscoveryClient 向服务中心注册；   </li></ul><h3><span id="架构如下">架构如下</span></h3><p>   <img src="img/ribbon%E5%90%8E%E7%9A%84%E6%9E%B6%E6%9E%84.png" alt="image"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习1EurekaServer</title>
      <link href="/posts/SpringCloud%E5%AD%A6%E4%B9%A01EurekaServer/"/>
      <url>/posts/SpringCloud%E5%AD%A6%E4%B9%A01EurekaServer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2><span id="创建eurekaserver">创建EurekaServer</span></h2><h3><span id="idea初始化项目">Idea初始化项目</span></h3><ul><li>选择cloud discovery-&gt;eureka server 。</li></ul><h3><span id="创建启动类">创建启动类</span></h3><ul><li>@EnableEurekaServer</li></ul><h3><span id="配置参数">配置参数</span></h3><pre><code>server:  port: 8761eureka:  instance:    hostname: localhost  client:    registerWithEureka: false    fetchRegistry: false    serviceUrl:      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/                  </code></pre><h2><span id="创建eurekaclient">创建EurekaClient</span></h2><h3><span id="初始化项目">初始化项目</span></h3><ul><li>通server</li></ul><h3><span id="创阿金启动类">创阿金启动类</span></h3><ul><li>@EnableEurekaClient</li></ul><h3><span id="配置参数">配置参数</span></h3><pre><code> eureka:   client:     serviceUrl:       defaultZone: http://localhost:8761/eureka/ server:   port: 8762 spring:   application:     name: service-hi</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微信公众平台Dubbo项目结构</title>
      <link href="/posts/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0Dubbo%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"/>
      <url>/posts/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0Dubbo%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>]]></content>
      
      
      
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> 微信公众平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于微信公众号的微服务架构</title>
      <link href="/posts/%E5%9F%BA%E4%BA%8E%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
      <url>/posts/%E5%9F%BA%E4%BA%8E%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li>wechatParent:    <ul><li>wechat-base-parent</li><li>wechat-business-parent</li><li>wechat-core-parent</li><li>wechat-web-parent</li></ul></li></ul><h3><span id="wechatparent">wechatParent</span></h3><ul><li>职责： 一键构建所有需要发布的项目。</li><li>特性<ul><li>所有项目初始时就带有这些 jar 包的依赖，例如：testng(单元测试相关),h2(单元测试相关),easymock(单元测试相关),lombok（根据注释自动生成 setter 和 getter）</li><li>所有项目的额外特性，例如：单元测试插件</li><li>项目发布管理，例如：私一的 maven 私服配置</li></ul></li></ul><h3><span id="wechat-core-parent">wechat-core-parent</span></h3><ul><li>职责：<ul><li>该部分与业务没有关联，只提供基础能力。例如：数据库持久能力，缓存能力，http封装能力，通用工具能力。</li></ul></li><li>通用特性：<ul><li>javadoc插件，用于生成javadoc</li></ul></li></ul><h3><span id="wechat-base-parent">wechat-base-parent</span></h3><ul><li>只代表一个真实存在而且能独立存在的业务实体，简称base项目。</li></ul><h3><span id="we-business-parent">we-business-parent</span></h3><ul><li>职责：<ul><li>它所聚合的的项目必须是一个提供 “共享” 业务流程，简称：business 项目。在这个流程过程中有可能需要引用 base 服务。它本身没有一个真实存在而且能独立存在的核心实体       </li></ul></li></ul><h3><span id="wechat-web-parent">wechat-web-parent</span></h3><ul><li>职责：<ul><li>它所聚合的的项目可以通过互联网向用户提供服务，在产品规划上它自己独有的不被共享的业务，简称：web 项目。</li></ul></li></ul><h3><span id="总体架构图如下">总体架构图如下</span></h3><p>   <img src="img/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="image">  </p><h3><span id="redis">Redis</span></h3><ul><li>提到阿里云的这个 Redis，不得不吐槽一句，它竟然是不支持主从的，只能单实例，不过，用它做数据缓存，还真是蛮不错的选择，响应速度非常快。而且，因为是放置在内网的且只能内网访问，所以安全性也很高。<h3><span id="mongodb">MongoDB</span></h3></li><li>结构型数据，主要存储档案式的数据，比如每个用户的操作行为，以档案式记录并进行统计分析，方便下一阶段的项目做个性化服务。另外一些关联复杂的数据，也可以用 MongoDb 存储，可以提高访问速度。还有，一些对软件应用版本比较敏感的数据也可以存在 MongoDB 中，比如 a 版本拿到 A 数据，b 版本拿到 B 数据，而这个 AB 数据都是由很多关联关系复杂的数据所组成，如果把这些数据根据版本号存储在不同的 MongoDB 档案中，需要时，直接根据版本号拿就可以了，这样就避免了很多的 mysql 查询。</li></ul><h3><span id="静态资源">静态资源</span></h3><ul><li>OSS + CDN<br>OSS 存储静态资源，CDN(内容分发网络) 可以加速静态资源的下载速度。至于资源链接地址，客户端可以通过接口访问从后端业务数据库中拿到。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 微信 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootstrap日期格式化</title>
      <link href="/posts/datetimepicker%20bootstrap%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
      <url>/posts/datetimepicker%20bootstrap%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li>p : 小写上下午 (‘am’ or ‘pm’)  meridian in lower case (‘am’ or ‘pm’) - according to locale file <ul><li>P : 大写上下午 (‘AM’ or ‘PM’) meridian in upper case (‘AM’ or ‘PM’) - according to locale file</li><li>s : 一位的秒  seconds without leading zeros</li><li>ss : 两位的秒  seconds, 2 digits with leading zeros</li><li>i : 一位的分钟  minutes without leading zeros</li><li>ii : 两位的分钟  minutes, 2 digits with leading zeros</li><li>h : 一位的24进制小时  hour without leading zeros - 24-hour format</li><li>hh : 两位的24进制小时  hour, 2 digits with leading zeros - 24-hour format</li><li>H : 一位的12进制小时 hour without leading zeros - 12-hour format</li><li>HH : 两位的24进制小时  hour, 2 digits with leading zeros - 12-hour format</li><li>d : 一位的天  day of the month without leading zeros</li><li>dd : 两位的天 day of the month, 2 digits with leading zeros</li><li>m : 一位的分钟  numeric representation of month without leading zeros</li><li>mm : 两位的分钟 numeric representation of the month, 2 digits with leading zeros</li><li>M : 缩写月份单词，三位数  short textual representation of a month, three letters</li><li>MM : 全拼月份单词 full textual representation of a month, such as January or March</li><li>yy : 两位的年  two digit representation of a year</li><li>yyyy : 四位的年  full numeric representation of a year, 4 digits</li></ul></li></ul><h3><span id="详情请看官网解释">详情请看官网解释</span></h3><p><a href="http://www.bootcss.com/p/bootstrap-datetimepicker/">http://www.bootcss.com/p/bootstrap-datetimepicker/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>datetimepicker Jquery日期格式化</title>
      <link href="/posts/datetimepicker%20Jquery%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
      <url>/posts/datetimepicker%20Jquery%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3><span id="年">年</span></h3><ul><li>y 一位数的年份（2001 显示为 “1”）。</li><li>yy 年份的最后两位数（2001 显示为 “01”）。</li><li>yyyy 完整的年份（2001 显示为 “2001”）。</li></ul><h3><span id="月">月</span></h3><ul><li>M 一位数或两位数月份值。</li><li>MM 两位数月份值。一位数数值前面加一个零。</li><li>MMM 三个字符的月份缩写。</li><li>MMMM 完整的月份名。</li></ul><h3><span id="天">天</span></h3><ul><li>d 一位数或两位数的天数。</li><li>dd 两位数的天数。一位数天数的前面加一个零。</li><li>ddd 三个字符的星期几缩写。</li><li>dddd 完整的星期几名称。</li></ul><h3><span id="小时">小时</span></h3><ul><li>h12 小时格式的一位数或两位数小时数。<br> hh12 小时格式的两位数小时数。一位数数值前面加一个零。</li><li> H24 小时格式的一位数或两位数小时数。</li><li>  HH24 小时格式的两位数小时数。一位数数值前面加一个零。</li></ul><h3><span id="分钟">分钟</span></h3><ul><li>m 一位数或两位数分钟值。</li><li>mm 两位数分钟值。一位数数值前面加一个零。</li></ul><h3><span id="秒">秒</span></h3><ul><li>s 一位数或两位数秒数。</li><li>ss 两位数秒数。一位数数值前面加一个零。</li></ul><h3><span id="上下午">上下午</span></h3><ul><li>t 一个字母的 AM/PM 缩写（”AM” 显示为 “A”）。</li><li>tt 两个字母的 AM/PM 缩写（”AM” 显示为 “AM”）。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>完整写一篇博客</title>
      <link href="/posts/%E5%AE%8C%E6%95%B4%E5%86%99%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/posts/%E5%AE%8C%E6%95%B4%E5%86%99%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3><span id="1命令行创建一个md文件">1命令行创建一个md文件。</span></h3><ul><li>hexo new “title”</li><li>在 hexo 主目录下 source -&gt; _posts 新建以 .md 为后缀的文件。</li></ul><p>  这两种方式都可以创建一个，不过命令行形式会在md中创建描述文件：</p><pre><code>    ---    title: 完整写一篇博客    date: 2017-07-18 14:03:42    tags:    ---</code></pre><h3><span id="创建front-matter">创建Front-matter</span></h3><pre><code> 参数    描述    默认值 layout    布局    post title    标题    文件名 date    建立日期    文件建立日期 updated    更新日期    文件更新日期 tags    标签（不适用于分页） categories    分类（不适用于分页） permalink    覆盖文章网址 thumbnail    缩略图地址 toc    显示 TOC 按钮    true comment    显示评论    true notag    不生成标签按钮    false top    置顶    false mathJax    启用 Mathjax    false</code></pre><h3><span id="友情url链接">友情url链接</span></h3><pre><code> pages:      About:          link: &quot;#about&quot;          icon: person          divider: false</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Material主题的Hexo博客</title>
      <link href="/posts/%E6%90%AD%E5%BB%BAMaterial%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/posts/%E6%90%AD%E5%BB%BAMaterial%E4%B8%BB%E9%A2%98%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>全篇可以在这搜到：</p><p><a href="https://material.viosey.com/services/">戳这里</a></p><h2><span id="本地搜索插件">本地搜索插件</span></h2><p>npm install hexo-generator-search –save<br>在主配置文件中添加：<br>search:<br>    path: search.xml<br>    field: all</p><h2><span id="rss订阅插件">rss订阅插件</span></h2><p>npm install hexo-generator-feed –save</p><p>feed:<br>  type: atom<br>  path: atom.xml<br>  limit: 20<br>  hub:<br>  content:</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>node8.0方法弃用解决办法</title>
      <link href="/posts/node8-0%E6%96%B9%E6%B3%95%E5%BC%83%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/posts/node8-0%E6%96%B9%E6%B3%95%E5%BC%83%E7%94%A8%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3><span id="刚升级node后发现报如下的错">刚升级node后发现报如下的错：</span></h3><ul><li><p>(node:34880) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.</p><p>  node.js从8.0开始已经弃用了fs.SyncWriteStream方法，hexo中有一个hexo-fs插件，调用了这个方法，所以就会报错。</p></li></ul><h3><span id="解决办法">解决办法：</span></h3><ul><li>npm install hexo-fs –save</li></ul><p>插件就更新了，问题就解决了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC通俗解释</title>
      <link href="/posts/RPC%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8A/"/>
      <url>/posts/RPC%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="rpc通俗解释">RPC通俗解释</span></h1><h2><span id="ipc和rpc">IPC和RPC</span></h2><p>早些时间，一个电脑中多个线程互相独立，A线程和B线程都想用发送邮件功能，就需要开发两份代码，所以就有了一个协议是：IPC（Inter-process-communication）进行进程间通信，这样就可以在A中开发一个发送邮件的代码，B进程调用A进程代码就行了。<br>同比，现在的程序员们，为了方便调用其他电脑中的代码，研究出来RPC（Remote Procedure Call Protocol）；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM介绍</title>
      <link href="/posts/JVM%E4%BB%8B%E7%BB%8D/"/>
      <url>/posts/JVM%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="jvm介绍">JVM介绍</span></h1><h2><span id="jvm包括">JVM包括：</span></h2><pre><code>* 1、 字节码指令集* 2、 一组寄存器* 3、 一个栈* 4、 一个垃圾回收堆* 5、 存储方法区</code></pre><h2><span id="jvm-的生命周期">JVM 的生命周期</span></h2><ol><li>JVM 实例对应了一个独立运行的 java 程序它是进程级别 <ol><li>启动。启动一个 Java 程序时，一个 JVM 实例就产生了，任何一个拥有 public static void main(String[] args) 函数的 class 都可以作为 JVM 实例运行的起点 </li><li>运行。main() 作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM 内部有两种线程：守护线程和非守护线程，main() 属于非守护线程，守护线程通常由 JVM 自己使用，<b> java 程序也可以表明自己创建的线程是守护线程 <b></b></b></li><li>消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用 Runtime 类或者 System.exit() 来退出</li></ol></li><li>JVM 执行引擎实例则对应了属于用户运行程序的线程它是线程级别的</li></ol><h2><span id="jvm模型">JVM模型</span></h2><p><img src="http://images.cnitblog.com/i/437053/201403/030952082544688.png" alt="image"></p><h2><span id="内存空间">内存空间：</span></h2><pre><code>1) 方法区： 指令计数器以及其他隐含寄存器2) Java堆： 3) Java栈：4) 本地方法栈：</code></pre><h2><span id="共享不共享">共享不共享：</span></h2><pre><code>共享：    1) 方法区    2) 栈（Heap）不共享：    1)程序计数器    2)VM stack 虚拟机栈    3)本地方法栈1) 程序计数器： 2) 栈： 线程私有的，每个线程创建的同时都会创建 JVM 栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及 Stack Frame，非基本类型的对象在 JVM 栈上仅存放一个指向堆上的地址。3) 堆：1）存储 *对象实例以及数组值*       2）**！Sun Hospot JVM为了提高对象内存分配的效率，对于所创建的线程都会分配一个独立的空间TLAB（Thread Local Allocation Buffer） ，其大小由JVM根据运行的情况计算而得，在TLAB中分配的对象不需要加锁，因此JVM在给线程的对象分配内存时会尽量在TLAB中分配，性能和C性能差不多高效，如果对象过大，仍然直接在堆中分配。 **       3）TLAB仅作用于新生代的Eden Space，因此多个小对象比一个大对象高效。       4）新创建的对象总是被放在新生代中，如果在一次或者多次GC后活下来，就会被转移到老年代。4）方法区：1）在Sun JDK中对应着为永久带、持久带 ！！！           2）方法区存放了所加载类的信息（名称，修饰符等），类中的静态变量，类中定义为final类型的常量，类中的Field信息，类中的方法信息，当开发人员用Class对象的getname,isInterface等获取信息时，数据都来源于方法区，方法区也是**共享的**，在一定条件下，也会被GC，当方法区使用的内存超过其允许的大小，也会抛OutMemory异常。</code></pre><h3><span id="原因">原因：</span></h3><pre><code>JVM每遇到一个线程，都会为其分配一个程序计数器，VM stack 和本地方法栈，当线程终止时三者所使用的空间也被回收掉。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何保证推送消息能够准确推送到客户端</title>
      <link href="/posts/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AF%E8%83%BD%E5%A4%9F%E5%87%86%E7%A1%AE%E6%8E%A8%E9%80%81%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/posts/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AF%E8%83%BD%E5%A4%9F%E5%87%86%E7%A1%AE%E6%8E%A8%E9%80%81%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1><span id="如何保证推送消息能够准确推送到客户端">如何保证推送消息能够准确推送到客户端。</span></h1><h2><span id="手机端">手机端：</span></h2><ul><li>轮询方式获取消息。</li><li>短信拦截模式。  发送短信通知消息，应用中的短信拦截模块拦截短信，并解析成数据。成本高。</li><li>持久连接。</li></ul><p> 监听电量变化，网络变化，开关屏幕等等时候注册BroadCastReceiver来接收通知，接手后进行消息获取。<br> 有些ROM一旦用户kill掉主线程，就不会再投送广播消息给应用，导致应用无法启动，这是可以Fork一个进程,一旦发现主线程被杀，立即调用shell启动该Service（应用保活）</p><h2><span id="微服务间如何选择推送和拉取数据">微服务间如何选择推送和拉取数据</span></h2><p>在消息系统中，一般有两种消费模式：生产端推送消息，消费主动拉取消息。</p><h4><span id="数据是动态的且实时性较强宜采用生产端推送">数据是动态的，且实时性较强，宜采用生产端推送。</span></h4><p>   例如家长手机控制孩子手机使用，希望设置立即生效，家长端设置后由<strong>立即</strong>由中间系统进行通知。如果让消费端轮询查消息，不仅不能保证消息的实时性和准确性，而且系统也会造成一定的损耗，供应链系统也会被迫处理重复订单问题。<br>    如果把消息设置成实时推送也是不合适的，<strong>推送成不成功不应该作为设置成功的条件</strong>。设置功能和推送功能不应该是强关联的，就像发送验证码，服务器收到了发送验证码的功能请求后，异步交给验证码发送功能，返回给客户200成功，随后验证码发送功能进行异步通知，确保通知成功即可。</p><h4><span id="客户端长时间离线状态">客户端长时间离线状态</span></h4><p>   客户端长时间离线状态（断网，没电等等），没办法推送过去，会暂存在一个暂存表中，等待客户端联网等监听广播事件进行主动获取，消息获取成功，就会把离线消息表里的消息转移到已发送的消息表中。（不在本表中将已发送的消息的字段置为已读，会影响查询速度。）</p><h4><span id="推送的优点">推送的优点</span></h4><ul><li>时效性高。</li><li>服务器压力小。 相对比轮询拉取模式，每次推送都会有数据，有效避免了空轮询</li><li>交互简单。 只需要提供推送接口就好了，不需要额外开销。</li></ul><h4><span id="推送的缺点">推送的缺点</span></h4><ul><li>不能保证一定能推送成功。</li><li>缺乏数据多样性，推送的消息一般都有固定的模板<br>####极光推送</li><li>活跃用户的到达率在90%以上。轮询获取99%以上。</li><li>并发情况下第三方服务的实时性不太理想。</li></ul><h4><span id="自主研发的推送系统">自主研发的推送系统</span></h4><ul><li>对客户端的海量长连接的维护管理消耗太大。</li><li>App端Service稳定性，保活。</li><li>有些厂商不允许有push service存在。</li></ul><p>##自主研发的推送架构</p><h3><span id="架构方案类似">架构方案类似：</span></h3><p>   <img src="http://upload-images.jianshu.io/upload_images/1760830-e6fbb7ae6613b8ae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>            （图片来自架构之美公众号，侵删）</p><ul><li>通过动态组合和扩展方式，结合移动Push推送数据分析，不同的手机使用不同的方案，针对性的优化，android平台中，融合多种不同的第三方推送PUSH平台，提高转化率。</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
