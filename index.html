<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"earyant.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="个人技术博客，分享开发中遇到的问题，以及想学的新技术，会持续更新，可以订阅rss。">
<meta property="og:type" content="website">
<meta property="og:title" content="Earyant的技术博客">
<meta property="og:url" content="http://earyant.github.io/index.html">
<meta property="og:site_name" content="Earyant的技术博客">
<meta property="og:description" content="个人技术博客，分享开发中遇到的问题，以及想学的新技术，会持续更新，可以订阅rss。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Earyant">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://earyant.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Earyant的技术博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Earyant的技术博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Earyant的技术博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到Earyant的技术博客，在这里我将与你分享新技术。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">23</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">83</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://earyant.github.io/posts/Scikit-Learn%E4%B8%8ETensorFlow%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Earyant">
      <meta itemprop="description" content="个人技术博客，分享开发中遇到的问题，以及想学的新技术，会持续更新，可以订阅rss。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Earyant的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/Scikit-Learn%E4%B8%8ETensorFlow%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97-1/" class="post-title-link" itemprop="url">Scikit-Learn与TensorFlow机器学习实用指南-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-21 23:10:25 / 修改时间：23:15:18" itemprop="dateCreated datePublished" datetime="2021-09-21T23:10:25+08:00">2021-09-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、简介</p>
<p>很多机器学习的问题都会涉及到有着几千甚至数百万维的特征的训练实例。这不仅让训练过程变得非常缓慢，同时还很难找到一个很好的解，我们接下来就会遇到这种情况。这种问题通常被称为维数灾难（curse of dimentionality）。</p>
<p>幸运的是，在现实生活中我们经常可以极大的降低特征维度，将一个十分棘手的问题转变成一个可以较为容易解决的问题。例如，对于 MNIST 图片集（第 3 章中提到）：图片四周边缘部分的像素几乎总是白的，因此你完全可以将这些像素从你的训练集中扔掉而不会丢失太多信息。图 7-6 向我们证实了这些像素的确对我们的分类任务是完全不重要的。同时，两个相邻的像素往往是高度相关的：如果你想要将他们合并成一个像素（比如取这两个像素点的平均值）你并不会丢失很多信息。</p>
<p>警告：降维肯定会丢失一些信息（这就好比将一个图片压缩成 JPEG 的格式会降低图像的质量），因此即使这种方法可以加快训练的速度，同时也会让你的系统表现的稍微差一点。降维会让你的工作流水线更复杂因而更难维护。所有你应该先尝试使用原始的数据来训练，如果训练速度太慢的话再考虑使用降维。在某些情况下，降低训练集数据的维度可能会筛选掉一些噪音和不必要的细节，这可能会让你的结果比降维之前更好（这种情况通常不会发生；它只会加快你训练的速度）。</p>
<p>降维除了可以加快训练速度外，在数据可视化方面（或者 DataViz）也十分有用。降低特征维度到 2（或者 3）维从而可以在图中画出一个高维度的训练集，让我们可以通过视觉直观的发现一些非常重要的信息，比如聚类。</p>
<p>在这一章里，我们将会讨论维数灾难问题并且了解在高维空间的数据。然后，我们将会展示两种主要的降维方法：投影（projection）和流形学习（Manifold Learning），同时我们还会介绍三种流行的降维技术：主成分分析（PCA），核主成分分析（Kernel PCA）和局部线性嵌入（LLE）。</p>
<p>二、维数灾难<br>我们已经习惯生活在一个三维的世界里，以至于当我们尝试想象更高维的空间时，我们的直觉不管用了。即使是一个基本的 4D 超正方体也很难在我们的脑中想象出来（见图 8-1），更不用说一个 200 维的椭球弯曲在一个 1000 维的空间里了。</p>
<p>图 8-1 点，线，方形，立方体和超正方体（0D 到 4D 超正方体）<br>这表明很多物体在高维空间表现的十分不同。比如，如果你在一个正方形单元中随机取一个点（一个1×1的正方形），那么随机选的点离所有边界大于 0.001（靠近中间位置）的概率为 0.4%（1 - 0.998^2）（换句话说，一个随机产生的点不大可能严格落在某一个维度上。但是在一个 1,0000 维的单位超正方体（一个1×1×…×1的立方体，有 10,000 个 1），这种可能性超过了 99.999999%。在高维超正方体中，大多数点都分布在边界处。</p>
<p>还有一个更麻烦的区别：如果你在一个平方单位中随机选取两个点，那么这两个点之间的距离平均约为 0.52。如果您在单位 3D 立方体中选取两个随机点，平均距离将大致为 0.66。但是，在一个 1,000,000 维超立方体中随机抽取两点呢？那么，平均距离，信不信由你，大概为 408.25！这非常违反直觉：当它们都位于同一单元超立方体内时，两点是怎么距离这么远的？这一事实意味着高维数据集有很大风险分布的非常稀疏：大多数训练实例可能彼此远离。当然，这也意味着一个新实例可能远离任何训练实例，这使得预测的可靠性远低于我们处理较低维度数据的预测，因为它们将基于更大的推测（extrapolations）。简而言之，训练集的维度越高，过拟合的风险就越大。</p>
<p>理论上来说，维数爆炸的一个解决方案是增加训练集的大小从而达到拥有足够密度的训练集。不幸的是，在实践中，达到给定密度所需的训练实例的数量随着维度的数量呈指数增长。如果只有 100 个特征（比 MNIST 问题要少得多）并且假设它们均匀分布在所有维度上，那么如果想要各个临近的训练实例之间的距离在 0.1 以内，您需要比宇宙中的原子还要多的训练实例。</p>
<p>三、降维的主要方法<br>在我们深入研究具体的降维算法之前，我们来看看降低维度的两种主要方法：投影和流形学习。</p>
<p>3.1 投影（Projection）<br>在大多数现实生活的问题中，训练实例并不是在所有维度上均匀分布的。许多特征几乎是常数，而其他特征则高度相关（如前面讨论的 MNIST）。结果，所有训练实例实际上位于（或接近）高维空间的低维子空间内。这听起来有些抽象，所以我们不妨来看一个例子。在图 8-2 中，您可以看到由圆圈表示的 3D 数据集。</p>
<p>图 8-2 一个分布接近于2D子空间的3D数据集<br>注意到所有训练实例的分布都贴近一个平面：这是高维（3D）空间的较低维（2D）子空间。现在，如果我们将每个训练实例垂直投影到这个子空间上（就像将短线连接到平面的点所表示的那样），我们就可以得到如图8-3所示的新2D数据集。铛铛铛！我们刚刚将数据集的维度从 3D 降低到了 2D。请注意，坐标轴对应于新的特征z1和z2（平面上投影的坐标）。</p>
<p>图 8-3 一个经过投影后的新的 2D 数据集<br>但是，投影并不总是降维的最佳方法。在很多情况下，子空间可能会扭曲和转动，比如图 8-4 所示的着名瑞士滚动玩具数据集。</p>
<p>图 8-4 瑞士滚动数玩具数据集<br>简单地将数据集投射到一个平面上（例如，直接丢弃x3）会将瑞士卷的不同层叠在一起，如图 8-5 左侧所示。但是，你真正想要的是展开瑞士卷所获取到的类似图 8-5 右侧的 2D 数据集。</p>
<p>图 8-5 投射到平面的压缩（左）vs 展开瑞士卷（右）<br>3.2 流形学习</p>
<p>瑞士卷一个是二维流形的例子。简而言之，二维流形是一种二维形状，它可以在更高维空间中弯曲或扭曲。更一般地，一个d维流形是类似于d维超平面的n维空间（其中d &lt; n）的一部分。在我们瑞士卷这个例子中，d = 2，n = 3：它有些像 2D 平面，但是它实际上是在第三维中卷曲。</p>
<p>许多降维算法通过对训练实例所在的流形进行建模从而达到降维目的；这叫做流形学习。它依赖于流形猜想（manifold assumption），也被称为流形假设（manifold hypothesis），它认为大多数现实世界的高维数据集大都靠近一个更低维的流形。这种假设经常在实践中被证实。</p>
<p>让我们再回到 MNIST 数据集：所有手写数字图像都有一些相似之处。它们由连线组成，边界是白色的，大多是在图片中中间的，等等。如果你随机生成图像，只有一小部分看起来像手写数字。换句话说，如果您尝试创建数字图像，那么您的自由度远低于您生成任何随便一个图像时的自由度。这些约束往往会将数据集压缩到较低维流形中。</p>
<p>流形假设通常包含着另一个隐含的假设：你现在的手上的工作（例如分类或回归）如果在流形的较低维空间中表示，那么它们会变得更简单。例如，在图 8-6 的第一行中，瑞士卷被分为两类：在三维空间中（图左上），分类边界会相当复杂，但在二维展开的流形空间中（图右上），分类边界是一条简单的直线。</p>
<p>但是，这个假设并不总是成立。例如，在图 8-6 的最下面一行，决策边界位于x1 = 5（图左下）。这个决策边界在原始三维空间（一个垂直平面）看起来非常简单，但在展开的流形中却变得更复杂了（四个独立线段的集合）（图右下）。</p>
<p>简而言之，如果在训练模型之前降低训练集的维数，那训练速度肯定会加快，但并不总是会得出更好的训练效果；这一切都取决于数据集。</p>
<p>希望你现在对于维数爆炸以及降维算法如何解决这个问题有了一定的理解，特别是对流形假设提出的内容。本章的其余部分将介绍一些最流行的降维算法。</p>
<p>图 8-6 决策边界并不总是会在低维空间中变的简单</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83284762">参考</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/topic/20134952/hot">参考二</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://earyant.github.io/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E9%AB%98%E7%BA%A7pandas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Earyant">
      <meta itemprop="description" content="个人技术博客，分享开发中遇到的问题，以及想学的新技术，会持续更新，可以订阅rss。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Earyant的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E9%AB%98%E7%BA%A7pandas/" class="post-title-link" itemprop="url">利用python进行数据分析-高级pandas</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-21 22:39:32 / 修改时间：22:44:12" itemprop="dateCreated datePublished" datetime="2021-09-21T22:39:32+08:00">2021-09-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://earyant.github.io/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Earyant">
      <meta itemprop="description" content="个人技术博客，分享开发中遇到的问题，以及想学的新技术，会持续更新，可以订阅rss。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Earyant的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/" class="post-title-link" itemprop="url">利用python进行数据分析-时间序列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-21 22:39:04 / 修改时间：23:14:03" itemprop="dateCreated datePublished" datetime="2021-09-21T22:39:04+08:00">2021-09-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、第14章 数据分析案例<br>本书正文的最后一章，我们来看一些真实世界的数据集。对于每个数据集，我们会用之前介绍的方法，从原始数据中提取有意义的内容。展示的方法适用于其它数据集，也包括你的。本章包含了一些各种各样的案例数据集，可以用来练习。</p>
<p>下载本书代码：<a target="_blank" rel="noopener" href="https://github.com/wesm/pydata-book%EF%BC%88%E5%BB%BA%E8%AE%AE%E6%8A%8A%E4%BB%A3%E7%A0%81%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%AE%89%E8%A3%85%E5%A5%BDAnaconda">https://github.com/wesm/pydata-book（建议把代码下载下来之后，安装好Anaconda</a> 3.6，在目录文件夹中用Jupyter notebook打开）</p>
<p>二、实例<br>2.6 1880-2010年间全美婴儿姓名<br>美国社会保障总署提供了一份从1880年到现在的婴儿名字频率数据。Hadley Wickham（许多流行R包的作者）经常用这份数据来演示R的数据处理功能。</p>
<p>你可以用这个数据集做很多事，例如：</p>
<p>· 计算指定名字（可以是你自己的，也可以是别人的）的年度比例。</p>
<p>· 计算某个名字的相对排名。</p>
<p>· 计算各年度最流行的名字，以及增长或减少最快的名字。</p>
<p>· 分析名字趋势：元音、辅音、长度、总体多样性、拼写变化、首尾字母等。</p>
<p>· 分析外源性趋势：圣经中的名字、名人、人口结构变化等。</p>
<p>利用前面介绍过的那些工具，这些分析工作都能很轻松地完成，我会讲解其中的一些。</p>
<p>到编写本书时为止，美国社会保障总署将该数据库按年度制成了多个数据文件，其中给出了每个性别/名字组合的出生总数。</p>
<p>下载”National data”文件names.zip，解压后的目录中含有一组文件（如yob1880.txt）。其中一个文件的前10行：</p>
<p>Mary,F,7065</p>
<p>Anna,F,2604</p>
<p>Emma,F,2003</p>
<p>Elizabeth,F,1939</p>
<p>Minnie,F,1746</p>
<p>Margaret,F,1578</p>
<p>Ida,F,1472</p>
<p>Alice,F,1414</p>
<p>Bertha,F,1320</p>
<p>Sarah,F,1288</p>
<p>由于这是一个非常标准的以逗号隔开的格式，所以可以用pandas.read_csv将其加载到DataFrame中：</p>
<p>In [95]: import pandas as pd</p>
<p>In [96]: names1880 =pd.read_csv(‘datasets/babynames/yob1880.txt’,names=[‘name’, ‘sex’, ‘births’])</p>
<p>In [97]: names1880</p>
<p>Out[97]:</p>
<p>name sex births</p>
<p>0 Mary F 7065</p>
<p>1 Anna F 2604</p>
<p>2 Emma F 2003</p>
<p>… … .. …</p>
<p>1997 Wright M 5</p>
<p>1998 York M 5</p>
<p>1999 Zachariah M 5</p>
<p>[2000 rows x 3 columns]</p>
<p>这些文件中仅含有当年出现超过5次的名字。为了简单起见，我们可以用births列的sex分组小计表示该年度的births总计：</p>
<p>In [98]: names1880.groupby(‘sex’).births.sum()</p>
<p>Out[98]:</p>
<p>sex</p>
<p>F 90993</p>
<p>M 110493</p>
<p>Name: births, dtype: int64</p>
<p>由于该数据集按年度被分隔成了多个文件，所以第一件事情就是要将所有数据都组装到一个DataFrame里面，并加上一个year字段。使用pandas.concat即可达到这个目的：</p>
<p>years = range(1880, 2011)</p>
<p>pieces = []</p>
<p>columns = [‘name’, ‘sex’, ‘births’]</p>
<p>for year in years:</p>
<p>path = ‘datasets/babynames/yob%d.txt’ % year</p>
<p>frame = pd.read_csv(path, names=columns)</p>
<p>frame[‘year’] = year</p>
<p>pieces.append(frame)</p>
<p>names = pd.concat(pieces, ignore_index=True)#合并表格</p>
<p>这里需要注意几件事情。第一，concat默认是按行将多个DataFrame组合到一起的；第二，必须指定ignore_index=True，因为我们不希望保留read_csv所返回的原始行号。现在我们得到了一个非常大的DataFrame，它含有全部的名字数据：</p>
<p>In [100]: names</p>
<p>Out[100]:</p>
<p>name sex births year</p>
<p>0 Mary F 7065 1880</p>
<p>1 Anna F 2604 1880</p>
<p>2 Emma F 2003 1880</p>
<p>3 Elizabeth F 1939 1880</p>
<p>… … .. … …</p>
<p>1690781 Zyquarius M 5 2010</p>
<p>1690782 Zyran M 5 2010</p>
<p>1690783 Zzyzx M 5 2010</p>
<p>[1690784 rows x 4 columns]</p>
<p>有了这些数据之后，我们就可以利用groupby或pivot_table在year和sex级别上对其进行聚合了，如图14-4所示：</p>
<p>In [101]: total_births = names.pivot_table(‘births’, index=’year’,</p>
<p>…..: columns=’sex’, aggfunc=sum)</p>
<p>In [102]: total_births.tail()</p>
<p>Out[102]:</p>
<p>sex F M</p>
<p>year</p>
<p>2006 1896468 2050234</p>
<p>2007 1916888 2069242</p>
<p>2008 1883645 2032310</p>
<p>2009 1827643 1973359</p>
<p>2010 1759010 1898382</p>
<p>In [103]: %matplotlib</p>
<p>total_births.plot(title=’Total births by sex and year’)</p>
<p>图14-4 按性别和年度统计的总出生数<br>下面我们来插入一个prop列，用于存放指定名字的婴儿数相对于总出生数的比例。prop值为0.02表示每100名婴儿中有2名取了当前这个名字。因此，我们先按year和sex分组，然后再将新列加到各个分组上：</p>
<p>def add_prop(group):</p>
<p>group[‘prop’] = group.births / group.births.sum()</p>
<p>return group</p>
<p>names = names.groupby([‘year’, ‘sex’]).apply(add_prop)</p>
<p>现在，完整的数据集就有了下面这些列：</p>
<p>In [105]: names</p>
<p>Out[105]:</p>
<p>name sex births year prop</p>
<p>0 Mary F 7065 1880 0.077643</p>
<p>1 Anna F 2604 1880 0.028618</p>
<p>2 Emma F 2003 1880 0.022013</p>
<p>… … .. … … …</p>
<p>1690781 Zyquarius M 5 2010 0.000003</p>
<p>1690782 Zyran M 5 2010 0.000003</p>
<p>1690783 Zzyzx M 5 2010 0.000003</p>
<p>[1690784 rows x 5 columns]</p>
<p>在执行这样的分组处理时，一般都应该做一些有效性检查，比如验证所有分组的prop的总和是否为1：</p>
<p>In [106]: names.groupby([‘year’, ‘sex’]).prop.sum()</p>
<p>Out[106]:</p>
<p>year sex</p>
<p>1880 F 1.0</p>
<p>M 1.0</p>
<p>1881 F 1.0</p>
<p>M 1.0</p>
<p>1882 F 1.0</p>
<p>M 1.0</p>
<p>…</p>
<p>2008 F 1.0</p>
<p>M 1.0</p>
<p>2009 F 1.0</p>
<p>M 1.0</p>
<p>2010 F 1.0</p>
<p>M 1.0</p>
<p>Name: prop, Length: 262, dtype: float64</p>
<p>工作完成。为了便于实现更进一步的分析，我需要取出该数据的一个子集：每对sex/year组合的前1000个名字。这又是一个分组操作：</p>
<p>def get_top1000(group):</p>
<p>return group.sort_values(by=’births’, ascending=False)[:1000]</p>
<p>grouped = names.groupby([‘year’, ‘sex’])</p>
<p>top1000 = grouped.apply(get_top1000)</p>
<p>top1000.reset_index(inplace=True, drop=True)</p>
<p>如果你喜欢DIY的话，也可以这样：</p>
<p>pieces = []</p>
<p>for year, group in names.groupby([‘year’, ‘sex’]):</p>
<p>pieces.append(group.sort_values(by=’births’, ascending=False)[:1000])</p>
<p>top1000 = pd.concat(pieces, ignore_index=True)</p>
<p>现在的结果数据集就小多了：</p>
<p>In [108]: top1000</p>
<p>Out[108]:</p>
<p>name sex births year prop</p>
<p>0 Mary F 7065 1880 0.077643</p>
<p>1 Anna F 2604 1880 0.028618</p>
<p>2 Emma F 2003 1880 0.022013</p>
<p>3 Elizabeth F 1939 1880 0.021309</p>
<p>… … .. … … …</p>
<p>261874 Jaquan M 194 2010 0.000102</p>
<p>261875 Jaydan M 194 2010 0.000102</p>
<p>261876 Maxton M 193 2010 0.000102</p>
<p>[261877 rows x 5 columns]</p>
<p>接下来的数据分析工作就针对这个top1000数据集了。</p>
<p>2.7分析命名趋势<br>有了完整的数据集和刚才生成的top1000数据集，我们就可以开始分析各种命名趋势了。首先将前1000个名字分为男女两个部分：</p>
<p>In [109]: boys = top1000[top1000.sex == ‘M’]</p>
<p>In [110]: girls = top1000[top1000.sex == ‘F’]</p>
<p>这是两个简单的时间序列，只需稍作整理即可绘制出相应的图表（比如每年叫做John和Mary的婴儿数）。我们先生成一张按year和name统计的总出生数透视表：</p>
<p>In [111]: total_births = top1000.pivot_table(‘births’, index=’year’,</p>
<p>…..: columns=’name’,aggfunc=sum)</p>
<p>现在，我们用DataFrame的plot方法绘制几个名字的曲线图（见图14-5）：</p>
<p>In [112]: <a target="_blank" rel="noopener" href="http://total_births.info()/">http://total_births.info()</a></p>
<p>&lt;class ‘pandas.core.frame.DataFrame’&gt;</p>
<p>Int64Index: 131 entries, 1880 to 2010</p>
<p>Columns: 6868 entries, Aaden to Zuri</p>
<p>dtypes: float64(6868)</p>
<p>memory usage: 6.9 MB</p>
<p>In [113]: subset = total_births[[‘John’, ‘Harry’, ‘Mary’, ‘Marilyn’]]</p>
<p>In [114]: subset.plot(subplots=True, figsize=(12, 10), grid=False,</p>
<p>…..: title=”Number of births per year”)</p>
<p>图14-5 几个男孩和女孩名字随时间变化的使用数量<br>从图中可以看出，这几个名字在美国人民的心目中已经风光不再了。但事实并非如此简单，我们在下一节中就能知道是怎么一回事了。</p>
<p>2.8评估命名多样性的增长<br>一种解释是父母愿意给小孩起常见的名字越来越少。这个假设可以从数据中得到验证。一个办法是计算最流行的1000个名字所占的比例，我按year和sex进行聚合并绘图（见图14-6）：</p>
<p>In [116]: table = top1000.pivot_table(‘prop’, index=’year’,</p>
<p>…..: columns=’sex’, aggfunc=sum)</p>
<p>In [117]: table.plot(title=’Sum of table1000.prop by year and sex’,</p>
<p>…..: yticks=np.linspace(0, 1.2, 13), xticks=range(1880, 2020, 10))</p>
<p>图14-6 分性别统计的前1000个名字在总出生人数中的比例<br>从图中可以看出，名字的多样性确实出现了增长（前1000项的比例降低）。另一个办法是计算占总出生人数前50%的不同名字的数量，这个数字不太好计算。我们只考虑2010年男孩的名字：</p>
<p>In [118]: df = boys[boys.year == 2010]</p>
<p>In [119]: df</p>
<p>Out[119]:</p>
<p>name sex births year prop</p>
<p>260877 Jacob M 21875 2010 0.011523</p>
<p>260878 Ethan M 17866 2010 0.009411</p>
<p>260879 Michael M 17133 2010 0.009025</p>
<p>… … .. … … …</p>
<p>261874 Jaquan M 194 2010 0.000102</p>
<p>261875 Jaydan M 194 2010 0.000102</p>
<p>261876 Maxton M 193 2010 0.000102</p>
<p>[1000 rows x 5 columns]</p>
<p>在对prop降序排列之后，我们想知道前面多少个名字的人数加起来才够50%。虽然编写一个for循环确实也能达到目的，但NumPy有一种更聪明的矢量方式。先计算prop的累计和cumsum，然后再通过searchsorted方法找出0.5应该被插入在哪个位置才能保证不破坏顺序：</p>
<p>In [120]: prop_cumsum = df.sort_values(by=’prop’, ascending=False).prop.cumsum()</p>
<p>In [121]: prop_cumsum[:10]</p>
<p>Out[121]:<br>260877 0.011523</p>
<p>260878 0.020934</p>
<p>260879 0.029959</p>
<p>260880 0.038930</p>
<p>260881 0.047817</p>
<p>260882 0.056579</p>
<p>260883 0.065155</p>
<p>260884 0.073414</p>
<p>260885 0.081528</p>
<p>260886 0.089621</p>
<p>Name: prop, dtype: float64</p>
<p>In [122]: prop_cumsum.values.searchsorted(0.5)</p>
<p>Out[122]: 116</p>
<p>由于数组索引是从0开始的，因此我们要给这个结果加1，即最终结果为117。拿1900年的数据来做个比较，这个数字要小得多：</p>
<p>In [123]: df = boys[boys.year == 1900]</p>
<p>In [124]: in1900 = df.sort_values(by=’prop’, ascending=False).prop.cumsum()</p>
<p>In [125]: in1900.values.searchsorted(0.5) + 1</p>
<p>Out[125]: 25</p>
<p>现在就可以对所有year/sex组合执行这个计算了。按这两个字段进行groupby处理，然后用一个函数计算各分组的这个值：</p>
<p>def get_quantile_count(group, q=0.5):</p>
<p>group = group.sort_values(by=’prop’, ascending=False)</p>
<p>return group.prop.cumsum().values.searchsorted(q) + 1</p>
<p>diversity = top1000.groupby([‘year’, ‘sex’]).apply(get_quantile_count)</p>
<p>diversity = diversity.unstack(‘sex’)</p>
<p>现在，diversity这个DataFrame拥有两个时间序列（每个性别各一个，按年度索引）。通过IPython，你可以查看其内容，还可以像之前那样绘制图表（如图14-7所示）：</p>
<p>In [128]: diversity.head()</p>
<p>Out[128]:</p>
<p>sex F M</p>
<p>year</p>
<p>1880 38 14</p>
<p>1881 38 14</p>
<p>1882 38 15</p>
<p>1883 39 15</p>
<p>1884 39 16</p>
<p>In [129]: diversity.plot(title=”Number of popular names in top 50%”)</p>
<p>图14-7 按年度统计的密度表<br>从图中可以看出，女孩名字的多样性总是比男孩的高，而且还在变得越来越高。</p>
<p>2.9 “最后一个字母”的变革<br>2007年，一名婴儿姓名研究人员Laura Wattenberg在她自己的网站上指出（<a href="http://www.babynamewizard.com）：近百年来，男孩名字在最后一个字母上的分布发生了显著的变化。为了了解具体的情况，我首先将全部出生数据在年度、性别以及末字母上进行了聚合：">http://www.babynamewizard.com）：近百年来，男孩名字在最后一个字母上的分布发生了显著的变化。为了了解具体的情况，我首先将全部出生数据在年度、性别以及末字母上进行了聚合：</a></p>
<p>get_last_letter = lambda x: x[-1]# 提取尾字符</p>
<p>last_letters = names.name.map(get_last_letter)</p>
<p>last_letters.name = ‘last_letter’</p>
<p>table = names.pivot_table(‘births’, index=last_letters,</p>
<p>columns=[‘sex’, ‘year’], aggfunc=sum)</p>
<p>然后选出具有一定代表性的三年，并输出前面几行：</p>
<p>In [131]: subtable = table.reindex(columns=[1910, 1960, 2010], level=’year’)</p>
<p>In [132]: subtable.head()</p>
<p>Out[132]:</p>
<p>sex F M</p>
<p>year 1910 1960 2010 1910 1960 2010</p>
<p>last_letter</p>
<p>a 108376.0 691247.0 670605.0 977.0 5204.0 28438.0</p>
<p>b NaN 694.0 450.0 411.0 3912.0 38859.0</p>
<p>c 5.0 49.0 946.0 482.0 15476.0 23125.0</p>
<p>d 6750.0 3729.0 2607.0 22111.0 262112.0 44398.0</p>
<p>e 133569.0 435013.0 313833.0 28655.0 178823.0 129012.0</p>
<p>接下来我们需要按总出生数对该表进行规范化处理，以便计算出各性别各末字母占总出生人数的比例：</p>
<p>In [133]: subtable.sum()</p>
<p>Out[133]:</p>
<p>sex year</p>
<p>F 1910 396416.0</p>
<p>1960 2022062.0</p>
<p>2010 1759010.0</p>
<p>M 1910 194198.0</p>
<p>1960 2132588.0</p>
<p>2010 1898382.0</p>
<p>dtype: float64</p>
<p>In [134]: letter_prop = subtable / subtable.sum()</p>
<p>In [135]: letter_prop</p>
<p>Out[135]:</p>
<p>sex F M</p>
<p>year 1910 1960 2010 1910 1960 2010</p>
<p>last_letter</p>
<p>a 0.273390 0.341853 0.381240 0.005031 0.002440 0.014980</p>
<p>b NaN 0.000343 0.000256 0.002116 0.001834 0.020470</p>
<p>c 0.000013 0.000024 0.000538 0.002482 0.007257 0.012181</p>
<p>d 0.017028 0.001844 0.001482 0.113858 0.122908 0.023387</p>
<p>e 0.336941 0.215133 0.178415 0.147556 0.083853 0.067959</p>
<p>f NaN 0.000010 0.000055 0.000783 0.004325 0.001188</p>
<p>g 0.000144 0.000157 0.000374 0.002250 0.009488 0.001404</p>
<p>h 0.051529 0.036224 0.075852 0.045562 0.037907 0.051670</p>
<p>i 0.001526 0.039965 0.031734 0.000844 0.000603 0.022628</p>
<p>j NaN NaN 0.000090 NaN NaN 0.000769</p>
<p>k 0.000121 0.000156 0.000356 0.036581 0.049384 0.018541</p>
<p>l 0.043189 0.033867 0.026356 0.065016 0.104904 0.070367</p>
<p>m 0.001201 0.008613 0.002588 0.058044 0.033827 0.024657</p>
<p>n 0.079240 0.130687 0.140210 0.143415 0.152522 0.362771</p>
<p>o 0.001660 0.002439 0.001243 0.017065 0.012829 0.042681</p>
<p>p 0.000018 0.000023 0.000020 0.003172 0.005675 0.001269</p>
<p>q NaN NaN 0.000030 NaN NaN 0.000180</p>
<p>r 0.013390 0.006764 0.018025 0.064481 0.031034 0.087477</p>
<p>s 0.039042 0.012764 0.013332 0.130815 0.102730 0.065145</p>
<p>t 0.027438 0.015201 0.007830 0.072879 0.065655 0.022861</p>
<p>u 0.000684 0.000574 0.000417 0.000124 0.000057 0.001221</p>
<p>v NaN 0.000060 0.000117 0.000113 0.000037 0.001434</p>
<p>w 0.000020 0.000031 0.001182 0.006329 0.007711 0.016148</p>
<p>x 0.000015 0.000037 0.000727 0.003965 0.001851 0.008614</p>
<p>y 0.110972 0.152569 0.116828 0.077349 0.160987 0.058168</p>
<p>z 0.002439 0.000659 0.000704 0.000170 0.000184 0.001831</p>
<p>有了这个字母比例数据之后，就可以生成一张各年度各性别的条形图了，如图14-8所示：</p>
<p>import matplotlib.pyplot as plt</p>
<p>fig, axes = plt.subplots(2, 1, figsize=(10, 8))</p>
<p>letter_prop[‘M’].plot(kind=’bar’, rot=0, ax=axes[0], title=’Male’)</p>
<p>letter_prop[‘F’].plot(kind=’bar’, rot=0, ax=axes[1], title=’Female’,</p>
<p>legend=False)</p>
<p>图14-8 男孩女孩名字中各个末字母的比例<br>可以看出，从20世纪60年代开始，以字母”n”结尾的男孩名字出现了显著的增长。回到之前创建的那个完整表，按年度和性别对其进行规范化处理，并在男孩名字中选取几个字母，最后进行转置以便将各个列做成一个时间序列：</p>
<p>In [138]: letter_prop = table / table.sum()</p>
<p>In [139]: dny_ts = letter_prop.loc[[‘d’, ‘n’, ‘y’], ‘M’].T</p>
<p>In [140]: dny_ts.head()</p>
<p>Out[140]:</p>
<p>last_letter d n y</p>
<p>year</p>
<p>1880 0.083055 0.153213 0.075760</p>
<p>1881 0.083247 0.153214 0.077451</p>
<p>1882 0.085340 0.149560 0.077537</p>
<p>1883 0.084066 0.151646 0.079144</p>
<p>1884 0.086120 0.149915 0.080405</p>
<p>有了这个时间序列的DataFrame之后，就可以通过其plot方法绘制出一张趋势图了（如图14-9所示）：</p>
<p>In [143]: dny_ts.plot()</p>
<p>2.10变成女孩名字的男孩名字（以及相反的情况）<br>另一个有趣的趋势是，早年流行于男孩的名字近年来“变性了”，例如Lesley或Leslie。回到top1000数据集，找出其中以”lesl”开头的一组名字：</p>
<p>In [144]: all_names = pd.Series(top1000.name.unique())</p>
<p>In [145]: lesley_like = all_names[all_names.str.lower().str.contains(‘lesl’)]</p>
<p>In [146]: lesley_like</p>
<p>Out[146]:</p>
<p>632 Leslie</p>
<p>2294 Lesley</p>
<p>4262 Leslee</p>
<p>4728 Lesli</p>
<p>6103 Lesly</p>
<p>dtype: object</p>
<p>然后利用这个结果过滤其他的名字，并按名字分组计算出生数以查看相对频率：</p>
<p>In [147]: filtered = top1000[top1000.name.isin(lesley_like)]</p>
<p>In [148]: filtered.groupby(‘name’).births.sum()</p>
<p>Out[148]:</p>
<p>name</p>
<p>Leslee 1082</p>
<p>Lesley 35022</p>
<p>Lesli 929</p>
<p>Leslie 370429</p>
<p>Lesly 10067</p>
<p>Name: births, dtype: int64</p>
<p>接下来，我们按性别和年度进行聚合，并按年度进行规范化处理：</p>
<p>In [149]: table = filtered.pivot_table(‘births’, index=’year’,</p>
<p>…..: columns=’sex’, aggfunc=’sum’)</p>
<p>In [150]: table = table.div(table.sum(1), axis=0)</p>
<p>In [151]: table.tail()</p>
<p>Out[151]:</p>
<p>sex F M</p>
<p>year</p>
<p>2006 1.0 NaN</p>
<p>2007 1.0 NaN</p>
<p>2008 1.0 NaN</p>
<p>2009 1.0 NaN</p>
<p>2010 1.0 NaN</p>
<p>最后，就可以轻松绘制一张分性别的年度曲线图了（如图2-10所示）：</p>
<p>In [153]: table.plot(style={‘M’: ‘k-‘, ‘F’: ‘k–’})</p>
<p>图14-10 各年度使用“Lesley型”名字的男女比例<br>三、小结</p>
<p>names1880 =pd.read_csv(‘datasets/babynames/yob1880.txt’,names=[‘name’, ‘sex’, ‘births’])</p>
<p>names1880.groupby(‘sex’).births.sum()</p>
<p>for year in years:</p>
<p>path = ‘datasets/babynames/yob%d.txt’ % year</p>
<p>frame = pd.read_csv(path, names=columns)</p>
<p>frame[‘year’] = year</p>
<p>pieces.append(frame)</p>
<p>names = pd.concat(pieces, ignore_index=True)#合并表格</p>
<p>total_births = names.pivot_table(‘births’, index=’year’,</p>
<p>…..: columns=’sex’, aggfunc=sum)</p>
<p>def add_prop(group):</p>
<p>group[‘prop’] = group.births / group.births.sum()</p>
<p>return group</p>
<p>names = names.groupby([‘year’, ‘sex’]).apply(add_prop)</p>
<p>names.groupby([‘year’, ‘sex’]).prop.sum()</p>
<p>def get_top1000(group):</p>
<p>return group.sort_values(by=’births’, ascending=False)[:1000]</p>
<p>grouped = names.groupby([‘year’, ‘sex’])</p>
<p>top1000 = grouped.apply(get_top1000)</p>
<p>top1000.reset_index(inplace=True, drop=True)</p>
<p>for year, group in names.groupby([‘year’, ‘sex’]):</p>
<p>pieces.append(group.sort_values(by=’births’, ascending=False)[:1000])</p>
<p>top1000 = pd.concat(pieces, ignore_index=True)</p>
<p>total_births = top1000.pivot_table(‘births’, index=’year’,</p>
<p>…..: columns=’name’,aggfunc=sum)</p>
<p>subset.plot(subplots=True, figsize=(12, 10), grid=False,</p>
<p>…..: title=”Number of births per year”)</p>
<p>table = top1000.pivot_table(‘prop’, index=’year’,</p>
<p>…..: columns=’sex’, aggfunc=sum)</p>
<p>table.plot(title=’Sum of table1000.prop by year and sex’,</p>
<p>…..: yticks=np.linspace(0, 1.2, 13), xticks=range(1880, 2020, 10))</p>
<p>prop_cumsum = df.sort_values(by=’prop’, ascending=False).prop.cumsum()</p>
<p>prop_cumsum.values.searchsorted(0.5)</p>
<p>in1900 = df.sort_values(by=’prop’, ascending=False).prop.cumsum()</p>
<p>in1900.values.searchsorted(0.5) + 1</p>
<p>def get_quantile_count(group, q=0.5):</p>
<p>group = group.sort_values(by=’prop’, ascending=False)</p>
<p>return group.prop.cumsum().values.searchsorted(q) + 1</p>
<p>diversity = top1000.groupby([‘year’, ‘sex’]).apply(get_quantile_count)</p>
<p>diversity = diversity.unstack(‘sex’)</p>
<p>table = names.pivot_table(‘births’, index=last_letters,</p>
<p>columns=[‘sex’, ‘year’], aggfunc=sum)</p>
<p>subtable = table.reindex(columns=[1910, 1960, 2010], level=’year’)</p>
<p>letter_prop = subtable / subtable.sum()</p>
<p>fig, axes = plt.subplots(2, 1, figsize=(10, 8))</p>
<p>letter_prop[‘M’].plot(kind=’bar’, rot=0, ax=axes[0], title=’Male’)</p>
<p>dny_ts = letter_prop.loc[[‘d’, ‘n’, ‘y’], ‘M’].T</p>
<p>all_names = pd.Series(top1000.name.unique())</p>
<p>lesley_like = all_names[all_names.str.lower().str.contains(‘lesl’)]</p>
<p>filtered = top1000[top1000.name.isin(lesley_like)]</p>
<p>filtered.groupby(‘name’).births.sum()</p>
<p>table = filtered.pivot_table(‘births’, index=’year’,</p>
<p>…..: columns=’sex’, aggfunc=’sum’)</p>
<p>table = table.div(table.sum(1), axis=0)</p>
<p>table.plot(style={‘M’: ‘k-‘, ‘F’: ‘k–’})</p>
<p>·后记<br>这一节涉及的统计学知识还是比较多的，对大数量的数据找特定维度展开分析给出了很多有用的实际案例。(下班撸一遍代码累成小番薯)</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/68766758">参考</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38093168">参考二</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://earyant.github.io/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Earyant">
      <meta itemprop="description" content="个人技术博客，分享开发中遇到的问题，以及想学的新技术，会持续更新，可以订阅rss。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Earyant的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/" class="post-title-link" itemprop="url">利用python进行数据分析-数据清洗</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-21 22:38:52 / 修改时间：22:44:12" itemprop="dateCreated datePublished" datetime="2021-09-21T22:38:52+08:00">2021-09-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://earyant.github.io/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-pandas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Earyant">
      <meta itemprop="description" content="个人技术博客，分享开发中遇到的问题，以及想学的新技术，会持续更新，可以订阅rss。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Earyant的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-pandas/" class="post-title-link" itemprop="url">利用python进行数据分析-pandas</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-21 22:38:35 / 修改时间：23:12:08" itemprop="dateCreated datePublished" datetime="2021-09-21T22:38:35+08:00">2021-09-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一、第14章 数据分析案例<br>本书正文的最后一章，我们来看一些真实世界的数据集。对于每个数据集，我们会用之前介绍的方法，从原始数据中提取有意义的内容。展示的方法适用于其它数据集，也包括你的。本章包含了一些各种各样的案例数据集，可以用来练习。</p>
<p>下载本书代码：<a target="_blank" rel="noopener" href="https://github.com/wesm/pydata-book%EF%BC%88%E5%BB%BA%E8%AE%AE%E6%8A%8A%E4%BB%A3%E7%A0%81%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%AE%89%E8%A3%85%E5%A5%BDAnaconda">https://github.com/wesm/pydata-book（建议把代码下载下来之后，安装好Anaconda</a> 3.6，在目录文件夹中用Jupyter notebook打开）</p>
<p>二、实例<br>2.4 MovieLens 1M数据集<br>GroupLens Research（<a target="_blank" rel="noopener" href="http://www.grouplens.org/node/73%EF%BC%89%E9%87%87%E9%9B%86%E4%BA%86%E4%B8%80%E7%BB%84%E4%BB%8E20%E4%B8%96%E7%BA%AA90%E5%B9%B4%E6%9C%AB%E5%88%B021%E4%B8%96%E7%BA%AA%E5%88%9D%E7%94%B1MovieLens%E7%94%A8%E6%88%B7%E6%8F%90%E4%BE%9B%E7%9A%84%E7%94%B5%E5%BD%B1%E8%AF%84%E5%88%86%E6%95%B0%E6%8D%AE%E3%80%82%E8%BF%99%E4%BA%9B%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8C%85%E6%8B%AC%E7%94%B5%E5%BD%B1%E8%AF%84%E5%88%86%E3%80%81%E7%94%B5%E5%BD%B1%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%88%E9%A3%8E%E6%A0%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%B9%B4%E4%BB%A3%EF%BC%89%E4%BB%A5%E5%8F%8A%E5%85%B3%E4%BA%8E%E7%94%A8%E6%88%B7%E7%9A%84%E4%BA%BA%E5%8F%A3%E7%BB%9F%E8%AE%A1%E5%AD%A6%E6%95%B0%E6%8D%AE%EF%BC%88%E5%B9%B4%E9%BE%84%E3%80%81%E9%82%AE%E7%BC%96%E3%80%81%E6%80%A7%E5%88%AB%E5%92%8C%E8%81%8C%E4%B8%9A%E7%AD%89%EF%BC%89%E3%80%82%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B8%80%E8%88%AC%E9%83%BD%E4%BC%9A%E5%AF%B9%E6%AD%A4%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%84%9F%E5%85%B4%E8%B6%A3%E3%80%82%E8%99%BD%E7%84%B6%E6%88%91%E4%B8%8D%E4%BC%9A%E5%9C%A8%E6%9C%AC%E4%B9%A6%E4%B8%AD%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%EF%BC%8C%E4%BD%86%E6%88%91%E4%BC%9A%E5%91%8A%E8%AF%89%E4%BD%A0%E5%A6%82%E4%BD%95%E5%AF%B9%E8%BF%99%E7%A7%8D%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%88%87%E7%89%87%E5%88%87%E5%9D%97%E4%BB%A5%E6%BB%A1%E8%B6%B3%E5%AE%9E%E9%99%85%E9%9C%80%E6%B1%82%E3%80%82">http://www.grouplens.org/node/73）采集了一组从20世纪90年末到21世纪初由MovieLens用户提供的电影评分数据。这些数据中包括电影评分、电影元数据（风格类型和年代）以及关于用户的人口统计学数据（年龄、邮编、性别和职业等）。基于机器学习算法的推荐系统一般都会对此类数据感兴趣。虽然我不会在本书中详细介绍机器学习技术，但我会告诉你如何对这种数据进行切片切块以满足实际需求。</a></p>
<p>MovieLens 1M数据集含有来自6000名用户对4000部电影的100万条评分数据。它分为三个表：评分、用户信息和电影信息。将该数据从zip文件中解压出来之后，可以通过pandas.read_table将各个表分别读到一个pandas DataFrame对象中：</p>
<p>import pandas as pd</p>
<p>pd.options.display.max_rows = 10 #限制显示数量</p>
<p>unames = [‘user_id’, ‘gender’, ‘age’, ‘occupation’, ‘zip’]</p>
<p>users = pd.read_table(‘datasets/movielens/users.dat’, sep=’::’,</p>
<p>header=None, names=unames)</p>
<p>rnames = [‘user_id’, ‘movie_id’, ‘rating’, ‘timestamp’]</p>
<p>ratings = pd.read_table(‘datasets/movielens/ratings.dat’, sep=’::’,</p>
<p>header=None, names=rnames)</p>
<p>mnames = [‘movie_id’, ‘title’, ‘genres’]</p>
<p>movies = pd.read_table(‘datasets/movielens/movies.dat’, sep=’::’,</p>
<p>header=None, names=mnames)</p>
<p>利用Python的切片语法，通过查看每个DataFrame的前几行即可验证数据加载工作是否一切顺利：</p>
<p>In [69]: users[:5]</p>
<p>Out[69]:</p>
<p>user_id gender age occupation zip</p>
<p>0 1 F 1 10 48067</p>
<p>1 2 M 56 16 70072</p>
<p>2 3 M 25 15 55117</p>
<p>3 4 M 45 7 02460</p>
<p>4 5 M 25 20 55455</p>
<p>In [70]: ratings[:5]</p>
<p>Out[70]:</p>
<p>user_id movie_id rating timestamp</p>
<p>0 1 1193 5 978300760</p>
<p>1 1 661 3 978302109</p>
<p>2 1 914 3 978301968</p>
<p>3 1 3408 4 978300275</p>
<p>4 1 2355 5 978824291</p>
<p>In [71]: movies[:5]</p>
<p>Out[71]:</p>
<p>movie_id title genres</p>
<p>0 1 Toy Story (1995) Animation|Children’s|Comedy</p>
<p>1 2 Jumanji (1995) Adventure|Children’s|Fantasy</p>
<p>2 3 Grumpier Old Men (1995) Comedy|Romance</p>
<p>3 4 Waiting to Exhale (1995) Comedy|Drama</p>
<p>4 5 Father of the Bride Part II (1995) Comedy</p>
<p>In [72]: ratings</p>
<p>Out[72]:</p>
<p>user_id movie_id rating timestamp</p>
<p>0 1 1193 5 978300760</p>
<p>1 1 661 3 978302109</p>
<p>2 1 914 3 978301968</p>
<p>3 1 3408 4 978300275</p>
<p>4 1 2355 5 978824291</p>
<p>… … … … …</p>
<p>1000204 6040 1091 1 956716541</p>
<p>1000205 6040 1094 5 956704887</p>
<p>1000206 6040 562 5 956704746</p>
<p>1000207 6040 1096 4 956715648</p>
<p>1000208 6040 1097 4 956715569</p>
<p>注意，其中的年龄和职业是以编码形式给出的，它们的具体含义请参考该数据集的README文件。分析散布在三个表中的数据可不是一件轻松的事情。假设我们想要根据性别和年龄计算某部电影的平均得分，如果将所有数据都合并到一个表中的话问题就简单多了。我们先用pandas的merge函数将ratings跟users合并到一起，然后再将movies也合并进去。pandas会根据列名的重叠情况推断出哪些列是合并（或连接）键：</p>
<p>In [73]: data = pd.merge(pd.merge(ratings, users), movies)</p>
<p>In [74]: data</p>
<p>Out[74]:</p>
<p>user_id … genres</p>
<p>0 1 … Drama</p>
<p>1 2 … Drama</p>
<p>2 12 … Drama</p>
<p>3 15 … Drama</p>
<p>4 17 … Drama</p>
<p>… … … …</p>
<p>1000204 5949 … Documentary</p>
<p>1000205 5675 … Drama</p>
<p>1000206 5780 … Drama</p>
<p>1000207 5851 … Comedy|Drama|Western</p>
<p>1000208 5938 … Documentary</p>
<p>[1000209 rows x 10 columns]</p>
<p>In [75]: data.iloc[0]</p>
<p>Out[75]:</p>
<p>user_id 1</p>
<p>movie_id 1193</p>
<p>rating 5</p>
<p>timestamp 978300760</p>
<p>gender F</p>
<p>age 1</p>
<p>occupation 10</p>
<p>zip 48067</p>
<p>title One Flew Over the Cuckoo’s Nest (1975)</p>
<p>genres Drama</p>
<p>Name: 0, dtype: object</p>
<p>为了按性别计算每部电影的平均得分，我们可以使用pivot_table方法：</p>
<p>In [76]: mean_ratings = data.pivot_table(‘rating’, index=’title’,</p>
<p>….: columns=’gender’, aggfunc=’mean’)</p>
<p>In [77]: mean_ratings[:5]</p>
<p>Out[77]:</p>
<p>gender F M</p>
<p>title</p>
<p>$1,000,000 Duck (1971) 3.375000 2.761905</p>
<p>‘Night Mother (1986) 3.388889 3.352941</p>
<p>‘Til There Was You (1997) 2.675676 2.733333</p>
<p>‘burbs, The (1989) 2.793478 2.962085</p>
<p>…And Justice for All (1979) 3.828571 3.689024</p>
<p>该操作产生了另一个DataFrame，其内容为电影平均得分，行标为电影名称，列标为性别。现在，我打算过滤掉评分数据不够250条的电影。为了达到这个目的，我先对title进行分组，然后利用size()得到一个含有各电影分组大小的Series对象：</p>
<p>In [78]: ratings_by_title = data.groupby(‘title’).size()</p>
<p>In [79]: ratings_by_title[:10]</p>
<p>Out[79]:</p>
<p>title</p>
<p>$1,000,000 Duck (1971) 37</p>
<p>‘Night Mother (1986) 70</p>
<p>‘Til There Was You (1997) 52</p>
<p>‘burbs, The (1989) 303</p>
<p>…And Justice for All (1979) 199</p>
<p>1-900 (1994) 2</p>
<p>10 Things I Hate About You (1999) 700</p>
<p>101 Dalmatians (1961) 565</p>
<p>101 Dalmatians (1996) 364</p>
<p>12 Angry Men (1957) 616</p>
<p>dtype: int64</p>
<p>In [80]: active_titles = ratings_by_title.index[ratings_by_title &gt;= 250]</p>
<p>In [81]: active_titles</p>
<p>Out[81]:</p>
<p>Index([‘’burbs, The (1989)’, ‘10 Things I Hate About You (1999)’,</p>
<p>‘101 Dalmatians (1961)’, ‘101 Dalmatians (1996)’, ‘12 Angry Men (1957)’,</p>
<p>‘13th Warrior, The (1999)’, ‘2 Days in the Valley (1996)’,</p>
<p>‘20,000 Leagues Under the Sea (1954)’, ‘2001: A Space Odyssey (1968)’,</p>
<p>‘2010 (1984)’,</p>
<p>…</p>
<p>‘X-Men (2000)’, ‘Year of Living Dangerously (1982)’,</p>
<p>‘Yellow Submarine (1968)’, ‘You’ve Got Mail (1998)’,</p>
<p>‘Young Frankenstein (1974)’, ‘Young Guns (1988)’,</p>
<p>‘Young Guns II (1990)’, ‘Young Sherlock Holmes (1985)’,</p>
<p>‘Zero Effect (1998)’, ‘eXistenZ (1999)’],</p>
<p>dtype=’object’, name=’title’, length=1216)</p>
<p>标题索引中含有评分数据大于250条的电影名称，然后我们就可以据此从前面的mean_ratings中选取所需的行了：</p>
<p>In [82]: mean_ratings = mean_ratings.loc[active_titles]</p>
<p>In [83]: mean_ratings</p>
<p>Out[83]:</p>
<p>gender F M</p>
<p>title</p>
<p>‘burbs, The (1989) 2.793478 2.962085</p>
<p>10 Things I Hate About You (1999) 3.646552 3.311966</p>
<p>101 Dalmatians (1961) 3.791444 3.500000</p>
<p>101 Dalmatians (1996) 3.240000 2.911215</p>
<p>12 Angry Men (1957) 4.184397 4.328421</p>
<p>… … …</p>
<p>Young Guns (1988) 3.371795 3.425620</p>
<p>Young Guns II (1990) 2.934783 2.904025</p>
<p>Young Sherlock Holmes (1985) 3.514706 3.363344</p>
<p>Zero Effect (1998) 3.864407 3.723140</p>
<p>eXistenZ (1999) 3.098592 3.289086</p>
<p>[1216 rows x 2 columns]</p>
<p>为了了解女性观众最喜欢的电影，我们可以对F列降序排列：</p>
<p>In [85]: top_female_ratings = mean_ratings.sort_values(by=’F’, ascending=False)</p>
<p>In [86]: top_female_ratings[:10]</p>
<p>Out[86]:</p>
<p>gender F M<br>title<br>Close Shave, A (1995) 4.644444 4.473795<br>Wrong Trousers, The (1993) 4.588235 4.478261<br>Sunset Blvd. (a.k.a. Sunset Boulevard) (1950) 4.572650 4.464589<br>Wallace &amp; Gromit: The Best of Aardman Animation… 4.563107 4.385075<br>Schindler’s List (1993) 4.562602 4.491415<br>Shawshank Redemption, The (1994) 4.539075 4.560625<br>Grand Day Out, A (1992) 4.537879 4.293255<br>To Kill a Mockingbird (1962) 4.536667 4.372611<br>Creature Comforts (1990) 4.513889 4.272277<br>Usual Suspects, The (1995) 4.513317 4.518248<br>2.5计算评分分歧<br>假设我们想要找出男性和女性观众分歧最大的电影。一个办法是给mean_ratings加上一个用于存放平均得分之差的列，并对其进行排序：</p>
<p>In [87]: mean_ratings[‘diff’] = mean_ratings[‘M’] - mean_ratings[‘F’]</p>
<p>按”diff”排序即可得到分歧最大且女性观众更喜欢的电影：</p>
<p>In [88]: sorted_by_diff = mean_ratings.sort_values(by=’diff’)</p>
<p>In [89]: sorted_by_diff[:10]</p>
<p>Out[89]:</p>
<p>gender F M diff</p>
<p>title</p>
<p>Dirty Dancing (1987) 3.790378 2.959596 -0.830782</p>
<p>Jumpin’ Jack Flash (1986) 3.254717 2.578358 -0.676359</p>
<p>Grease (1978) 3.975265 3.367041 -0.608224</p>
<p>Little Women (1994) 3.870588 3.321739 -0.548849</p>
<p>Steel Magnolias (1989) 3.901734 3.365957 -0.535777</p>
<p>Anastasia (1997) 3.800000 3.281609 -0.518391</p>
<p>Rocky Horror Picture Show, The (1975) 3.673016 3.160131 -0.512885</p>
<p>Color Purple, The (1985) 4.158192 3.659341 -0.498851</p>
<p>Age of Innocence, The (1993) 3.827068 3.339506 -0.487561</p>
<p>Free Willy (1993) 2.921348 2.438776 -0.482573</p>
<p>对排序结果反序并取出前10行，得到的则是男性观众更喜欢的电影：</p>
<p>In [90]: sorted_by_diff[::-1][:10] #倒序</p>
<p>Out[90]:</p>
<p>gender F M diff</p>
<p>title</p>
<p>Good, The Bad and The Ugly, The (1966) 3.494949 4.221300 0.726351</p>
<p>Kentucky Fried Movie, The (1977) 2.878788 3.555147 0.676359</p>
<p>Dumb &amp; Dumber (1994) 2.697987 3.336595 0.638608</p>
<p>Longest Day, The (1962) 3.411765 4.031447 0.619682</p>
<p>Cable Guy, The (1996) 2.250000 2.863787 0.613787</p>
<p>Evil Dead II (Dead By Dawn) (1987) 3.297297 3.909283 0.611985</p>
<p>Hidden, The (1987) 3.137931 3.745098 0.607167</p>
<p>Rocky III (1982) 2.361702 2.943503 0.581801</p>
<p>Caddyshack (1980) 3.396135 3.969737 0.573602</p>
<p>For a Few Dollars More (1965) 3.409091 3.953795 0.544704</p>
<p>如果只是想要找出分歧最大的电影（不考虑性别因素），则可以计算得分数据的方差或标准差：</p>
<p>In [91]: rating_std_by_title = data.groupby(‘title’)[‘rating’].std()#标准差</p>
<p>In [92]: rating_std_by_title = rating_std_by_title.loc[active_titles]#选择列</p>
<p>In [93]: rating_std_by_title.sort_values(ascending=False)[:10]#排序</p>
<p>Out[93]:</p>
<p>title</p>
<p>Dumb &amp; Dumber (1994) 1.321333</p>
<p>Blair Witch Project, The (1999) 1.316368</p>
<p>Natural Born Killers (1994) 1.307198</p>
<p>Tank Girl (1995) 1.277695</p>
<p>Rocky Horror Picture Show, The (1975) 1.260177</p>
<p>Eyes Wide Shut (1999) 1.259624</p>
<p>Evita (1996) 1.253631</p>
<p>Billy Madison (1995) 1.249970</p>
<p>Fear and Loathing in Las Vegas (1998) 1.246408</p>
<p>Bicentennial Man (1999) 1.245533</p>
<p>Name: rating, dtype: float64</p>
<p>可能你已经注意到了，电影分类是以竖线（|）分隔的字符串形式给出的。如果想对电影分类进行分析的话，就需要先将其转换成更有用的形式才行。</p>
<p>三、小结<br>pd.options.display.max_rows = 10 #限制显示数量</p>
<p>data = pd.merge(pd.merge(ratings, users), movies)</p>
<p>data.iloc[0]</p>
<p>mean_ratings = data.pivot_table(‘rating’, index=’title’,</p>
<p>….: columns=’gender’, aggfunc=’mean’)</p>
<p>ratings_by_title = data.groupby(‘title’).size()</p>
<p>active_titles = ratings_by_title.index[ratings_by_title &gt;= 250]</p>
<p>mean_ratings = mean_ratings.loc[active_titles]</p>
<p>top_female_ratings = mean_ratings.sort_values(by=’F’, ascending=False)</p>
<p>mean_ratings[‘diff’] = mean_ratings[‘M’] - mean_ratings[‘F’]</p>
<p>sorted_by_diff = mean_ratings.sort_values(by=’diff’)</p>
<p>sorted_by_diff[::-1][:10] #倒序</p>
<p>rating_std_by_title = data.groupby(‘title’)[‘rating’].std()#标准差</p>
<p>rating_std_by_title = rating_std_by_title.loc[active_titles]#选择列</p>
<p>rating_std_by_title.sort_values(ascending=False)[:10]#排序</p>
<p>·后记<br>最后一章，查缺补漏。本节涉及了表的读取、合并、选择、透视、分组、排序、筛选、统计，功能相对齐全。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://earyant.github.io/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-numpy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Earyant">
      <meta itemprop="description" content="个人技术博客，分享开发中遇到的问题，以及想学的新技术，会持续更新，可以订阅rss。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Earyant的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-numpy/" class="post-title-link" itemprop="url">利用python进行数据分析-numpy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-09-21 22:29:02 / 修改时间：22:50:07" itemprop="dateCreated datePublished" datetime="2021-09-21T22:29:02+08:00">2021-09-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- toc -->

<ul>
<li><a href="#%E4%B8%80-numpy%E5%8C%85%E7%AE%80%E4%BB%8B">一、NumPy包简介</a><ul>
<li><a href="#11-%E7%AE%80%E4%BB%8B">1.1 简介</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%AE%9E%E4%BE%8B">二、实例</a><ul>
<li><a href="#21-%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94">2.1 性能对比</a></li>
<li><a href="#22-%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0">2.2 产生随机数</a></li>
<li><a href="#23-%E6%89%B9%E9%87%8F%E8%BF%90%E7%AE%97">2.3 批量运算</a></li>
<li><a href="#24-%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84">2.4 创建数组</a></li>
<li><a href="#25-ndarray%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2.5 ndarray的数据类型</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E5%B0%8F%E7%BB%93">三、小结</a></li>
</ul>
<!-- tocstop -->

<p>书摘前言：</p>
<p>《利用Python进行数据分析·第2版》是量化分析前置中非常具有教科书意义的一本书，其中前三章为基础知识。第四章起是相对重要的内容，也是此文收录的内容和我的一些想法，依托每篇文章两千字左右的篇幅拆分成几篇。感谢作者McKinney和SeanCheney。</p>
<h1><span id="一-numpy包简介">一、NumPy包简介</span></h1><h2><span id="11-简介">1.1 简介</span></h2><p>该包是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。</p>
<p>NumPy最重要的一个特点就是其N维数组对象（即ndarray），该对象是一个快速而灵活的大数据集容器。后续所有提到的数组都是指ndarry。</p>
<h1><span id="二-实例">二、实例</span></h1><h2><span id="21-性能对比">2.1 性能对比</span></h2><p>要搞明白具体的性能差距，考察一个包含一百万整数的数组，和一个等价的Python列表：</p>
<p>In [7]: import numpy as np #np为通用简写,测试环境为ipython</p>
<p>In [8]: my_arr = np.arange(1000000) #所有涉及np的代码建议手打一遍</p>
<p>In [9]: my_list = list(range(1000000))</p>
<p>#各个序列分别乘以2：</p>
<p>In [10]: %time for _ in range(10): my_arr2 = my_arr * 2</p>
<p>CPU times: user 20 ms, sys: 50 ms, total: 70 ms</p>
<p>Wall time: 72.4 ms #我的是22ms</p>
<p>In [11]: %time for _ in range(10): my_list2 = [x * 2 for x in my_list]</p>
<p>CPU times: user 760 ms, sys: 290 ms, total: 1.05 s</p>
<p>Wall time: 1.05 s #我的是1.37s</p>
<p>基于NumPy的算法要比纯Python快10到100倍（甚至更快），并且使用的内存更少。#我的耗时为1370ms:22ms,折合62倍</p>
<h2><span id="22-产生随机数">2.2 产生随机数</span></h2><p>In [12]: import numpy as np</p>
<p>In [13]: data = np.random.randn(2, 3)#2,3为2行3列</p>
<p>In [14]: data</p>
<p>Out[14]:</p>
<p>array([[-0.2047, 0.4789, -0.5194],</p>
<p>[-0.5557, 1.9658, 1.3934]])</p>
<h2><span id="23-批量运算">2.3 批量运算</span></h2><p>In [15]: data * 10 #进行整体的数学运算,数值10倍</p>
<p>Out[15]:</p>
<p>array([[ -2.0471, 4.7894, -5.1944],</p>
<p>[ -5.5573, 19.6578, 13.9341]])</p>
<p>·原数组乘2,可以用*实现数组内全数平方</p>
<p>In [16]: data + data</p>
<p>Out[16]:</p>
<p>array([[-0.4094, 0.9579, -1.0389],</p>
<p>[-1.1115, 3.9316, 2.7868]])</p>
<p>·ndarray中的所有元素必须是相同类型的。每个数组都有一个shape（一个表示各维度大小的元组）和一个dtype（一个用于说明数组数据类型的对象）：</p>
<p>In [17]: data.shape #几行几列</p>
<p>Out[17]: (2, 3)</p>
<p>In [18]: data.dtype #数据类型dtype=datatype</p>
<p>Out[18]: dtype(‘float64’)</p>
<p>·数组大小的对比</p>
<p>In [51]: arr = np.array([[1., 2., 3.], [4., 5., 6.]])</p>
<p>In [57]: arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])</p>
<p>In [59]: arr2 &gt; arr</p>
<p>Out[59]:</p>
<p>array([[False, True, False],</p>
<p>[ True, False, True]])</p>
<h2><span id="24-创建数组">2.4 创建数组</span></h2><p>·创建数组最简单的办法就是使用array函数。</p>
<p>In [19]: data1 = [6, 7.5, 8, 0, 1]</p>
<p>In [20]: arr1 = np.array(data1) #转化为ndarry</p>
<p>In [21]: arr1</p>
<p>Out[21]: array([ 6. , 7.5, 8. , 0. , 1. ])</p>
<p>·嵌套序列将会被转换为一个多维数组：</p>
<p>In [22]: data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]</p>
<p>In [23]: arr2 = np.array(data2) #转化为2行两列的多维数组</p>
<p>In [24]: arr2</p>
<p>Out[24]:</p>
<p>array([[1, 2, 3, 4],</p>
<p>[5, 6, 7, 8]])</p>
<p>·数组的行列数统计</p>
<p>In [25]: arr2.ndim #行数函数,代表两行</p>
<p>Out[25]: 2</p>
<p>In [26]: arr2.shape#数组的行数和列数组成的元组</p>
<p>Out[26]: (2, 4)</p>
<p>·zeros和ones分别可以创建指定长度或形状的全0或全1数组。</p>
<p>empty可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元组即可：</p>
<p>In [30]: np.zeros((3, 6))</p>
<p>Out[30]:</p>
<p>array([[ 0., 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0., 0.],</p>
<p>[ 0., 0., 0., 0., 0., 0.]])</p>
<p>In [31]: np.empty((2, 3, 2)) #返回的不一定是0,可能是任何数</p>
<p>Out[31]:</p>
<p>array([[[ 0., 0.], [ 0., 0.], [ 0., 0.]], [[ 0., 0.],</p>
<p>[ 0., 0.], [ 0., 0.]]])</p>
<p>·由于NumPy关注的是数值计算，因此，如果没有特别指定，数据类型基本都是float64（浮点数）</p>
<h2><span id="25-ndarray的数据类型">2.5 ndarray的数据类型</span></h2><p>dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息：</p>
<p>In [33]: arr1 = np.array([1, 2, 3], dtype=np.float64)</p>
<p>In [35]: arr1.dtype</p>
<p>Out[35]: dtype(‘float64’)</p>
<p>·NumPy的数据类型（简单了解即可，后续实例中慢慢掌握）</p>
<p>int8、uint8（i1、 u1）：有符号和无符号的8位(1个字节)整型</p>
<p>int16、uint16（i2、u2）： 有符号和无符号的16位(2个字节)整型</p>
<p>int32、uint32（i4、u4）：有符号和无符号的32位(4个字节)整型</p>
<p>int64、uint64（i8、u8）：有符号和无符号的64位(8个字节)整型</p>
<p>float16 （f2）： 半精度浮点数</p>
<p>float32（f4或f）： 标准的单精度浮点数。与C的float兼 容</p>
<p>float64（f8或d）： 标准的双精度浮点数。</p>
<p>float128（f16或g） ：扩展精度浮点数</p>
<p>complex64、complex128、complex256（c8 c16 c32）分别用两个32位、64位或128位浮点数表示的复数</p>
<p>bool 存储True和False值的布尔类型</p>
<p>·你可以通过ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype：</p>
<p>In [37]: arr = np.array([1, 2, 3, 4, 5])</p>
<p>In [38]: arr.dtype</p>
<p>Out[38]: dtype(‘int64’)</p>
<p>In [39]: float_arr = arr.astype(np.float64)</p>
<p>In [40]: float_arr.dtype</p>
<p>Out[40]: dtype(‘float64’)</p>
<p>·如果转换反向把小数转整数,则会直接去掉小数部分。字符串如果全是数字，也可以转换为数值。</p>
<p>·数组的切片</p>
<p>In [60]: arr = np.arange(10)</p>
<p>In [61]: arr</p>
<p>Out[61]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</p>
<p>In [62]: arr[5]</p>
<p>Out[62]: 5</p>
<p>In [63]: arr[5:8]</p>
<p>Out[63]: array([5, 6, 7])</p>
<p>In [64]: arr[5:8] = 12</p>
<p>In [65]: arr</p>
<p>Out[65]: array([ 0, 1, 2, 3, 4, 12, 12, 12, 8, 9])</p>
<p>当你将一个标量值赋值给一个切片时（如arr[5:8]=12），该值会自动传播到整个选区。跟列表最重要的区别在于，数组切片是原始数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。</p>
<p>·注意：如果你想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作:arr[5:8].copy()。</p>
<p>·对于高维度数组，能做的事情更多。在一个二维数组中，各索引位置上的元素不再是标量而是一维数组：</p>
<p>In [72]: arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</p>
<p>In [73]: arr2d[2]</p>
<p>Out[73]: array([7, 8, 9])</p>
<p>·你可以传入一个以逗号隔开的索引列表来选取单个元素。也就是说，下面两种方式是等价的：</p>
<p>In [74]: arr2d[0][2]</p>
<p>Out[74]: 3</p>
<p>In [75]: arr2d[0, 2]</p>
<p>Out[75]: 3</p>
<p>·索引列表中相当于数组的一部分,操作部分同样会影响到整体</p>
<p>·多维数组切片，可以选取第二行的前两列,通过对切片的影响,可以变更数组的部分：</p>
<p>In [93]: arr2d[1, :2]</p>
<p>Out[93]: array([4, 5])</p>
<h1><span id="三-小结">三、小结</span></h1><p>import numpy as np #导入</p>
<p>np.arange(1000000) #生成一个0至999999的数组</p>
<p>np.random.randn(2, 3) #产生一个2行3列的随机数</p>
<p>arr1 = np.array(data1) #建立数组</p>
<p>data.shape #数组的行列数</p>
<p>data.dtype #数组的类型</p>
<p>arr2.ndim #数组的行数</p>
<p>np.zeros(10) #生成包含10个0的一维数组</p>
<p>np.empty((2, 3, 2)) #生成2个3行2列的数组</p>
<p>arr1 = np.array([1, 2, 3], dtype=np.float64) #建立指定类型的数组</p>
<p>float_arr = arr.astype(np.float64) #借鉴其他数组建立不同类型数组</p>
<p>arr[5:8].copy() #复制一个一样的数组</p>
<p>arr2d[0][2] #取数组的部分</p>
<p>arr2d[1, :2] #数组切片</p>
<p>此处其实原文还有些许其他内容，但是个人建议可以等到有需求要用的时候再搜来学。</p>
<p>个人觉得，所有知识系统的核心应该是应用场景。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://earyant.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%A6%E5%8D%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Earyant">
      <meta itemprop="description" content="个人技术博客，分享开发中遇到的问题，以及想学的新技术，会持续更新，可以订阅rss。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Earyant的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%A6%E5%8D%95/" class="post-title-link" itemprop="url">机器学习书单</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-18 11:11:47" itemprop="dateCreated datePublished" datetime="2021-09-18T11:11:47+08:00">2021-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-21 14:24:52" itemprop="dateModified" datetime="2021-09-21T14:24:52+08:00">2021-09-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><ol>
<li>利用python进行数据分析</li>
</ol>
<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><ol>
<li>python机器学习基础教程</li>
<li>机器学习实战：基于Scikit-Learn和TensorFlow</li>
<li>机器学习（周志华）</li>
<li>统计学习方法（李航）</li>
<li>优达学城-机器学习入门</li>
<li>Cousera-机器学习-吴恩达</li>
<li>Python机器学习实践指南</li>
<li>Python机器学习——预测分析核心算法</li>
<li>实用机器学习</li>
<li>深入理解XGBoost：高效机器学习算法与进阶</li>
<li>分布式机器学习：算法、理论与实践</li>
</ol>
<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><ol>
<li>python神经网络编程</li>
<li>深度学习入门-基于python的理论与实现</li>
<li>python深度学习</li>
<li>深度学习</li>
<li>deeplearning.ai-深度学习吴恩达</li>
<li>TensorFlow技术解析与实战</li>
<li>精通Python自然语言处理</li>
<li>Hands-On Machine Learning with Scikit-Learn and TensorFlow</li>
</ol>
<h1 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h1><ol>
<li>Reinforcement learning</li>
</ol>
<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><ol>
<li>可汗学院</li>
<li>线性代数及其应用</li>
<li>概率论基础教程</li>
<li>统计学</li>
</ol>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><ol>
<li>智能风控：原理、算法与工程实践</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://earyant.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Earyant">
      <meta itemprop="description" content="个人技术博客，分享开发中遇到的问题，以及想学的新技术，会持续更新，可以订阅rss。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Earyant的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" class="post-title-link" itemprop="url">机器学习路线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-17 17:20:02" itemprop="dateCreated datePublished" datetime="2021-09-17T17:20:02+08:00">2021-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-18 15:57:49" itemprop="dateModified" datetime="2021-09-18T15:57:49+08:00">2021-09-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="机器学习路线图"><a href="#机器学习路线图" class="headerlink" title="机器学习路线图"></a>机器学习路线图</h1><h2 id="入门课程"><a href="#入门课程" class="headerlink" title="入门课程"></a>入门课程</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.coursera.org/learn/machine-learning">Machine Learning | Coursera</a><br>入门首选，推荐只认识“机器学习”四个字但还不知道它是什么的学习这些年机器学习的大多数年轻人靠这个入门。具体提纲我就不列了，免得增加篇幅。建议是直接按顺序一课课学，不要着急。在学完这个课程前，不要学后面的。<br>关于这门课的官方介绍是：本课程将广泛介绍机器学习、数据挖掘和统计模式识别。相关主题包括：(i) 监督式学习（参数和非参数算法、支持向量机、核函数和神经网络）。(ii) 无监督学习（集群、降维、推荐系统和深度学习）。(iii) 机器学习实例（偏见/方差理论；机器学习和AI领域的创新）。课程将引用很多案例和应用，您还需要学习如何在不同领域应用学习算法，例如智能机器人（感知和控制）、文本理解（网络搜索和垃圾邮件过滤）、计算机视觉、医学信息学、音频、数据库挖掘等领域。这门课基本涵盖了机器学习的主要知识点，例如：线性回归、逻辑回归、支持向量机、神经网络、K-Means、异常检测等等。而且课程中没有复杂的公式推导和理论分析。Ng 的目的是让机器学习初学者能够快速对整个机器学习知识点有比较整体的认识，便于快速入门。</li>
</ol>
<p><img src="https://pic1.zhimg.com/v2-2b979310ac6c053b9a96a1e594824934_b.jpg" alt="img"></p>
<ol start="2">
<li><p><a target="_blank" rel="noopener" href="http://cs231n.stanford.edu/">CS231n: Convolutional Neural Networks for Visual RecognitionStanford</a><br>最受欢迎的课之一.</p>
</li>
<li><p>机器学习体系图</p>
<p><img src="https://img-blog.csdnimg.cn/20190425205801254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE2MDYzMDc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ol>
<h1 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h1><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/tutorial/95/3cefbe4d0e914256b1271fe3417dded8">面试技巧</a><br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/experience?tagId=645">面经</a><br><a target="_blank" rel="noopener" href="https://www.nowcoder.com/ta/review-ml">面试题</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://earyant.github.io/posts/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Earyant">
      <meta itemprop="description" content="个人技术博客，分享开发中遇到的问题，以及想学的新技术，会持续更新，可以订阅rss。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Earyant的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">自己写一个数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-01 17:12:09" itemprop="dateCreated datePublished" datetime="2019-01-01T17:12:09+08:00">2019-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-18 15:57:49" itemprop="dateModified" datetime="2021-09-18T15:57:49+08:00">2021-09-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="godb"><a href="#godb" class="headerlink" title="godb"></a>godb</h1><blockquote>
<p>本项目中，数据库就是本地一个文件夹，表也是数据库下的目录，里面的数据就是表文件夹下的文件，<br>表目录下的scheme.json保存着表结构<br>表目录下data0.json data1.json分别存储着数据，每个文件里的数据不超过1000行。</p>
</blockquote>
<h2 id="设计逻辑"><a href="#设计逻辑" class="headerlink" title="设计逻辑"></a>设计逻辑</h2><ul>
<li>  代码分为client端和server端</li>
<li>  server端开启端口，接收指令，并执行指令</li>
<li>  client端连接端口，发送指令</li>
<li>server端分层执行<ul>
<li>  解析语句，判断类型，建库、建表、插入数据等等</li>
<li>  不同类型语句进入不同service执行，互不干扰</li>
<li>  验证语句，返回数据</li>
</ul>
</li>
</ul>
<h2 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h2><blockquote>
<p>暂时建表只支持这种格式，实际实现是在项目tmp目录下新建一个db1的文件夹</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database db1</span><br></pre></td></tr></table></figure>

<h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><blockquote>
<p>暂时只支持  ‘id’ 列名， varchar（255） 类型长度，以及默认值<br>以及主键<br>实际实现是在数据库目录下新建一个表名的文件夹，并有一个scheme.json文件记录各列属性</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>  table1 (`id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><blockquote>
<p>支持语句格式,value 只支持一个括号，values支持多个括号多行数据插入<br>实际实现是在表文件夹下，新建data(i).json文件，里面存储具体数据，i是预留数据量大的情况下的分文件存储，每个文件暂时最多支持存储1000行。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> feature_conf <span class="keyword">values</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>// TODO</p>
<ul>
<li>  [ ] 增加索引文件，指向data(i).json并指明多少列</li>
<li>  [ ] 索引文件分层，类似B+树存储</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://earyant.github.io/posts/String-intern%E6%96%B9%E6%B3%95%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Earyant">
      <meta itemprop="description" content="个人技术博客，分享开发中遇到的问题，以及想学的新技术，会持续更新，可以订阅rss。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Earyant的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/String-intern%E6%96%B9%E6%B3%95%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">String.intern方法理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-27 14:50:23" itemprop="dateCreated datePublished" datetime="2018-07-27T14:50:23+08:00">2018-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-18 15:57:49" itemprop="dateModified" datetime="2021-09-18T15:57:49+08:00">2021-09-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="intern作用"><a href="#intern作用" class="headerlink" title="intern作用"></a>intern作用</h2><blockquote>
<p>如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回</p>
</blockquote>
<p>先明白含义是什么，再看一道题，copy美团的文章，详见参考一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    s.intern();</span><br><span class="line">    String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    s3.intern();</span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>jdk7,8下false true<br>jdk6以下false false</p>
</blockquote>
<p>接下来把intern下移一行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    s.intern();</span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>;</span><br><span class="line">    s3.intern();</span><br><span class="line">    System.out.println(s3 == s4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>jdk7,8下false false<br>jdk6以下false false</p>
</blockquote>
<p>看完答案后，我是很懵逼的，我有看了美团文章的解释，瞬间，更懵逼了。美团文章解释的其实挺好的，但是没有抓住重点。<br>详细论证两篇文章都有，基本都能看明白（看不明白可以找我交流），重点在两点：</p>
<ul>
<li>jdk7、8和6有什么不同： 7以上将常量池从perm区移到了heap中</li>
<li>jdk7、8第一个程序中为什么一个是false，一个是true，<strong>jdk7以后常量去不仅仅可以保存对象，也可以保存对象的引用</strong>，所以s3的引用被保存到常量区中，s4直接在常量区找到了对象的引用，所以为true。</li>
</ul>
<p>有兴趣研究的同学，可以联系我，微信 ryry89，邮箱<a href="mailto:&#101;&#97;&#x72;&#x79;&#97;&#x6e;&#116;&#76;&#101;&#x65;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;">&#101;&#97;&#x72;&#x79;&#97;&#x6e;&#116;&#76;&#101;&#x65;&#x40;&#x67;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/in_depth_understanding_string_intern.html">参考一</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Kidezyq/p/8040338.html">参考二</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Earyant</p>
  <div class="site-description" itemprop="description">个人技术博客，分享开发中遇到的问题，以及想学的新技术，会持续更新，可以订阅rss。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">83</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/earyantLe" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;earyantLe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lirui940403@gmail.com" title="E-Mail → mailto:lirui940403@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/earyant" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;earyant" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/earyantLe" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;earyantLe" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/earyant" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;earyant" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/earyant" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;earyant" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Earyant</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
